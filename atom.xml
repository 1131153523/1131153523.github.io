<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://1131153523.github.io</id>
    <title>Gridea</title>
    <updated>2019-08-09T15:13:29.179Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://1131153523.github.io"/>
    <link rel="self" href="https://1131153523.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://1131153523.github.io/images/avatar.png</logo>
    <icon>https://1131153523.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[逐行级源码分析系列(一) Vuex]]></title>
        <id>https://1131153523.github.io/post/zhu-xing-ji-yuan-ma-fen-xi-xi-lie-yi-vuex</id>
        <link href="https://1131153523.github.io/post/zhu-xing-ji-yuan-ma-fen-xi-xi-lie-yi-vuex">
        </link>
        <updated>2019-08-09T15:08:13.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>首先这篇文章也是本人第一次发这种技术文章，错别字，分析错误，不知道的东西在所难免，希望大家指正，目前本人还是一位即将大四的学生，写这个系列的目的也是为了记录在源码中学习，通过写博客让我更加熟悉了源码及其内部完完整整的实现，通过这篇文章也让我对vuex的源码变得非常熟悉，在写这完篇文章之前，因为时间原因，断断续续写了两个星期，虽然已经看完了，但是要全部分析完并写出来，太耗费精力和时间。然后这个系列我打算按照这个顺序来写，我会尽量写完，也并非大放厥词，以下本人都已看完源码，排版可能有点差，我会慢慢学习，如果里面有错误，大佬轻喷。。</p>
<ul>
<li>逐行级源码分析系列(一) Vuex 源码</li>
<li>逐行级源码分析系列(二) Redux和React-Redux源码</li>
<li>逐行级源码分析系列(三) Vue-Router源码</li>
<li>逐行级源码分析系列(四) React-Router-Dom源码</li>
<li>逐行级源码分析系列(五) Express源码</li>
<li>逐行级源码分析系列(六) Koa核心源码</li>
<li>逐行级源码分析系列(六) Typescript版Axios源码</li>
</ul>
<h2 id="install">install</h2>
<p>当我们使用<code>Vue.use</code>会调用vuex的<code>install</code>方法，它的实现如下</p>
<pre><code class="language-javascript">export function install (_Vue) {
  if (Vue &amp;&amp; _Vue === Vue) {
    if (process.env.NODE_ENV !== 'production') {
      console.error(
        '[vuex] already installed. Vue.use(Vuex) should be called only once.'
      )
    }
    return
  }
  Vue = _Vue
  applyMixin(Vue)
}

</code></pre>
<p>这个方法传入了Vue构造函数,然后判断如果<code>_Vue === Vue</code>，则说明已经安装过了就直接返回，不做处理。然后调用了<code>applyMixin(Vue)</code>方法，我们来看下<code>applyMixin</code>方法实现</p>
<h2 id="applymixin">applyMixin</h2>
<pre><code class="language-javascript">
export default function (Vue) {
  const version = Number(Vue.version.split('.')[0])
  if (version &gt;= 2) {
    // 混入beforeCreate，vuexInit方法
    Vue.mixin({ beforeCreate: vuexInit })
  } else {
    const _init = Vue.prototype._init
    // 重写_init方法，把vuexInit方法，挂载到options中
    Vue.prototype._init = function (options = {}) {
      // 这里做了兼容处理，如果有其他库也使用了init方法，就把vuexInit添加到Init数组中
      options.init = options.init
        ? [vuexInit].concat(options.init)
        : vuexInit
      _init.call(this, options)
    }
  }

  /**
   * Vuex init hook, injected into each instances init hooks list.
   */

   // 这个方法的作用就是可以让每个组件都能通过this.$store放问到store对象
  function vuexInit () {
    // 获取mergeoptios选线
    const options = this.$options
    // 如果存在store属性
    if (options.store) {
      // 如果store是一个方法，就调用store，否则直接使用
      this.$store = typeof options.store === 'function'
        ? options.store()
        : options.store
    } else if (options.parent &amp;&amp; options.parent.$store) {
      // 获取父亲的$store属性
      this.$store = options.parent.$store
    }
  }
}

</code></pre>
<p>其实整个函数看起来似乎有点复杂</p>
<pre><code class="language-javascript">Vue.mixin({ beforeCreate: vuexInit })
</code></pre>
<p>其实只是调用了这段代码,因为这是vue2.0版本及以上才有的方法，我们这里只讨论vue2.0的情况，关于<code>mixin</code>的用法，这里不做介绍，它为所有的组件添加<code>beforeCreate</code>生命周期钩子</p>
<p>下面我们看一下<code>vuexInit</code>方法的实现</p>
<pre><code class="language-javascript">   // 这个方法的作用就是可以让每个组件都能通过this.$store放问到store对象
  function vuexInit () {
    // 获取mergeoptions的选项
    const options = this.$options
    // 这段if逻辑其实实在根组件中，添加了一个store属性，并赋给this.$store
    if (options.store) {
      // 如果store是一个方法，就调用store，否则直接使用
      this.$store = typeof options.store === 'function'
        ? options.store()
        : options.store
    } else if (options.parent &amp;&amp; options.parent.$store) {
      // 获取父亲的$store属性
      this.$store = options.parent.$store
    }
  }
</code></pre>
<p>首先，获取了<code>this.$options</code>,这段代码，如果大家有看过vue源码的应该知道，这是<code>mergeOptions</code>后的<code>options</code>, 先是判断是否存在<code>store</code>属性，如果不存在，就在父组件中查找，如果有就使用父组件中的<code>$store</code>，通过这种方式，能够在组件之间形成一种链式查找，其实本质上是引用了，根组件中的<code>store</code>,举个例子</p>
<pre><code class="language-javascript">new Vue({
  router,
  store,   // $store实际最终指向的都是这里的store
  render: h =&gt; h(App)
}).$mount('#app')
</code></pre>
<h2 id="new-vuexstoreoptions">new Vuex.Store(options)</h2>
<p>安装<code>install</code>完成之后，我们来看看<code>new Vuex.Store(options)</code>发生了什么,由于源码太多，就只截取构造函数中的代码，一起来看，vuex进行了哪些初始化操作</p>
<pre><code class="language-javascript">  constructor (options = {}) {
    if (!Vue &amp;&amp; typeof window !== 'undefined' &amp;&amp; window.Vue) {
      install(window.Vue)
    }

    if (process.env.NODE_ENV !== 'production') {
      assert(Vue, `must call Vue.use(Vuex) before creating a store instance.`)
      assert(typeof Promise !== 'undefined', `vuex requires a Promise polyfill in this browser.`)
      assert(this instanceof Store, `store must be called with the new operator.`)
    }

    const {
      plugins = [],
      strict = false //使 Vuex store 进入严格模式，在严格模式下，任何 mutation 处理函数以外修改 Vuex state 都会抛出错误。
    } = options


    this._committing = false   // 正在提交
    this._actions = Object.create(null)  // actions对象
    this._actionSubscribers = []  // actions订阅数组
    this._mutations = Object.create(null)  
    this._wrappedGetters = Object.create(null)
    this._modules = new ModuleCollection(options)  // 收集modules,
    this._modulesNamespaceMap = Object.create(null)
    this._subscribers = []
    this._watcherVM = new Vue()

    // bind commit and dispatch to self
    const store = this
    const { dispatch, commit } = this
    this.dispatch = function boundDispatch (type, payload) {
      return dispatch.call(store, type, payload)
    }
    this.commit = function boundCommit (type, payload, options) {
      return commit.call(store, type, payload, options)
    }

    // strict mode
    this.strict = strict

    // 根module的state属性
    const state = this._modules.root.state

    // init root module.
    // this also recursively registers all sub-modules
    // and collects all module getters inside this._wrappedGetters
    installModule(this, state, [], this._modules.root)

    // initialize the store vm, which is responsible for the reactivity
    // (also registers _wrappedGetters as computed properties)
    resetStoreVM(this, state)

    // apply plugins
    plugins.forEach(plugin =&gt; plugin(this))

    const useDevtools = options.devtools !== undefined ? options.devtools : Vue.config.devtools
    if (useDevtools) {
      devtoolPlugin(this)
    }
  }

</code></pre>
<pre><code class="language-javascript">    if (!Vue &amp;&amp; typeof window !== 'undefined' &amp;&amp; window.Vue) {
      install(window.Vue)
    }

    if (process.env.NODE_ENV !== 'production') {
      assert(Vue, `must call Vue.use(Vuex) before creating a store instance.`)
      assert(typeof Promise !== 'undefined', `vuex requires a Promise polyfill in this browser.`)
      assert(this instanceof Store, `store must be called with the new operator.`)
    }
</code></pre>
<p>这段代码我们不做讨论，相信大家也知道什么意思</p>
<pre><code class="language-javascript">    const {
     //一个数组，包含应用在 store 上的插件方法。这些插件直接接收 store 作为唯一参数，可以监听 mutation（用于外部地数据持久化、记录或调试）或者提交 mutation （用于内部数据，例如 websocket 或 某些观察者）
      plugins = [],
        
        
      strict = false //使 Vuex store 进入严格模式，在严格模式下，任何 mutation 处理函数以外修改 Vuex state 都会抛出错误。
    } = options
</code></pre>
<p>上面这段代码，获取了我们传入的配置<code>plugins</code>和<code>strict</code>，上面代码中标注有每个属性的作用，关于详细的使用可以到官网查看，以后会有讲解</p>
<pre><code class="language-javascript">    this._committing = false  
    this._actions = Object.create(null) 
    this._actionSubscribers = [] 

    this._mutations = Object.create(null)  

    this._wrappedGetters = Object.create(null)
    this._modules = new ModuleCollection(options) 
    this._modulesNamespaceMap = Object.create(null)
    this._subscribers = []
    this._watcherVM = new Vue()
</code></pre>
<p>这些代码做了一些属性的初始化，我们暂且不看具体是干什么用的，关键是下面这段代码</p>
<pre><code class="language-javascript">this._modules = new ModuleCollection(options) 
</code></pre>
<p>看到这段代码，我们肯定能立马想到，我们传入的<code>modules</code>配置，我们来看看<code>modules</code>做了哪些初始化</p>
<h3 id="new-modulecollectionoptions">new ModuleCollection(options)</h3>
<pre><code class="language-javascript">  constructor (rawRootModule) {
    this.register([], rawRootModule, false)
  }
</code></pre>
<p>这个类的构造函数只有简简单单的一行代码，它的参数<code>rawRootModule</code>,是我们给<code>Vuex.Store(options)</code>传入的完整的<code>options</code>,接下来看看<code>register</code>方法做了什么</p>
<pre><code class="language-javascript">  register (path, rawModule, runtime = true) {
    if (process.env.NODE_ENV !== 'production') {
      assertRawModule(path, rawModule)
    }
    // 创建Module对象，初始runtime为false
    const newModule = new Module(rawModule, runtime)
    if (path.length === 0) {
      // this.root = new Module(rawModule, runtime)
      this.root = newModule
    } else {
      // 如果path = ['user', 'login']， path.slice(0, -1) = ['user']   会去掉最后一个
      // parent是根模块
      const parent = this.get(path.slice(0, -1)) 
      // 把模块添加到根Module对象的_children对象中，形式如下
      // _children = {
      //   user: new Module(user, runtime)
      // }
      parent.addChild(path[path.length - 1], newModule)
    }
    // 如果options中存在modules属性
    if (rawModule.modules) {
      // 遍历modules都西昂
      forEachValue(rawModule.modules, (rawChildModule, key) =&gt; {
        // 获取每个module对应的options
        /*{
          modules: {
            user: {
              state,
              mutations
            },
            login
          },
          state: {

          },
          mutations: {
            
          }
        }*/

        // 看到上面的形式，如果modules里有options,继续递归遍历， 
        // path = ['user', 'login']
        this.register(path.concat(key), rawChildModule, runtime)
      })
    }
  }
</code></pre>
<pre><code>const newModule = new Module(rawModule, runtime)
</code></pre>
<p>代码一上来就创建了一个<code>Module</code>对象,并把<code>options</code>作为参数传入，我们继续看看<code>Module</code>这个类中做了哪些操作</p>
<pre><code class="language-javascript">export default class Module {
  constructor (rawModule, runtime) {
    this.runtime = runtime
    this._children = Object.create(null)
    this._rawModule = rawModule
    // 获取state
    const rawState = rawModule.state

    // 如果state是个方法就调用
    this.state = (typeof rawState === 'function' ? rawState() : rawState) || {}
  }

   // ...其他方法
}

</code></pre>
<p>上面的构造函数进行了一些初始化，<code>this.runtime</code>记录了是否是运行时，<code>this._children</code>初始化为空对象，它主要是用来，保存当前模块的子模块，<code>this._rawModule</code>记录了，当前模块的配置，然后又对<code>state</code>进行了些处理。然后我们大概知道了<code>new Module</code>做了什么</p>
<ol>
<li>创建了一个_children对象</li>
<li>_rawModule记录模块配置</li>
</ol>
<p>其他并不是很重要，我们先不提，再回到<code>new ModuleCollection(options)</code>,构造函数中</p>
<pre><code class="language-javascript">const newModule = new Module(rawModule, runtime)
</code></pre>
<p>这里拿到了<code>Module</code>对象</p>
<pre><code class="language-javascript">    if (path.length === 0) {
      // this.root = new Module(rawModule, runtime)
      this.root = newModule
    } else {
      // 如果path = ['user', 'login']， path.slice(0, -1) = ['user']   会去掉最后一个
      // parent是根模块
      const parent = this.get(path.slice(0, -1)) 
      // 把模块添加到根Module对象的_children对象中，形式如下
      // _children = {
      //   user: new Module(user, runtime)
      // }
      parent.addChild(path[path.length - 1], newModule)
    }
</code></pre>
<p>这是一段逻辑判断，而这个<code>path</code>是在<code>ModuleCollection</code>构造函数中,传入的,初始时为空</p>
<pre><code class="language-javascript">this.register([], rawRootModule, false)  

/**
   * 
   * @param {*} path 初始为空数组
   * @param {*} rawModule options
   * @param {*} runtime  初始为false
   */
  register (path, rawModule, runtime = true) {...}
  
  
</code></pre>
<pre><code class="language-javascript">    if (path.length === 0) {
      // this.root = new Module(rawModule, runtime)
      this.root = newModule
    } else {...}
</code></pre>
<p>他把<code>ModuleCollection</code>对象的root属性设置为一个<code>Module</code>对象，也就是代表根module,而else中的逻辑我们暂时不看，因为后面会有递归，下个周期时会进入else分支</p>
<pre><code class="language-javascript">    // 如果options中存在modules属性
    if (rawModule.modules) {
      // 遍历modules
      forEachValue(rawModule.modules, (rawChildModule, key) =&gt; {
        // 获取每个module对应的options

        /*{
          modules: {
            user: {
              state,
              mutations
            },
            login
          },
          state: {

          },
          mutations: {
            
          }
        }*/

        // 看到上面的形式，如果modules里有options,继续递归遍历， 
        // path = ['user', 'login']
        this.register(path.concat(key), rawChildModule, runtime)
      })
    }
</code></pre>
<p>这段代码，拿到了当前模块的配置，注意：根模块的配置其实就是<code>options</code>, 然后判断是否存在<code>modules</code>,如果存在，就遍历每个模块，这个<code>forEachValue</code>方法，其实实现非常简单，感兴趣的可以去看一下，最终回调函数遍历到每个<code>module</code>,并获取到<code>module</code>对象和它的模块对象的<code>key</code>,也就是模块名。</p>
<p>之后再次调用了下<code>register</code>方法，递归执行</p>
<pre><code class="language-javascript">this.register(path.concat(key), rawChildModule, runtime)
</code></pre>
<p><strong>注意</strong>：<code>path.concat(key)</code>, path本来是空数组，在每次递归时都会拼接模块的名字，这段代码非常关键，后面的<code>namespace</code>会有用到</p>
<p>然后我们再次回到<code>register</code>方法的开始</p>
<pre><code class="language-javascript">    // 创建Module对象，初始runtime为false
    const newModule = new Module(rawModule, runtime)
      
    if (path.length === 0) {
      // this.root = new Module(rawModule, runtime)
      this.root = newModule
    } else {
      // 如果path = ['user', 'login']， path.slice(0, -1) = ['user']   会去掉最后一个
      // parent是根模块
      const parent = this.get(path.slice(0, -1)) 
      // 把模块添加到根Module对象的_children对象中，形式如下
      // _children = {
      //   user: new Module(user, runtime)
      // }
      parent.addChild(path[path.length - 1], newModule)
    }
</code></pre>
<p>依然是创建了<code>Module</code>对象，此时的<code>Module</code>已经是子<code>Module</code>了, <code>if-else</code>判断也会执行到<code>else</code>中</p>
<pre><code class="language-javascript">    if (path.length === 0) {
 		//...
    } else {
      // 如果path = ['user', 'login']， path.slice(0, -1) = ['user']   会去掉最后一个
      // parent是根模块
      const parent = this.get(path.slice(0, -1)) 
      // 把模块添加到根Module对象的_children对象中，形式如下
      // _children = {
      //   user: new Module(user, runtime)
      // }
      parent.addChild(path[path.length - 1], newModule)
    }
</code></pre>
<p>假如我们有两个<code>module</code>,它会获取到除了最后一个的所有<code>module</code>的key列表，并调用<code>get</code>方法</p>
<pre><code class="language-javascript">  get (path) {
    return path.reduce((module, key) =&gt; {
      // 获取子模块
      return module.getChild(key)
    }, this.root)
  }
</code></pre>
<p>这段是<code>get</code>方法的实现,它其实是返回path对应模块的子模块</p>
<pre><code>parent.addChild(path[path.length - 1], newModule)
</code></pre>
<p>从最后，把模块添加到，当前模块的<code>_children</code>对象中</p>
<pre><code class="language-javascript">  addChild (key, module) {
    this._children[key] = module
  }
</code></pre>
<p>最后，通过<code>ModuleCollection</code>对象的<code>root</code>,就可以拿到<code>Module</code>对象树</p>
<p>类似这样</p>
<pre><code class="language-javascript">new Vuex.Store({
	modules:{
	    user: {
	       modules:{
               login
           }
	    },
	    cart: {
	        
	    }
	}
})
// 模拟一下
ModuleCollection = {
    root = 根Module: {
            _children: {
                子module(user): {
                	_children: {
                        子module(login)
                    }
                 },
                子module(cart)
            }
        }
}
</code></pre>
<blockquote>
<p>小总结：new ModuleCollection(options)在root这个属性上挂载了一个由module对象组成的树</p>
</blockquote>
<p>我们回到<code>new Vuex.Store(options)</code>时的构造函数</p>
<pre><code class="language-javascript">this._modules = new ModuleCollection(options)
</code></pre>
<p><code>this._modules</code>拿到了模块的集合</p>
<pre><code class="language-javascript">    // bind commit and dispatch to self
    const store = this
    const { dispatch, commit } = this
    this.dispatch = function boundDispatch (type, payload) {
      return dispatch.call(store, type, payload)
    }
    this.commit = function boundCommit (type, payload, options) {
      return commit.call(store, type, payload, options)
    }
</code></pre>
<p>这段代码，重写了<code>dispatch</code>和<code>commit</code>方法，其实相当于调用了<code>bind</code>方法,我个人认为也可以改写成这样</p>
<pre><code class="language-javascript">this.dispatch = this.dispatch.bind(store, type, payload)
this.commit = this.commit.bind(store, type, payload)
</code></pre>
<p>继续后面的步骤</p>
<pre><code>this.strict = strict
</code></pre>
<p><code>strict</code>使 Vuex store 进入严格模式，在严格模式下，任何 mutation 处理函数以外修改 Vuex state 都会抛出错误</p>
<pre><code class="language-javascript">    // 根module的state属性
    const state = this._modules.root.state
</code></pre>
<p>保存根模块的<code>state</code>属性</p>
<pre><code class="language-javascript">installModule(this, state, [], this._modules.root)
</code></pre>
<p>这段代码虽然简短，但是非常重要，我们来具体分析<code>installModule</code>方法</p>
<h3 id="installmodule">installModule</h3>
<pre><code class="language-javascript">/**
 * 
 * @param {*} store store对象
 * @param {*} rootState 根module的state对象
 * @param {*} path 初始为空数组
 * @param {*} module 根module对象
 * @param {*} hot 
 */
function installModule (store, rootState, path, module, hot) {
	
}
</code></pre>
<p>它的参数如上</p>
<pre><code class="language-javascript">  // 如果是空数组，说明是根module
  const isRoot = !path.length
</code></pre>
<p>判断是否是根模块</p>
<pre><code class="language-javascript">  // 返回由module名字 拼接成的字符串
  const namespace = store._modules.getNamespace(path)
</code></pre>
<p>这段代码很有意思，我们来看下<code>getNamespace</code>方法，它在<code>ModuleCollection</code>类中</p>
<pre><code class="language-javascript">  getNamespace (path) {
    // 根module
    let module = this.root

    return path.reduce((namespace, key) =&gt; {
      // 获取子module
      module = module.getChild(key)
      // 如果模块的namespace存在， 举个列子： 一层模块 user/， 二层模块： user/login/
      return namespace + (module.namespaced ? key + '/' : '')
    }, '')
  }
</code></pre>
<p>直接做一个简单的例子，如果我们在每个模块中使用了<code>namespaced</code>，设置为<code>true</code>，当我们调用<code>commit</code>,<code>dispatch</code>等方法时，我们需要这样做</p>
<pre><code class="language-javascript">this.$store.dispatch('count/increment')

this.$store.commit('count/INCREMENT')
</code></pre>
<p><code>getNamespace</code>要做的其实就是获取到<code>count/increment</code>前面的<code>count/</code>,并返回</p>
<pre><code class="language-javascript">  // 如果namespaced存在
  if (module.namespaced) {
    // 初始时store._modulesNamespaceMap[namespace]是不存在的
    if (store._modulesNamespaceMap[namespace] &amp;&amp; process.env.NODE_ENV !== 'production') {
      console.error(`[vuex] duplicate namespace ${namespace} for the namespaced module ${path.join('/')}`)
    }
    // namespace对应module
    store._modulesNamespaceMap[namespace] = module
  }
</code></pre>
<p>这段代码做的事情，就是把<code>namespace</code>和<code>module</code>作为key,value保存在<code>store</code>对象的<code>_modulesNamespaceMap</code>属性上,关于这个属性在什么地方用，可以参考<code>helper.js</code>的<code>getModuleByNamespace</code>方法，这个方法是实现<code>mapActions</code>，<code>mapMutations</code>的关键，以后也会讲到</p>
<p>然后是这段代码</p>
<pre><code class="language-javascript">  // 如果不是根root module   ，初始时hot也不存在， 初始时hot为ture,所以不会执行下面的
  if (!isRoot &amp;&amp; !hot) {
    const parentState = getNestedState(rootState, path.slice(0, -1))
    const moduleName = path[path.length - 1]
    store._withCommit(() =&gt; {
      Vue.set(parentState, moduleName, module.state)
    })
  }
</code></pre>
<p><code>isRoot</code>想必不用多说，就是判断是否是根模块，而<code>hot</code>这个变量又是哪里来的呢，他是<code>installModule</code>方法传入的一个参数，初始时他是空的，但这又有什么用处呢；emmm,由于我自己很少用到，我就不多做详细介绍了（因为菜，所以没用过），具体用法官方文档有详细介绍</p>
<p>我们继续，前面说到，<code>hot</code>是不存在的，而当前又是根节点，所以也不会执行这个if逻辑，但是我们还是要讲一下，不然一会还要回来讲，首先看一下<code>getNestedState</code>方法实现</p>
<pre><code class="language-javascript">const parentState = getNestedState(rootState, path.slice(0, -1))

// 具体实现
function getNestedState (state, path) {
  return path.length
    ? path.reduce((state, key) =&gt; state[key], state)
    : state
}

</code></pre>
<p>首先它的第一个参数是<code>state</code>,也就是当前模块的<code>state</code>,注意不一定是<code>rootState</code>，不要被调用参数误解，实际上是递归引用的传递，这个函数就是判断当前<code>path</code>是否为空，如果为空，表示它是根模块的<code>state</code>,不为空表示为子模块的<code>state</code>，要注意的是<code>path.slice(0, -1)</code>，它获取了除了本身模块名之前的模块名数组，<code>getNestedState</code>函数直接来说就是用来获取父模块的<code>state</code>,从字面意思也可以理解，至于reduce的一些操作就不详细讲解了。</p>
<pre><code class="language-javascript">const moduleName = path[path.length - 1]
</code></pre>
<p>然后就是获取了当前模块名,接下来关键来了</p>
<pre><code class="language-javascript">    store._withCommit(() =&gt; {
      Vue.set(parentState, moduleName, module.state)
    })
</code></pre>
<p>从字面意思，好像是跟随commit调用？没错就是这样。。</p>
<pre><code class="language-javascript">  _withCommit (fn) {
 
    const committing = this._committing
    this._committing = true
    fn()
    // 重新设置之前的提交状态
    this._committing = committing
  }
</code></pre>
<p>它就简单的调用了传入的回调函数，设置了前后的状态，然后来看下回调函数的内部</p>
<pre><code class="language-javascript">parentState:父模块的state
moduleName:当前模块名
module.state:当前模块的state

Vue.set(parentState, moduleName, module.state)
</code></pre>
<p>关于<code>Vue.set</code>方法的介绍：<strong>向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性，因为 Vue 无法探测普通的新增属性</strong></p>
<p>也就是说，它可以在把每个<code>state</code>属性变为响应式，在<code>commit</code>之前，为什么在之前呢，因为这是初始化阶段，我们没有主动调用<code>commit</code></p>
<p>我们继续后面的代码</p>
<pre><code class="language-javascript">  // 重写了dispatch, commit ,getter,state等方法，全部挂载到了当前模块的context属性上
  const local = module.context = makeLocalContext(store, namespace, path)
</code></pre>
<p>下面我将详细讲解<code>makeLocalContext</code>方法</p>
<h4 id="makelocalcontext">makeLocalContext</h4>
<pre><code class="language-javascript">function makeLocalContext (store, namespace, path) {
  const noNamespace = namespace === ''

  const local = {
    // 如果不存在namespace，就重写dispatch方法
    dispatch: noNamespace ? store.dispatch : (_type, _payload, _options) =&gt; {
      const args = unifyObjectStyle(_type, _payload, _options)
      const { payload, options } = args
      let { type } = args
      if (!options || !options.root) {
        // 使用namespace拼接action的类型
        type = namespace + type
        // 如果不使用 namespace/action的形式调用action就会报错
        if (process.env.NODE_ENV !== 'production' &amp;&amp; !store._actions[type]) {
          console.error(`[vuex] unknown local action type: ${args.type}, global type: ${type}`)
          return
        }
      }
      return store.dispatch(type, payload)
    },

    commit: noNamespace ? store.commit : (_type, _payload, _options) =&gt; {
      const args = unifyObjectStyle(_type, _payload, _options)
      const { payload, options } = args
      let { type } = args
      if (!options || !options.root) {
        type = namespace + type
        if (process.env.NODE_ENV !== 'production' &amp;&amp; !store._mutations[type]) {
          console.error(`[vuex] unknown local mutation type: ${args.type}, global type: ${type}`)
          return
        }
      }
      store.commit(type, payload, options)
    }
  }

  // getters and state object must be gotten lazily
  // because they will be changed by vm update
  Object.defineProperties(local, {
    getters: {
      get: noNamespace
        ? () =&gt; store.getters
        : () =&gt; makeLocalGetters(store, namespace)
    },
    state: {
      get: () =&gt; getNestedState(store.state, path)
    }
  })

  return local
}
</code></pre>
<p>这面代码返回了一个local对象，并且这些对象对<code>dispatch</code>,<code>commit</code>等方法还有<code>state</code>,<code>getter</code>进行了包装</p>
<pre><code class="language-javascript">const noNamespace = namespace === ''
</code></pre>
<p>这段代码用来判断是否存在命名空间<code>namespace</code>，然后我们再来看下<code>dispatch</code></p>
<h5 id="1dispatch">1.dispatch</h5>
<pre><code class="language-javascript">    dispatch: noNamespace ? store.dispatch : (_type, _payload, _options) =&gt; {
      const args = unifyObjectStyle(_type, _payload, _options)
      const { payload, options } = args
      let { type } = args
      if (!options || !options.root) {
        // 使用namespace拼接action的类型
        type = namespace + type
        // 如果不使用 namespace/action的形式调用action就会报错
        if (process.env.NODE_ENV !== 'production' &amp;&amp; !store._actions[type]) {
          console.error(`[vuex] unknown local action type: ${args.type}, global type: ${type}`)
          return
        }
      }
      return store.dispatch(type, payload)
    },
</code></pre>
<p>首先判断是否有命名空间，如果没有就是正常的<code>dispatch</code>,如果存在，则先统一对象风格<code>unifyObjectStyle</code></p>
<p>先来看下<code>unifyObjectStyle</code>实现,具体讲解就写在注释里了</p>
<pre><code class="language-javascript">// 统一对象风格
function unifyObjectStyle (type, payload, options) {
    // 
  if (isObject(type) &amp;&amp; type.type) {
    options = payload
    payload = type
    type = type.type
  }

  if (process.env.NODE_ENV !== 'production') {
    assert(typeof type === 'string', `expects string as the type, but found ${typeof type}.`)
  }

  return { type, payload, options }
}
</code></pre>
<p>在看这段代码之前，先说一下，一般来说我们都是这样使用<code>dispatch</code></p>
<pre><code class="language-javascript">store.dispatch('incrementAsync', {
  amount: 10
})
</code></pre>
<p>但其实也可以这样,并且官方文档也有例子</p>
<pre><code class="language-javascript">store.dispatch({
  type: 'incrementAsync',
  amount: 10
})
</code></pre>
<p>知道这些我们就继续往下分析</p>
<pre><code class="language-javascript">  if (isObject(type) &amp;&amp; type.type) {
    options = payload
    payload = type
    type = type.type
  }
</code></pre>
<p>这里是对参数进行了简单的处理，统一处理成了我们平常使用的模式，最后返回了相应的<code>type, payload, options</code></p>
<p>接下来，回到<code>makeLocalContext</code>方法</p>
<pre><code class="language-javascript">    dispatch: noNamespace ? store.dispatch : (_type, _payload, _options) =&gt; {
      const args = unifyObjectStyle(_type, _payload, _options)
      const { payload, options } = args
      let { type } = args
      if (!options || !options.root) {
        // 使用namespace拼接action的类型
        type = namespace + type
        // 如果不使用 namespace/action的形式调用action就会报错
        if (process.env.NODE_ENV !== 'production' &amp;&amp; !store._actions[type]) {
          console.error(`[vuex] unknown local action type: ${args.type}, global type: ${type}`)
          return
        }
      }
      return store.dispatch(type, payload)
    },
</code></pre>
<p>统一这些参数以后，又是一个if判断，第三个参数用的也很少，但是官方文档是有说明的，<code>options</code> 里可以有 <code>root: true</code>，它允许在<a href="https://vuex.vuejs.org/zh/guide/modules.html#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">命名空间模块</a>里提交根的 <code>mutation或action</code>，然后返回了调用<code>store.dispatch</code>方法的返回值，然后我们来看看包装后的<code>commit</code></p>
<h5 id="2commit">2.commit</h5>
<pre><code class="language-javascript">    commit: noNamespace ? store.commit : (_type, _payload, _options) =&gt; {
      const args = unifyObjectStyle(_type, _payload, _options)
      const { payload, options } = args
      let { type } = args
      if (!options || !options.root) {
        type = namespace + type
        if (process.env.NODE_ENV !== 'production' &amp;&amp; !store._mutations[type]) {
          console.error(`[vuex] unknown local mutation type: ${args.type}, global type: ${type}`)
          return
        }
      }
      store.commit(type, payload, options)
    }
</code></pre>
<p>这段代码和<code>dispatch</code>的实现非常相似，就不讲解了，所做的事情就是对参数进行统一</p>
<pre><code class="language-javascript">  Object.defineProperties(local, {
    getters: {
      get: noNamespace
        ? () =&gt; store.getters
        : () =&gt; makeLocalGetters(store, namespace)
    },
    state: {
      get: () =&gt; getNestedState(store.state, path)
    }
  })
</code></pre>
<p>然后这段代码是把<code>state</code>和<code>getter</code>代理到了local对象上，</p>
<h5 id="3getter">3.getter</h5>
<p>判断当前模块是否有命名空间，如果不是，就不做任何处理，否则调用<code>makeLocalGetters</code>方法，并传入<code>store</code>对象和<code>namespace</code>完整模块字符串，至于这个<code>namespace</code>是什么，可以往前翻一翻，有具体的讲解。比如<code>user/login</code>，表示user模块下的login模块的namespace。然后我们来看看<code>makeLocalGetters</code>做了什么</p>
<pre><code class="language-javascript">
function makeLocalGetters (store, namespace) {
  const gettersProxy = {}
  const splitPos = namespace.length
  Object.keys(store.getters).forEach(type =&gt; {
    // 截取getter中的namespace，如果不相等，就不做处理
    if (type.slice(0, splitPos) !== namespace) return

    // 获取getter 的namespace后面的字符串
    const localType = type.slice(splitPos)


    Object.defineProperty(gettersProxy, localType, {
      // 把getters中的属性方法，代理到新的对象中
      get: () =&gt; store.getters[type],
      enumerable: true
    })
  })

  return gettersProxy
}
</code></pre>
<p>这个函数被调用说明一定是有<code>namespace</code>的，然后遍历<code>getter</code>，此时的<code>getter</code>的属性名是包含有<code>namespace</code>的，至于为什么会有，这个在以后的<code>registerGetters</code>中会有讲解。然后获取到<code>namespace</code>后面真实的<code>getter</code>属性名，并被代理到一个新的对象中，并且被获取时，仍然是使用了完整的<code>namespace</code>，举个例子</p>
<pre><code>假设模块:  user/todo
store.getters.doSomething()   
等价于
store.getters['user/todo/doSomething']()
</code></pre>
<p>看完这些相信大家都明白了</p>
<h5 id="4state">4.state</h5>
<p>调用了<code>getNestedState</code>方法，这个方法想必不用多说，前面也有讲过，用来获取模块的父模块<code>state</code>，并返回</p>
<p>我们再回到一开始，调用<code>makeLocalContext</code>的位置, 返回的local对象，最终放在了模块的<code>context</code>属性上</p>
<pre><code class="language-javascript">const local = module.context = makeLocalContext(store, namespace, path)
</code></pre>
<p>接下来我们继续分析，后面的内容</p>
<h4 id="registermutation">registerMutation</h4>
<pre><code class="language-javascript">  // 遍历mutations
  module.forEachMutation((mutation, key) =&gt; {
    // 把namespace和mutation名进行拼接
    const namespacedType = namespace + key
    registerMutation(store, namespacedType, mutation, local)
  })
</code></pre>
<p>这段代码，简单来说就是遍历了，当前模块的所有<code>mutations</code>，并对每个<code>mutation</code>调用了<code>registerMutation</code>方法，传入了<code>store</code>对象，完整的<code>namespace + commit名</code>，<code>mutation函数</code>,以及<code>local</code>对象，接下来看看<code>registerMutation</code>方法实现，至于<code>forEachMutation</code>方法，大家可以自己看一下，实现也很简单</p>
<pre><code class="language-javascript">function registerMutation (store, type, handler, local) {
  const entry = store._mutations[type] || (store._mutations[type] = [])
  entry.push(function wrappedMutationHandler (payload) {
    // 调用mutation, 并传入state和参数
    handler.call(store, local.state, payload)
  })
}
</code></pre>
<p>这个函数，实际上是把当前模块的<code>mutation</code>放在了一个<code>_mutations</code>对象中，那这个属性在哪定义的呢</p>
<pre><code class="language-javascript">this._mutations = Object.create(null)
</code></pre>
<p>实际上在<code>Store</code>类的构造函数的时候已经初始化为了一个空对象，<code>registerMutation</code>所做的事情，就是把<code>mutations</code>和<code>namespaceType</code>,形成一个映射关系，并且<code>mutations</code>是一个数组，比如这样</p>
<pre><code>{
	'user/todo/INCREMENT': [
		function() {...}
	]
}
</code></pre>
<p>这里之所以用数组的形式存储函数，我觉得是为了防止重复定义<code>mutation</code>，因为调用之后只有最后一个会生效</p>
<pre><code class="language-javascript">  entry.push(function wrappedMutationHandler (payload) {
    // 调用mutation, 并传入state和参数
    handler.call(store, local.state, payload)
  })
</code></pre>
<p>然后就是把<code>mutation</code>的调用放在一个函数中，传入了state，payload，在真正调用<code>commit</code>的时候才会循环调用，真实的<code>mutation</code></p>
<p>下面我们继续看后面的代码</p>
<h4 id="registeraction">registerAction</h4>
<pre><code class="language-javascript">  module.forEachAction((action, key) =&gt; {
    // namespace + type
    const type = action.root ? key : namespace + key

    const handler = action.handler || action
    registerAction(store, type, handler, local)
  })
</code></pre>
<p>这里和前面的处理差不多，只是有个判断，如果action存在root说明是根模块，所以直接用<code>key</code>就好了,<code>options</code> 里可以有 <code>root: true</code>，它允许在<a href="https://vuex.vuejs.org/zh/guide/modules.html#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">命名空间模块</a>里提交根的 mutation，否则就使用<code>namespace</code>和<code>key</code>拼接成的action名，然后我们来看<code>registerAction</code>是实现</p>
<pre><code class="language-javascript">function registerAction (store, type, handler, local) {
  const entry = store._actions[type] || (store._actions[type] = [])
  entry.push(function wrappedActionHandler (payload, cb) {
    let res = handler.call(store, {
      dispatch: local.dispatch,
      commit: local.commit,
      getters: local.getters,
      state: local.state,
      rootGetters: store.getters,
      rootState: store.state
    }, payload, cb)
    if (!isPromise(res)) {
      res = Promise.resolve(res)
    }
      // 这是给devTool用的，可以不用关心
    if (store._devtoolHook) {
      return res.catch(err =&gt; {
        store._devtoolHook.emit('vuex:error', err)
        throw err
      })
    } else {
      return res
    }
  })
}

</code></pre>
<p>我们暂且不看<code>wrappedActionHandler</code>函数里面的内容，它的处理依旧和<code>mutation</code>的处理一样，也是把action放在<code>_actions</code>对象中，然后再看<code>wrappedActionHandler</code>里的内容，它调用了<code>action</code>,并且让他this指向了<code>store</code>,传入了，<code>local</code>对象中的<code>dispatch</code>,<code>commit</code>等方法还有<code>state</code>,<code>getter</code>,这不就是我们之前看到的，经过处理后的API方法吗。</p>
<p>然后它拿到<code>action</code>调用之后的返回值，最终返回了一个<code>Promise.resolve(res)</code>,也就是一个Promise</p>
<p>通过上面这些代码，我们能在实际中这么用</p>
<p>注意：<strong>commit, dispatch,getters,state都是当前模块里的方法和对象</strong></p>
<pre><code class="language-javascript">{
	actions: {
		async increment({ commit, dispatch, getters,state, rootGetters, rootState }) {
		 	return await getData()
		}
	}
}
</code></pre>
<p>说完了<code>registerAction</code>，我们来说一说<code>registerGetter</code></p>
<h4 id="registergetter">registerGetter</h4>
<pre><code class="language-javascript">  module.forEachGetter((getter, key) =&gt; {
    const namespacedType = namespace + key
    registerGetter(store, namespacedType, getter, local)
  })
</code></pre>
<p>不多废话，直接看<code>registerGetter</code>的实现</p>
<pre><code class="language-javascript">function registerGetter (store, type, rawGetter, local) {
  if (store._wrappedGetters[type]) {
    if (process.env.NODE_ENV !== 'production') {
      console.error(`[vuex] duplicate getter key: ${type}`)
    }
    return
  }
  store._wrappedGetters[type] = function wrappedGetter (store) {
    return rawGetter(
      local.state, // local state
      local.getters, // local getters
      store.state, // root state
      store.getters // root getters
    )
  }
}
</code></pre>
<p>一上来就是一个判断，简单点来说就是，不允许有重复定义的<code>getters</code>，我们之前是看到<code>actions</code>和<code>mutation</code>是可以重复定义的。然后再来看其他的，它和之前的处理有所不同，但也相差不大，因为不允许有重复，所以就不需要push一个函数了，直接调用了<code>getter</code>方法，传入了<code>state</code>,<code>getters</code>,根<code>state</code>,根<code>getters</code>，我们可以这样用</p>
<pre><code class="language-javascript">{
	['INCREMENT']: function(state, getters, rootState, rootGetters){
		//...
	}
}
</code></pre>
<p>讲完这些<code>installModule</code>基本上要结束了，我们看最后一段代码</p>
<pre><code class="language-javascript">  module.forEachChild((child, key) =&gt; {
    installModule(store, rootState, path.concat(key), child, hot)
  })
</code></pre>
<p>没错，是个递归，它拿到了子模块进行了递归，大家可以翻到前面梳理一下流程</p>
<p><code>installModule</code>方法我们也讲完了，我们要回到Store类的构造函数中，看看还有些什么初始化操作</p>
<pre><code class="language-javascript">resetStoreVM(this, state)

plugins.forEach(plugin =&gt; plugin(this))

const useDevtools = options.devtools !== undefined ? options.devtools : Vue.config.devtools
if (useDevtools) {
   devtoolPlugin(this)
}
</code></pre>
<p>接下来分析<code>resetStoreVM</code></p>
<h3 id="resetstorevm">resetStoreVM</h3>
<pre><code class="language-javascript">function resetStoreVM (store, state, hot) {
  const oldVm = store._vm
  // bind store public getters
  store.getters = {}
  const wrappedGetters = store._wrappedGetters
  const computed = {}
  forEachValue(wrappedGetters, (fn, key) =&gt; {
    // use computed to leverage its lazy-caching mechanism
    // direct inline function use will lead to closure preserving oldVm.
    // using partial to return function with only arguments preserved in closure enviroment.
    computed[key] = partial(fn, store)
    Object.defineProperty(store.getters, key, {
      get: () =&gt; store._vm[key],
      enumerable: true // for local getters
    })
  })

  // use a Vue instance to store the state tree
  // suppress warnings just in case the user has added
  // some funky global mixins
  const silent = Vue.config.silent
  Vue.config.silent = true
  store._vm = new Vue({
    data: {
      $$state: state
    },
    computed
  })
  Vue.config.silent = silent

  // enable strict mode for new vm
  if (store.strict) {
    enableStrictMode(store)
  }

  if (oldVm) {
    if (hot) {
      // dispatch changes in all subscribed watchers
      // to force getter re-evaluation for hot reloading.
      store._withCommit(() =&gt; {
        oldVm._data.$$state = null
      })
    }
    Vue.nextTick(() =&gt; oldVm.$destroy())
  }
}
</code></pre>
<p>首先看一下<code>store._vm</code>是什么，如果有注意到这个函数中间的一段代码的话可以看到，<code>_vm</code>是又创建了一个Vue实例，这个我们后面讲。然后在<code>store</code>上定义了一个对象<code>getters</code>，然后遍历之前，<code>registerGetters</code>注册的<code>getter</code>,然后是这段代码</p>
<pre><code class="language-javascript">  forEachValue(wrappedGetters, (fn, key) =&gt; {
    // use computed to leverage its lazy-caching mechanism
    // direct inline function use will lead to closure preserving oldVm.
    // using partial to return function with only arguments preserved in closure enviroment.
    computed[key] = partial(fn, store)
    Object.defineProperty(store.getters, key, {
      get: () =&gt; store._vm[key],
      enumerable: true // for local getters
    })
  })


// partial函数实现
export function partial (fn, arg) {
  return function () {
    return fn(arg)
  }
}
</code></pre>
<p>首先是遍历所有<code>getters</code>,调用<code>partial</code>函数，返回了一个新函数，并把它放入<code>computed</code>对象中，后面的代码其实是做了这件事</p>
<pre><code>$store.getter
等价于
$store._vm.getter
</code></pre>
<p>把<code>getter</code>代理到了一个新的Vue实例的<code>computed</code>对象上，这在后面的代码有所体现</p>
<pre><code class="language-javascript">  const silent = Vue.config.silent
  // 启动Vue的日志和警告
  Vue.config.silent = true
  store._vm = new Vue({
    data: {
      // 把state放在Vue的data中
      $$state: state
    },
    computed  // 把所有getter放在了computed中
  })
</code></pre>
<p>这段代码相信不会陌生，vuex之所以能够响应式，原因就在这里，我们通过调用<code>mutation</code>,修改了<code>state</code>,会触发页面更新，其实是Vue的帮助</p>
<h4 id="strict">strict</h4>
<p>我们继续看后面的代码</p>
<pre><code class="language-javascript">  if (store.strict) {
    enableStrictMode(store)
  }

  if (oldVm) {
    if (hot) {
     // 强制getters重新计算
      store._withCommit(() =&gt; {
        oldVm._data.$$state = null
      })
    }
    // 防止重复创建Vue实例（个人理解）
    Vue.nextTick(() =&gt; oldVm.$destroy())
  }
</code></pre>
<p>首先是判断<code>strict</code>是否为true, 表示是严格模式，如果直接更改state，会报错，我们看一下它的实现</p>
<pre><code class="language-javascript">function enableStrictMode (store) {
  store._vm.$watch(function () { return this._data.$$state }, () =&gt; {
    if (process.env.NODE_ENV !== 'production') {
      assert(store._committing, `do not mutate vuex store state outside mutation handlers.`)
    }
  }, { deep: true, sync: true })
}
</code></pre>
<p>很关键的是中间的箭头函数，我们可以直接看一下Vue源码的实现，它是如何实现修改state报错</p>
<pre><code class="language-javascript">  Vue.prototype.$watch = function (
    expOrFn: string | Function,
    cb: any,
    options?: Object
  ): Function {
    const vm: Component = this
    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options)
    }
    options = options || {}

    options.user = true  // 很关键的属性

    const watcher = new Watcher(vm, expOrFn, cb, options)

    if (options.immediate) {
      try {
        cb.call(vm, watcher.value)
      } catch (error) {
        handleError(error, vm, `callback for immediate watcher &quot;${watcher.expression}&quot;`)
      }
    }
    return function unwatchFn () {
      watcher.teardown()
    }
  }
</code></pre>
<p>这段代码有个地方很关键,<code>options.user = true</code>，它被传入了<code>Watcher</code>对象中，还有我们传入了箭头函数<code>cb</code></p>
<p>我们看看Watcher哪里有使用到<code>user</code>属性</p>
<pre><code class="language-javascript">class Watcher {
    
  // ...
    
  update () {
    /* istanbul ignore else */
    if (this.lazy) {
      this.dirty = true
    } else if (this.sync) {
      this.run()
    } else {
      queueWatcher(this)
    }
  }
  run () {
    if (this.active) {
      const value = this.get()
      if (
        value !== this.value ||
        // Deep watchers and watchers on Object/Arrays should fire even
        // when the value is the same, because the value may
        // have mutated.
        isObject(value) ||
        this.deep
      ) {
        // set new value
        const oldValue = this.value
        this.value = value
        if (this.user) {
          try {
            this.cb.call(this.vm, value, oldValue)
          } catch (e) {
            handleError(e, this.vm, `callback for watcher &quot;${this.expression}&quot;`)
          }
        } else {
          this.cb.call(this.vm, value, oldValue)
        }
      }
    }
  }
    
    // ...
}


</code></pre>
<p>我先说一下，这个<code>run</code>方法在什么时机调用的，它是在<code>set</code>属性访问器内部调用<code>notify</code>之后，<code>watcher</code>会调用自身的<code>update</code>方法,然后<code>run</code>就会被调用，可能说的不太清楚，如果各位有时间可以看一下，这里只针对<code>strict</code>原理来讲</p>
<p>下面我们只看这段代码</p>
<pre><code class="language-javascript">        if (this.user) {
          try {
            this.cb.call(this.vm, value, oldValue)
          } catch (e) {
            handleError(e, this.vm, `callback for watcher &quot;${this.expression}&quot;`)
          }
        } else {
          this.cb.call(this.vm, value, oldValue)
        }
</code></pre>
<p>我们知道之前传入的<code>user</code>属性为true, 如果调用回调是一定会抛出错误的</p>
<pre><code class="language-javascript">    if (process.env.NODE_ENV !== 'production') {
      assert(store._committing, `do not mutate vuex store state outside mutation handlers.`)
    }
</code></pre>
<p>这就是<code>strict</code>模式下，直接修改<code>state</code>会报错的原因</p>
<p>讲完这些，其实后面的代码就简单略过了，也不是很重要（懒？）</p>
<p>然后我们来看<code>Store</code>构造函数中最后一点内容</p>
<pre><code class="language-javascript">    plugins.forEach(plugin =&gt; plugin(this))

    const useDevtools = options.devtools !== undefined ? options.devtools : Vue.config.devtools
    if (useDevtools) {
      devtoolPlugin(this)
   }
</code></pre>
<p>首先调用了所有的<code>plugin</code>,并传入了<code>store</code>对象，关于<code>plugin</code>的用法官方文档都有介绍。然后关于<code>useDevtools</code>内容我就不讲解了，它和devTool相关</p>
<p>终于讲完了初始化，我们开始讲<code>Vuex</code>的一些API</p>
<h2 id="api">API</h2>
<p>我们按照官方文档一个个来</p>
<h4 id="1-commit">1. commit</h4>
<p>​	<code>commit</code>的用法就不用介绍了，直接看源码</p>
<pre><code class="language-javascript">  commit (_type, _payload, _options) {
    // check object-style commit
    const {
      type,
      payload,
      options
    } = unifyObjectStyle(_type, _payload, _options)

    const mutation = { type, payload }
    const entry = this._mutations[type]
    if (!entry) {
      if (process.env.NODE_ENV !== 'production') {
        console.error(`[vuex] unknown mutation type: ${type}`)
      }
      return
    }
    this._withCommit(() =&gt; {
      // 遍历type对应的mutation数组
      entry.forEach(function commitIterator (handler) {
        handler(payload)
      })
    })
    // 遍历所有订阅，并传入mutation对象和状态
    this._subscribers.forEach(sub =&gt; sub(mutation, this.state))

    if (
      process.env.NODE_ENV !== 'production' &amp;&amp;
      options &amp;&amp; options.silent
    ) {
      console.warn(
        `[vuex] mutation type: ${type}. Silent option has been removed. ` +
        'Use the filter functionality in the vue-devtools'
      )
    }
  }
</code></pre>
<p>首先是调用<code>unifyObjectStyle</code>方法，统一对象风格，如果有看前面的内容的话，应该知道，这是用来处理以下两种情况的参数</p>
<pre><code>commit(type: string, payload?: any, options?: Object)
commit(mutation: Object, options?: Object)
</code></pre>
<p>然后是下面这段</p>
<pre><code class="language-javascript">    const mutation = { type, payload }
    const entry = this._mutations[type]
    if (!entry) {
      if (process.env.NODE_ENV !== 'production') {
        console.error(`[vuex] unknown mutation type: ${type}`)
      }
      return
    }
</code></pre>
<p>如果<code>commit</code>的<code>mutation</code>不存在的话，就会报出警告,并返回不做处理</p>
<pre><code class="language-javascript">    this._withCommit(() =&gt; {
      // 遍历type对应的mutation数组
      entry.forEach(function commitIterator (handler) {
        handler(payload)
      })
    })
</code></pre>
<p><code>_withCommit</code>方法前面也有讲过，简单点说其实就是调用传入的回调函数，这里循环调用了<code>mutation</code>，至于为什么是数组，前面有讲到，是在<code>registerMutation</code>方法</p>
<p>我们继续来看</p>
<pre><code class="language-javascript">    // 遍历所有订阅，并传入mutation对象和状态
    this._subscribers.forEach(sub =&gt; sub(mutation, this.state))
    
    //  silent属性已经被删除，不让使用
    if (
      process.env.NODE_ENV !== 'production' &amp;&amp;
      options &amp;&amp; options.silent
    ) {
      console.warn(
        `[vuex] mutation type: ${type}. Silent option has been removed. ` +
        'Use the filter functionality in the vue-devtools'
      )
    }
</code></pre>
<p><code>this._subscribers</code>属性也是在<code>Store</code>对象的构造函数初始化时创建的一个数组，看到这个数组的名字，不用多说肯定是发布订阅模式，然后循环调用订阅的回调函数,它是在<code>mutation</code>被调用后执行, 但是在哪里订阅的呢，其实是在<code>subscribe</code>方法，它也是Vuex的一个API，下面我们来具体讲讲</p>
<h4 id="2-subscribe">2. subscribe</h4>
<p>订阅 store 的 mutation。<code>handler</code> 会在每个 <code>mutation</code>完成后调用，接收 mutation 和经过 mutation 后的状态作为参数</p>
<pre><code class="language-javascript">  subscribe (fn) {
    return genericSubscribe(fn, this._subscribers)
  }
</code></pre>
<pre><code class="language-javascript">function genericSubscribe (fn, subs) {
  if (subs.indexOf(fn) &lt; 0) {
    subs.push(fn)
  }
  return () =&gt; {
    const i = subs.indexOf(fn)
    if (i &gt; -1) {
      subs.splice(i, 1)
    }
  }
}
</code></pre>
<p>这就是一个简单的发布订阅模式的应用，把回调存储在了订阅数组中，其中<code>genericSubscribe</code>方法利用了闭包，返回了一个函数，调用它之后就可以取消订阅,其实还有其他的订阅方法,<code>subscribeAction</code></p>
<h4 id="3-subscribeaction">3. subscribeAction</h4>
<pre><code class="language-javascript">  subscribeAction (fn) {
    const subs = typeof fn === 'function' ? { before: fn } : fn
    return genericSubscribe(subs, this._actionSubscribers)
  }
</code></pre>
<p>判断是否是一个函数，如果是默认为<code>before</code>函数，也就是在<code>dispatch</code>调用<code>action</code>之前调用，如果是<code>{after: fn}</code>就会在<code>action</code>之后调用</p>
<h4 id="4-dispatch">4. dispatch</h4>
<pre><code class="language-javascript">  // 执行了beforeActions所有回调
  // 执行所有actions,并拿到所有promise返回的结果
  // 执行了afterActions所有回调
  dispatch (_type, _payload) {
    // check object-style dispatch
    const {
      type,
      payload
    } = unifyObjectStyle(_type, _payload)

    const action = { type, payload }
    const entry = this._actions[type]
    if (!entry) {
      if (process.env.NODE_ENV !== 'production') {
        console.error(`[vuex] unknown action type: ${type}`)
      }
      return
    }

    try {
      this._actionSubscribers
        .filter(sub =&gt; sub.before)
        .forEach(sub =&gt; sub.before(action, this.state))
    } catch (e) {
      if (process.env.NODE_ENV !== 'production') {
        console.warn(`[vuex] error in before action subscribers: `)
        console.error(e)
      }
    }

    const result = entry.length &gt; 1
      ? Promise.all(entry.map(handler =&gt; handler(payload)))
      : entry[0](payload)

    return result.then(res =&gt; {
      try {
        this._actionSubscribers
          .filter(sub =&gt; sub.after)
          .forEach(sub =&gt; sub.after(action, this.state))
      } catch (e) {
        if (process.env.NODE_ENV !== 'production') {
          console.warn(`[vuex] error in after action subscribers: `)
          console.error(e)
        }
      }
      return res
    })
  }
</code></pre>
<p>前面关于对象统一，以及是否存在<code>action</code>的判断就不讲了</p>
<pre><code class="language-javascript">    try {
      this._actionSubscribers
        .filter(sub =&gt; sub.before)
        .forEach(sub =&gt; sub.before(action, this.state))
    } catch (e) {
      if (process.env.NODE_ENV !== 'production') {
        console.warn(`[vuex] error in before action subscribers: `)
        console.error(e)
      }
    }
</code></pre>
<p>然后过滤筛选获取到了订阅的一些<code>before</code>函数,也就是在调用<code>action</code>之前调用，并传入了<code>action</code>, <code>action = { type, payload }</code>以及<code>state</code></p>
<h4 id="5-watch">5. watch</h4>
<p>响应式地侦听 <code>fn</code> 的返回值，当值改变时调用回调函数。<code>fn</code> 接收 store 的 state 作为第一个参数，其 getter 作为第二个参数。最后接收一个可选的对象参数表示 Vue 的 <a href="https://cn.vuejs.org/v2/api/#vm-watch"><code>vm.$watch</code></a> 方法的参数。</p>
<pre><code class="language-javascript">  watch (getter, cb, options) {
    if (process.env.NODE_ENV !== 'production') {
      assert(typeof getter === 'function', `store.watch only accepts a function.`)
    }
    return this._watcherVM.$watch(() =&gt; getter(this.state, this.getters), cb, options)
  }

// Store构造函数初始化时
this._watcherVM = new Vue()
</code></pre>
<p>这里给侦听函数里的，<code>getter</code>传入了<code>state</code>和<code>getters</code>, 当<code>state</code>发生变化时，侦听函数的返回值也发生了变化，值改变后就会触发<code>cb</code>回调函数, 关于<code>vm.$watch</code>的用法，可以参考Vue的官方文档<a href="https://cn.vuejs.org/v2/api/#vm-watch"><code>vm.$watch</code></a></p>
<h4 id="6-replacestate">6. replaceState</h4>
<p>替换 store 的根状态，仅用状态合并或时光旅行调试。</p>
<pre><code class="language-javascript">    this._withCommit(() =&gt; {
      this._vm._data.$$state = state
    })
</code></pre>
<p>直接替换掉了<code>$$state</code>原本状态</p>
<h4 id="7-registermodule">7. registerModule</h4>
<p>可以注册模块，例子：</p>
<pre><code class="language-javascript">// 注册模块 `myModule`
store.registerModule('myModule', {
  // ...
})
// 注册嵌套模块 `nested/myModule`
store.registerModule(['nested', 'myModule'], {
  // ...
})
</code></pre>
<pre><code class="language-javascript">  registerModule (path, rawModule, options = {}) {
    if (typeof path === 'string') path = [path]

    if (process.env.NODE_ENV !== 'production') {
      assert(Array.isArray(path), `module path must be a string or an Array.`)
      assert(path.length &gt; 0, 'cannot register the root module by using registerModule.')
    }

    this._modules.register(path, rawModule)
    installModule(this, this.state, path, this._modules.get(path), options.preserveState)
    // reset store to update getters...
    resetStoreVM(this, this.state)
  }
</code></pre>
<p>首先时统一处理了一下<code>path</code>和一些断言，然后调用了<code>register</code>方法<code>installModule</code>方法，<code>resetStoreVM</code>方法，这几个方法前面都有讲到，相当于又创建了一个<code>Store</code>对象，流程也差不多</p>
<h4 id="8-unregistermodule">8. unregisterModule</h4>
<p>卸载一个动态模块。</p>
<pre><code class="language-javascript">  unregisterModule (path) {
    if (typeof path === 'string') path = [path]
    if (process.env.NODE_ENV !== 'production') {
      assert(Array.isArray(path), `module path must be a string or an Array.`)
    }

    this._modules.unregister(path)
    this._withCommit(() =&gt; {
      const parentState = getNestedState(this.state, path.slice(0, -1))
      Vue.delete(parentState, path[path.length - 1])
    })
    resetStore(this)
  }
</code></pre>
<p>前面是对<code>path</code>模块名进行了处理以及断言是否是数组，然后调用<code>unregister</code></p>
<pre><code class="language-javascript">this._modules.unregister(path)


unregister (path) {
    const parent = this.get(path.slice(0, -1))
    const key = path[path.length - 1]
    if (!parent.getChild(key).runtime) return

    parent.removeChild(key)
}
</code></pre>
<p>这里获取到了传入模块名，也就是<code>path</code>的父模块，然后获取子模块判断是否存在<code>runtime</code>属性，这个属性是干嘛的，我也不是很清楚，希望又大佬解惑（菜 ！- -,没办法啊）</p>
<pre><code class="language-javascript">  parent.removeChild(key)

  removeChild (key) {
    delete this._children[key]
  }
</code></pre>
<p>最后删除了子模块,也就是我们要删除的模块</p>
<h4 id="9-hotupdate">9. hotUpdate</h4>
<p>热替换新的 action 和 mutation</p>
<p><strong>官方的例子</strong></p>
<pre><code class="language-javascript">// store.js
import Vue from 'vue'
import Vuex from 'vuex'
import mutations from './mutations'
import moduleA from './modules/a'

Vue.use(Vuex)

const state = { ... }

const store = new Vuex.Store({
  state,
  mutations,
  modules: {
    a: moduleA
  }
})

if (module.hot) {
  // 使 action 和 mutation 成为可热重载模块
  module.hot.accept(['./mutations', './modules/a'], () =&gt; {
    // 获取更新后的模块
    // 因为 babel 6 的模块编译格式问题，这里需要加上 `.default`
    const newMutations = require('./mutations').default
    const newModuleA = require('./modules/a').default
    // 加载新模块
    store.hotUpdate({
      mutations: newMutations,
      modules: {
        a: newModuleA
      }
    })
  })
}
</code></pre>
<p>热模块更新源码如下</p>
<pre><code class="language-javascript">  hotUpdate (newOptions) {
    this._modules.update(newOptions)
    resetStore(this, true)
  }
</code></pre>
<p><code>this._modules.update(newOptions)</code>方法是在<code>module-collection.js</code>文件中定义</p>
<pre><code class="language-javascript">  update (rawRootModule) {
    update([], this.root, rawRootModule)
  }

</code></pre>
<pre><code class="language-javascript">function update (path, targetModule, newModule) {
  if (process.env.NODE_ENV !== 'production') {
    assertRawModule(path, newModule)
  }

  // update target module
  targetModule.update(newModule)

  // update nested modules
  if (newModule.modules) {
    for (const key in newModule.modules) {
       // 如果传入的配置中没有该模块就报错
      if (!targetModule.getChild(key)) {
        if (process.env.NODE_ENV !== 'production') {
          console.warn(
            `[vuex] trying to add a new module '${key}' on hot reloading, ` +
            'manual reload is needed'
          )
        }
        return
      }
      update(
        path.concat(key),
        targetModule.getChild(key),
        newModule.modules[key]
      )
    }
  }
}

</code></pre>
<p>以上代码总的来说就是递归遍历模块，并更新模块，其中涉及到三个<code>update</code>方法，大家不要弄混。</p>
<pre><code>update([], this.root, rawRootModule)
</code></pre>
<p>主要传入了，一个空数组，原本的根模块对象，要用来替换的模块配置</p>
<pre><code class="language-javascript">function update (path, targetModule, newModule) {
  if (process.env.NODE_ENV !== 'production') {
    assertRawModule(path, newModule)
  }

  // update target module
  targetModule.update(newModule)

  // update nested modules
  if (newModule.modules) {
    for (const key in newModule.modules) {
       // 如果传入的配置中没有该模块就报错
      if (!targetModule.getChild(key)) {
        if (process.env.NODE_ENV !== 'production') {
          console.warn(
            `[vuex] trying to add a new module '${key}' on hot reloading, ` +
            'manual reload is needed'
          )
        }
        return
      }
      update(
        path.concat(key),
        targetModule.getChild(key),
        newModule.modules[key]
      )
    }
  }
</code></pre>
<p>递归遍历，原本的模块树，使用新模块替换掉原本模块</p>
<p>以上代码中还有一个模块中的<code>update</code>方法,即<code>targetModule.update(newModule)</code></p>
<pre><code class="language-javascript">// update target module
targetModule.update(newModule)

// module.js
update (rawModule) {
    this._rawModule.namespaced = rawModule.namespaced
    if (rawModule.actions) {
      this._rawModule.actions = rawModule.actions
    }
    if (rawModule.mutations) {
      this._rawModule.mutations = rawModule.mutations
    }
    if (rawModule.getters) {
      this._rawModule.getters = rawModule.getters
    }
  }
</code></pre>
<p>这个方法其实很简单，替换掉了原本的模块。</p>
<h2 id="辅助函数">辅助函数</h2>
<p><code>mapXXX</code>方法都在<code>helper.js</code>文件中</p>
<pre><code class="language-javascript">// helper.js
export const mapState = normalizeNamespace((namespace, states) =&gt; {
  //..
})

export const mapMutations = normalizeNamespace((namespace, mutations) =&gt; {
  // ..
})
// ...
</code></pre>
<p>可以看到他们都调用了<code>normalizeNamespace</code>方法，我们知道<code>mapXxx</code>是一个方法，所以它一定会返回一个方法</p>
<pre><code class="language-javascript">function normalizeNamespace (fn) {
  return (namespace, map) =&gt; {
    if (typeof namespace !== 'string') {
      map = namespace
      namespace = ''
    } else if (namespace.charAt(namespace.length - 1) !== '/') {
      namespace += '/'
    }
    return fn(namespace, map)
  }
}
</code></pre>
<p>这个方法实际上是对参数进行了处理，判断如果<code>namespace</code>不是字符串，也就是说它可能不存在，<code>namespace</code>就设置为一个空字符串，比如这样</p>
<pre><code>{
	computed: {
		...mapState(['username'])
	}
}
</code></pre>
<p>如果传入了<code>namespace</code>字符串，并且最后没有斜杠，就自动帮它加上，最后才是调用真实的<code>mapXXX</code>，比如这样</p>
<pre><code>{
	computed: {
		...mapState('user/', ['username'])
	}
}
</code></pre>
<p>接下来我们看一下<code>mapState</code>实现</p>
<h4 id="mapstate">mapState</h4>
<pre><code class="language-javascript">export const mapState = normalizeNamespace((namespace, states) =&gt; {
  const res = {}
  normalizeMap(states).forEach(({ key, val }) =&gt; {
    res[key] = function mappedState () {
      let state = this.$store.state
      let getters = this.$store.getters
      if (namespace) {
        const module = getModuleByNamespace(this.$store, 'mapState', namespace)
        if (!module) {
          return
        }
        state = module.context.state
        getters = module.context.getters
      }
      return typeof val === 'function'
        ? val.call(this, state, getters)
        : state[val]
    }
    // mark vuex getter for devtools
    res[key].vuex = true
  })
  return res
})
</code></pre>
<p>首先又是调用了一个<code>normalizeMap</code>方法，传入了我们需要获取的<code>states</code>,<code>normalizeMap</code>实现如下</p>
<pre><code class="language-javascript">function normalizeMap (map) {
  return Array.isArray(map)
    ? map.map(key =&gt; ({ key, val: key }))
    : Object.keys(map).map(key =&gt; ({ key, val: map[key] }))
}
</code></pre>
<p>这段代码看起来可能有点复杂，举个例子</p>
<pre><code class="language-javascript">normalizeMap([1, 2, 3]) =&gt; [ { key: 1, val: 1 }, { key: 2, val: 2 }, { key: 3, val: 3 } ]
normalizeMap(['user', 'count']) =&gt; [ { key: 'user', val: 'user' }, { key: 'count', val: 'count' }]

normalizeMap({a: 1, b: 2, c: 3}) =&gt; [ { key: 'a', val: 1 }, { key: 'b', val: 2 }, { key: 'c', val: 3 } ]
</code></pre>
<p>然后我们回到之前的代码</p>
<pre><code class="language-javascript">export const mapState = normalizeNamespace((namespace, states) =&gt; {
  const res = {}
  normalizeMap(states).forEach(({ key, val }) =&gt; {
    res[key] = function mappedState () {
      let state = this.$store.state
      let getters = this.$store.getters
      if (namespace) {
        const module = getModuleByNamespace(this.$store, 'mapState', namespace)
        if (!module) {
          return
        }
        state = module.context.state
        getters = module.context.getters
      }
      return typeof val === 'function'
        ? val.call(this, state, getters)
        : state[val]
    }
    // mark vuex getter for devtools
    res[key].vuex = true
  })
  return res
})
</code></pre>
<p>细心的童鞋可能注意到了，整个<code>mapState</code>返回的是一个对象，其形式如下，其他<code>mapMutations</code>,<code>mapActions</code>都可以这样</p>
<pre><code class="language-javascript">mapState('user', ['username', 'password'])

{
	username: function(){},
	password: function(){}
}

mapMutation('count', ['increment'])
</code></pre>
<p>现在知道为啥<code>mapState</code>要写在<code>computed</code>里了吧！原因就在这里。为了方便我就直接用注释分析了</p>
<pre><code class="language-javascript">    res[key] = function mappedState () {
      // store对象中的state,这个state是根state 
      let state = this.$store.state
      // 根getters
      let getters = this.$store.getters
      // 如果传入了namespace
      if (namespace) {
        // 调用getModuleByNamespace方法，源码实现在下方,它返回namespace对应的模块
        const module = getModuleByNamespace(this.$store, 'mapState', namespace)
        if (!module) {
          return
        }
        // 有看过前面源码应该记得，很多方法和对象都挂载到了context属性上
        state = module.context.state
        getters = module.context.getters
      }
      // 调用val或获取state
      return typeof val === 'function'
        ? val.call(this, state, getters)
        : state[val]
    }
    // mark vuex getter for devtools
    res[key].vuex = true
  })
</code></pre>
<pre><code class="language-javascript">function getModuleByNamespace (store, helper, namespace) {
   // _modulesNamespaceMap属性是不是很眼熟？
   // 它是在Store类的installModule方法中使用到，记录了namespace对应的module 
  const module = store._modulesNamespaceMap[namespace]
  if (process.env.NODE_ENV !== 'production' &amp;&amp; !module) {
    console.error(`[vuex] module namespace not found in ${helper}(): ${namespace}`)
  }
  return module
}
</code></pre>
<p>上面这些代码有几个注意点</p>
<ol>
<li>
<p><code>getModuleByNamespace</code>方法中的<code>store._modulesNamespaceMap[namespace]</code>是在<code>installModules</code>中进行的初始化</p>
</li>
<li>
<p><code>mapState</code>是可以传入回调函数的</p>
<pre><code>{
  computed: mapState({
    // 箭头函数可使代码更简练
    count: state =&gt; state.count,

    // 传字符串参数 'count' 等同于 `state =&gt; state.count`
    countAlias: 'count',

    // 为了能够使用 `this` 获取局部状态，必须使用常规函数
    countPlusLocalState (state) {
      return state.count + this.localCount
    }
  })
}
</code></pre>
</li>
</ol>
<h4 id="mapmutations">mapMutations</h4>
<pre><code class="language-javascript">export const mapMutations = normalizeNamespace((namespace, mutations) =&gt; {
  const res = {}
  normalizeMap(mutations).forEach(({ key, val }) =&gt; {
    res[key] = function mappedMutation (...args) {
      // Get the commit method from store
      let commit = this.$store.commit
      if (namespace) {
        const module = getModuleByNamespace(this.$store, 'mapMutations', namespace)
        if (!module) {
          return
        }
        commit = module.context.commit
      }
      return typeof val === 'function'
        ? val.apply(this, [commit].concat(args))
        : commit.apply(this.$store, [val].concat(args))
    }
  })
  return res
})
</code></pre>
<p>其他相同的代码就不讲了，关键看下面的</p>
<pre><code class="language-javascript">    res[key] = function mappedMutation (...args) {
      // Get the commit method from store
      let commit = this.$store.commit
      if (namespace) {
        const module = getModuleByNamespace(this.$store, 'mapMutations', namespace)
        if (!module) {
          return
        }
        commit = module.context.commit
      }
      return typeof val === 'function'
        ? val.apply(this, [commit].concat(args))
        : commit.apply(this.$store, [val].concat(args))
    }
</code></pre>
<p>这段代码其实和<code>mapState</code>里的相差不大，都是获取到<code>commit</code>,如果有<code>namespace</code>就获取模块里的<code>commit</code>,最后调用<code>commit</code>,它也可以传入一个回调函数,不过，举个例子</p>
<pre><code class="language-javascript">methods: {
	...mapMutations(['increment']),
	//等价于
	...mapMutations({
		add: function(commit, ...args){
		   commit('increment', ...args)
	    }
	}),
     // 等价于
    ...mapMutations({
      add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')`
    })
}
// 组件中调用
this.add(1)
</code></pre>
<h4 id="mapgetters">mapGetters</h4>
<pre><code class="language-javascript">export const mapGetters = normalizeNamespace((namespace, getters) =&gt; {
  const res = {}
  normalizeMap(getters).forEach(({ key, val }) =&gt; {
    // The namespace has been mutated by normalizeNamespace
    val = namespace + val
    res[key] = function mappedGetter () {
        // 如果namespace存在但是没有找到对应的模块 就直接返回，不做处理
      if (namespace &amp;&amp; !getModuleByNamespace(this.$store, 'mapGetters', namespace)) {
        return
      }
      // 如果没有找到对应的getter会报错并返回
      if (process.env.NODE_ENV !== 'production' &amp;&amp; !(val in this.$store.getters)) {
        console.error(`[vuex] unknown getter: ${val}`)
        return
      }
      
      return this.$store.getters[val]
    }
    // mark vuex getter for devtools
    res[key].vuex = true
  })
  return res
})
</code></pre>
<p>mapGetters和其它实现有所区别</p>
<ol>
<li>
<p>所有模块的<code>getters</code>都被代理在<code>store</code>对象中，所以直接使用<code>getter</code>的<code>key</code>和<code>namespace</code>拼接获取到对应的<code>getter</code>；具体在哪代理可以参见</p>
<pre><code class="language-javascript">// store.js 的makeLocalContext方法里的实现
Object.defineProperties(local, {
    getters: {
      get: noNamespace
        ? () =&gt; store.getters
        : () =&gt; makeLocalGetters(store, namespace)
    },
    state: {
      get: () =&gt; getNestedState(store.state, path)
    }
  })
</code></pre>
</li>
<li>
<p><code>getter</code>不支持传入函数</p>
</li>
</ol>
<h4 id="mapactions">mapActions</h4>
<pre><code class="language-javascript">export const mapActions = normalizeNamespace((namespace, actions) =&gt; {
  const res = {}
  normalizeMap(actions).forEach(({ key, val }) =&gt; {
    res[key] = function mappedAction (...args) {
      // get dispatch function from store
      let dispatch = this.$store.dispatch
      if (namespace) {
        const module = getModuleByNamespace(this.$store, 'mapActions', namespace)
        if (!module) {
          return
        }
        dispatch = module.context.dispatch
      }
      return typeof val === 'function'
        ? val.apply(this, [dispatch].concat(args))
        : dispatch.apply(this.$store, [val].concat(args))
    }
  })
  return res
})
</code></pre>
<p><code>mapActions</code>的实现和<code>mutation</code>的实现一模一样？确实是这样。。。下面只说下用法</p>
<pre><code class="language-javascript">methods: {
	...mapActions(['increment']),
	//等价于
	...mapActions({
		add: function(dispatch, ...args){
		   dispatch('increment', ...args)
	    }
	}),
     // 等价于
    ...mapActions({
      add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')`
    })
}
// 组件中调用
this.add(1)
</code></pre>
<h4 id="createnamespacedhelpers">createNamespacedHelpers</h4>
<pre><code class="language-javascript">export const createNamespacedHelpers = (namespace) =&gt; ({
  mapState: mapState.bind(null, namespace),
  mapGetters: mapGetters.bind(null, namespace),
  mapMutations: mapMutations.bind(null, namespace),
  mapActions: mapActions.bind(null, namespace)
})
</code></pre>
<p>官方例子</p>
<pre><code class="language-javascript">import { createNamespacedHelpers } from 'vuex'

const { mapState, mapActions } = createNamespacedHelpers('some/nested/module')

export default {
  computed: {
    // 在 `some/nested/module` 中查找
    ...mapState({
      a: state =&gt; state.a,
      b: state =&gt; state.b
    })
  },
  methods: {
    // 在 `some/nested/module` 中查找
    ...mapActions([
      'foo',
      'bar'
    ])
  }
}
</code></pre>
<p>对于这个<code>createNamespacedHelpers</code>如何实现，我想大家应该看的懂吧</p>
<h2 id="总结">总结</h2>
<p>终于分析完了<code>Vuex</code>的源码，完成这篇文章也是没事抽出空闲时间写出来的，可能会有错别字，分析错误或者有些我不知道的，欢迎大家指正，阅读源码也使我学到了很多东西，让我从陌生，逐渐开始得心应手，一直到现在，我对于源码不再是单纯的为了面试，而是一种兴趣，谢谢大家观看</p>
<h2 id="下一章">下一章</h2>
<p>逐行级源码分析系列(二) Redux和React-Redux源码（正在写作）</p>
<p>未完待续。。。</p>
]]></content>
    </entry>
</feed>