<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://1131153523.github.io</id>
    <title></title>
    <updated>2019-08-10T04:11:41.571Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://1131153523.github.io"/>
    <link rel="self" href="https://1131153523.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://1131153523.github.io/images/avatar.png</logo>
    <icon>https://1131153523.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, </rights>
    <entry>
        <title type="html"><![CDATA[逐行级源码分析系列(二)  Redux和React-Redux源码]]></title>
        <id>https://1131153523.github.io/post/3QTzMfYA8</id>
        <link href="https://1131153523.github.io/post/3QTzMfYA8">
        </link>
        <updated>2019-08-10T03:29:05.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>因为最近忙于秋招，平时只是花费空闲时间来写这篇博客，所以有些地方可能讲的不是很好，也不详细，现在看来不知道算不算是逐行了，希望大家能谅解，我一定会坚持写完这个系列。。</p>
<p>万字长文，大家谨慎观看</p>
<h2 id="系列文章">系列文章</h2>
<ul>
<li><a href="https://juejin.im/post/5d398f37e51d45106b15fff4">逐行级源码分析系列(一) Vuex</a></li>
<li><a href="https://juejin.im/post/5d4e38db5188251f6b1ef99b">逐行级源码分析系列(二)  Redux和React-Redux源码</a></li>
<li>逐行级源码分析系列(三) Vue-Router源码</li>
<li>逐行级源码分析系列(四) React-Router-Dom源码</li>
<li>逐行级源码分析系列(五) Express源码</li>
<li>逐行级源码分析系列(六) Koa核心源码</li>
<li>逐行级源码分析系列(六) Typescript版Axios源码</li>
</ul>
<h2 id="redux">Redux</h2>
<h3 id="一个例子">一个例子</h3>
<p>在看<code>redux</code>源码前，必须要理解的是发布订阅模式，下面我会用一个例子来实现一个简易版<code>redux</code>,方便大家理解</p>
<pre><code class="language-javascript">
const reducer = function(state = { count: 1 }, action) {
    switch(action.type) {
        case 'INCREMENT':
            return {
                ...state,
                count: count + 1
            }
        default:
            return state
    }
}

const createStore = function(reducer, preloadedState) {
    // 监听者数组
    const listeners = []
    // 如果有设置好的state,设置当前state
    let currentState = preloadedState
    const subscribe = function(fn) {
        listeners.push(fn)
        // 返回一个能取消订阅的函数
        return function() {
            const index = listeners.indexOf(fn)
            listeners.splice(index, 1)
        }
    }
    // 获取当前state
    const getState = function() {
        return currentState
    }
    
    const dispatch = function(action) {
        // 调用reducer，将新的state,替换掉当前的state
    	currentState = reducer(currentState, action)
        // 循环调用监听函数
        for (let i = 0;i &lt; listeners.length;i++) {
            let listener = listeners[i]
            listener()
        }
        return action
    }
    // 初始化
    dispatch({ type: ActionTypes.INIT })
    return {
        getState,
        subscribe,
        dispatch
    }
}
</code></pre>
<p>在react中使用</p>
<pre><code class="language-javascript">const store = createStore(reducer)
class App extends React.Component {
    constructor(props) {
        super(props)
        this.state = {
            store,
            count: 1
        }
    }
    componentWillMount() {
        // 当点击按钮之后，调用dispatch更新状态，然后调用订阅的监听函数，更新state
        // 在真正的react-redux中使用的其实是context来保存store
        this.state.store.subscribe(() =&gt; {
            this.setState({
                count: this.state.store.getState().count
            })
        })
    }
    handleClick = () =&gt; {
        this.state.store.dispatch({ type: 'INCREMENT' })
    }
    render() {
        return (
            &lt;div&gt;
                 &lt;button onClick={this.handleClick}&gt;&lt;/button&gt;
            	{ this.state.count }
            &lt;/div&gt;
        )
    }
}

</code></pre>
<p>看完上面的代码相信大家对<code>redux</code>会有一个比较深刻的认识，接下来我将根据源码来讲解</p>
<h3 id="入口">入口</h3>
<pre><code class="language-javascript">import createStore from './createStore'
import combineReducers from './combineReducers'
import bindActionCreators from './bindActionCreators'
import applyMiddleware from './applyMiddleware'
import compose from './compose'
import warning from './utils/warning'
import __DO_NOT_USE__ActionTypes from './utils/actionTypes'

/*
 * This is a dummy function to check if the function name has been altered by minification.
 * If the function has been minified and NODE_ENV !== 'production', warn the user.
 */
function isCrushed() {}

if (
  process.env.NODE_ENV !== 'production' &amp;&amp;
  typeof isCrushed.name === 'string' &amp;&amp;
  isCrushed.name !== 'isCrushed'
) {
  warning(
    'You are currently using minified code outside of NODE_ENV === &quot;production&quot;. ' +
      'This means that you are running a slower development build of Redux. ' +
      'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' +
      'or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) ' +
      'to ensure you have the correct code for your production build.'
  )
}

export {
  createStore,
  combineReducers,
  bindActionCreators,
  applyMiddleware,
  compose,
  __DO_NOT_USE__ActionTypes
}

</code></pre>
<p>入口代码其实非常简单，导出了一些方法,下面我们逐个分析</p>
<h3 id="createstore">createStore</h3>
<p>定位到<code>createStore.js</code>文件</p>
<p>首先我们分析以下这个方法的参数</p>
<pre><code class="language-javascript">export default function createStore(reducer, preloadedState, enhancer) {}
</code></pre>
<ul>
<li>
<p>reducer</p>
<p><strong>reducer函数</strong></p>
</li>
<li>
<p>preloadedState</p>
<p><strong>初始的state,可选参数</strong></p>
</li>
<li>
<p>enhancer</p>
<p><strong>它其实是<code>applyMiddleware</code>函数，这个函数很重要，以后也会讲到</strong></p>
</li>
</ul>
<p><strong>createStore返回的方法:</strong></p>
<ul>
<li>
<p>getState</p>
</li>
<li>
<p>subscribe</p>
</li>
<li>
<p>dispatch</p>
</li>
<li>
<p>replaceReducer</p>
</li>
<li></li>
</ul>
<p>讲完参数和返回值，继续看</p>
<pre><code class="language-javascript">  if (
    (typeof preloadedState === 'function' &amp;&amp; typeof enhancer === 'function') ||
    (typeof enhancer === 'function' &amp;&amp; typeof arguments[3] === 'function')
  ) {
    throw new Error(
      'It looks like you are passing several store enhancers to ' +
        'createStore(). This is not supported. Instead, compose them ' +
        'together to a single function.'
    )
  }
</code></pre>
<p>判断如果<code>preloadedState</code>是一个函数并且<code>enhancer</code>也是一个函数，就会抛出异常或者存在第四个参数是一个函数，也会抛出错误</p>
<pre><code class="language-javascript">  if (typeof preloadedState === 'function' &amp;&amp; typeof enhancer === 'undefined') {
    enhancer = preloadedState
    preloadedState = undefined
  }
</code></pre>
<p>对参数进行重载，如果我们只是用了<code>reducer</code>和<code>enhancer</code>，那么会对参数进行处理</p>
<p>然后是下面这段代码，也非常重要</p>
<pre><code class="language-javascript">  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error('Expected the enhancer to be a function.')
    }

    return enhancer(createStore)(reducer, preloadedState)
  }

</code></pre>
<p>这段代码实际上执行了<code>applyMiddleware</code>函数，在其中，使用中间件对<code>dispatch</code>进行了包装，返回了新的<code>store</code>,这个以后会讲到，这里提前剧透一点</p>
<pre><code class="language-javascript">export default function applyMiddleware(...middlewares) {
  return createStore =&gt; (...args) =&gt; {

    return {
      ...store,
      dispatch
    }
  }
}

</code></pre>
<p>可以看到，返回了新的<code>store</code></p>
<p>然后我们继续来看</p>
<pre><code class="language-javascript">  // 获取reducer
  let currentReducer = reducer   // 记录当前的reducer
  let currentState = preloadedState  // 记录当前state

  let currentListeners = []    // 记录监听函数
  let nextListeners = currentListeners  // 最新的Listeners

  // 是否正在Dispatch
  let isDispatching = false
</code></pre>
<p>这里初始化了一些变量，其作用不必多说，在继续后面的代码之前，大家回忆一下之前的例子，<code>createStore</code>返回了哪些方法，没错就是<code>getState</code>,<code>dispatch</code>,<code>subscribe</code>，其实并不止这些，还有<code>replaceReducer</code>以及<code>observable</code>,下面我将依次分析其源码</p>
<h4 id="getstate">getState</h4>
<pre><code class="language-javascript">  function getState() {

    // isDispatching为false不能获取当前state
    if (isDispatching) {
      throw new Error(
        'You may not call store.getState() while the reducer is executing. ' +
          'The reducer has already received the state as an argument. ' +
          'Pass it down from the top reducer instead of reading it from the store.'
      )
    }

    return currentState
  }
</code></pre>
<p>很简洁的代码，首先判断是否正在<code>dispatch</code>，如果是就会抛出异常，否则正常返回<code>currentState</code>,也就是当前最新的<code>state</code></p>
<h4 id="subscribe">subscribe</h4>
<pre><code class="language-javascript">  function subscribe(listener) {
    if (typeof listener !== 'function') {
      throw new Error('Expected the listener to be a function.')
    }

    if (isDispatching) {
      throw new Error(
        'You may not call store.subscribe() while the reducer is executing. ' +
          'If you would like to be notified after the store has been updated, subscribe from a ' +
          'component and invoke store.getState() in the callback to access the latest state. ' +
          'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.'
      )
    }

    let isSubscribed = true

    ensureCanMutateNextListeners()
    nextListeners.push(listener)

    return function unsubscribe() {
      if (!isSubscribed) {
        return
      }

      if (isDispatching) {
        throw new Error(
          'You may not unsubscribe from a store listener while the reducer is executing. ' +
            'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.'
        )
      }

      isSubscribed = false

      ensureCanMutateNextListeners()
      const index = nextListeners.indexOf(listener)
      nextListeners.splice(index, 1)
      currentListeners = null
    }
  }
</code></pre>
<p>第一个判断，确保传入的<code>listener</code>存在，第二个判断，确保能够正在<code>dispatch</code>的时候，不会<code>subscribe</code></p>
<pre><code class="language-javascript"> let isSubscribed = true
</code></pre>
<p>然后定义了一个变量，表示是否被订阅，因为如果没有被订阅，那么在调用<code>unsubscribe</code>也就是取消订阅是完全没有必要的，所以如果在<code>unsubscribe</code>中，检测到并没有被订阅，就会直接返回，不做处理</p>
<pre><code class="language-javascript">ensureCanMutateNextListeners()

function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice()
    }
}

</code></pre>
<p>然后这段代码主要是用来防止在订阅和取消订阅时出现一些问题，确保能够改变<code>nextListeners</code></p>
<pre><code class="language-javascript">nextListeners.push(listener)
</code></pre>
<p>最后把监听函数放在了<code>nextListeners</code>数组中，随后返回<code>unsubscribe</code></p>
<pre><code class="language-javascript">    return function unsubscribe() {
      if (!isSubscribed) {
        return
      }

      if (isDispatching) {
        throw new Error(
          'You may not unsubscribe from a store listener while the reducer is executing. ' +
            'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.'
        )
      }

      isSubscribed = false

      ensureCanMutateNextListeners()
      const index = nextListeners.indexOf(listener)
      nextListeners.splice(index, 1)
      currentListeners = null
    }
</code></pre>
<p>其实也是利用了闭包的特点，能够把监听函数保留在内存中</p>
<h4 id="dispatch">dispatch</h4>
<pre><code class="language-javascript">  function dispatch(action) {
    if (!isPlainObject(action)) {
      throw new Error(
        'Actions must be plain objects. ' +
          'Use custom middleware for async actions.'
      )
    }

    if (typeof action.type === 'undefined') {
      throw new Error(
        'Actions may not have an undefined &quot;type&quot; property. ' +
          'Have you misspelled a constant?'
      )
    }

    if (isDispatching) {
      throw new Error('Reducers may not dispatch actions.')
    }

    try {
      isDispatching = true
      currentState = currentReducer(currentState, action)
    } finally {
      isDispatching = false
    }

    const listeners = (currentListeners = nextListeners)
    for (let i = 0; i &lt; listeners.length; i++) {
      const listener = listeners[i]
      listener()
    }

    return action
  }
</code></pre>
<p>第一个判断<code>action</code>是否是一个对象，否则报错</p>
<p>第二个判断<code>action</code>中的类型是否存在，如果不存在也会报错</p>
<p>第三个判断，保证不会再<code>dispatch</code>的时候再<code>dispatch</code>防止出现一些无法预估的问题</p>
<p>这个方法我把它缩短点，大家就能看懂了</p>
<pre><code class="language-javascript">  function dispatch(action) {
    try {
      isDispatching = true
      currentState = currentReducer(currentState, action)
    } finally {
      isDispatching = false
    }
    const listeners = (currentListeners = nextListeners)
    for (let i = 0; i &lt; listeners.length; i++) {
      const listener = listeners[i]
      listener()
    }

    return action
  }
</code></pre>
<p>对于<code>currentReducer</code>的调用前后设置了不同的状态，给<code>currentReducer</code>函数传入了当前的<code>state</code>和<code>action</code>，然后拿到返回的新的<code>state</code>，替换掉原本的<code>state</code>,也就是<code>currentState</code>。随后依次调用<code>nextListeners</code>数组中存方的监听函数</p>
<h4 id="replacereducer">replaceReducer</h4>
<p>按照字面意思就知道是替换掉原本的<code>reducer</code>,我们看一下其实现</p>
<pre><code class="language-javascript">  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== 'function') {
      throw new Error('Expected the nextReducer to be a function.')
    }

    currentReducer = nextReducer

    // This action has a similiar effect to ActionTypes.INIT.
    // Any reducers that existed in both the new and old rootReducer
    // will receive the previous state. This effectively populates
    // the new state tree with any relevant data from the old one.
    dispatch({ type: ActionTypes.REPLACE })
  }
</code></pre>
<p>如果传入的新的<code>reducer</code>不存在就会报错</p>
<p>直接使用新的<code>reducer</code>替换掉了原本的<code>currentReducer</code>,然后调用<code>dispatch({ type: ActionTypes.REPLACE })</code>,初始化，相当于调用了<code>reducer</code>重置了<code>currentState</code>,至于<code>ActionTypes</code>其实是记录了一些状态</p>
<h4 id="observable">observable</h4>
<pre><code class="language-javascript">  function observable() {
    const outerSubscribe = subscribe
    return {
      subscribe(observer) {
        if (typeof observer !== 'object' || observer === null) {
          throw new TypeError('Expected the observer to be an object.')
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState())
          }
        }

        observeState()
        const unsubscribe = outerSubscribe(observeState)
        return { unsubscribe }
      },

      [$$observable]() {
        return this
      }
    }
  }
</code></pre>
<p><code>observable</code>函数是为<code>observable/reactive</code>库预留的交互接口，下面举个<code>Rxjs的Observable</code>例子</p>
<pre><code class="language-javascript">const observable = Rx.Observable.create(observer =&gt; {
  const id = setTimeout(() =&gt; observer.next('...'), 5000); // emit value after 5s

  return () =&gt; { clearTimeout(id); console.log('cleared!'); };
});

const subscription = observable.subscribe(value =&gt; console.log(value));

setTimeout(() =&gt; subscription.unsubscribe(), 3000); // cancel subscription after 3s

</code></pre>
<pre><code class="language-javascript">const outerSubscribe = subscribe
</code></pre>
<p>首先保留原本的<code>subscribe</code></p>
<p>然后返回了一个对象</p>
<pre><code class="language-javascript">    return {
      subscribe(observer) {
        if (typeof observer !== 'object' || observer === null) {
          throw new TypeError('Expected the observer to be an object.')
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState())
          }
        }

        observeState()
        const unsubscribe = outerSubscribe(observeState)
        return { unsubscribe }
      },

      [$$observable]() {
        return this
      }
    }
</code></pre>
<p><code>subscribe</code>中第一个判断：observer参数必须是一个对象，否则抛出异常</p>
<pre><code class="language-javascript">        function observeState() {
          if (observer.next) {
            observer.next(getState())
          }
        }
        observeState()
</code></pre>
<p>创建了一个状态变更函数，把<code>state</code>传给了<code>observer</code>,然后立即执行<code>observeState</code>函数</p>
<pre><code class="language-javascript">      [$$observable]() {
        return this
      }
</code></pre>
<p>这个函数使用来返回<code>observable</code>对象</p>
<pre><code class="language-javascript">export default function createStore(reducer, preloadedState, enhancer) {
    
    // ...一些方法
    
  dispatch({ type: ActionTypes.INIT })

  return {
    dispatch,
    subscribe,
    getState,
    replaceReducer,
    [$$observable]: observable
  }
}
</code></pre>
<p>最后调用一次<code>dispatch</code>，为什么要单独调用一次呢，其实是为了初始化<code>currentState</code>,大家可以想象以下，调用<code>dispatch</code>之后会发生什么，由于我们并没有传入<code>preloadedState</code>，所以此时的<code>currentState</code>是<code>undefined</code>,调用<code>dispatch</code>之后它会调用<code>reducer</code>，返回一个我们自己的默认<code>state</code>(注意：<code>{ type: ActionTypes.INIT }</code>其实没有任何用处，只是一种标识)</p>
<pre><code class="language-javascript"> // dispatch方法    
    try {
      isDispatching = true
      currentState = currentReducer(currentState, action)
    } finally {
      isDispatching = false
    }
</code></pre>
<p>大家看到上面的代码，相信应该能明白了吧，关于<code>createStore</code>函数的介绍就到这里了</p>
<h3 id="bindactioncreators">bindActionCreators</h3>
<p>我们直接来看下，这个函数的实现，它也是在一个单独的文件<code>bindActionCreators.js</code></p>
<pre><code class="language-javascript">function bindActionCreator(actionCreator, dispatch) {
  return function() {
    return dispatch(actionCreator.apply(this, arguments))
  }
}
</code></pre>
<p>这个文件中，有一个内部的私有方法<code>bindActionCreator</code>,它和<code>bindActionCreators</code>的唯一区别就是少了一个字母，其实它就是用来单独处理<code>action</code>和<code>dispatch</code>之间的绑定，它利用了闭包的特性，返回了一个新的函数，直接调用就相当于调用了<code>dispatch</code></p>
<pre><code class="language-javascript">export default function bindActionCreators(actionCreators, dispatch) {
  if (typeof actionCreators === 'function') {
    return bindActionCreator(actionCreators, dispatch)
  }

  if (typeof actionCreators !== 'object' || actionCreators === null) {
    throw new Error(
      `bindActionCreators expected an object or a function, instead received ${
        actionCreators === null ? 'null' : typeof actionCreators
      }. ` +
        `Did you write &quot;import ActionCreators from&quot; instead of &quot;import * as ActionCreators from&quot;?`
    )
  }

  const boundActionCreators = {}
  for (const key in actionCreators) {
    const actionCreator = actionCreators[key]
    if (typeof actionCreator === 'function') {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)
    }
  }
  return boundActionCreators
}

</code></pre>
<p>然后我们再来看<code>bindActionCreators</code>,他的第一个参数是一个由<code>actionCreator</code>组成的对象，第二个参数就是<code>dispatch</code>方法</p>
<p>第一个判断：如果只传入了一个<code>actionCreator</code>，直接调用<code>bindActionCreator</code>,返回一个函数</p>
<p>第二个判断：如果<code>actionCreators</code>不是对象，或者传入的是<code>undefined</code>，<code>null</code>就会抛出错误</p>
<pre><code class="language-javascript">  const boundActionCreators = {}
  for (const key in actionCreators) {
    const actionCreator = actionCreators[key]
    if (typeof actionCreator === 'function') {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)
    }
  }
  return boundActionCreators
</code></pre>
<p>然后是这段代码，他会遍历所有的<code>actionCreator</code>,把<code>actionCreator</code>的键作为，<code>boundActionCreators</code>对象中的一个键，并调用<code>bindActionCreator</code>对每个<code>actionCreator</code>进行处理，把处理返回的函数，作为<code>boundActionCreators</code>对象中的键的值，类似这样</p>
<pre><code class="language-javascript">{
	incrementAction(){
		return {
			type: 'INCREMENT'
		}
	},
	decrementAction(){
		return {
			type: 'DECREMENT'
		}
	}
}
// 经过bindActionCreators处理
{
	incrementAction: function() {
		dispatch(incrementAction())
	},
	decrementAction: function() {
		dispatch(decrementAction())
	}
}


// 原本我们要这么用
store.dispatch(incrementAction())

// 现在
incrementAction()
</code></pre>
<p>怎么样是不是很方便！</p>
<p>ok，现在bindActionCreators我们也讲解完了</p>
<h3 id="combinereducers">combineReducers</h3>
<p>这个函数的实现也是在一个单独文件里，它里面也有很多内置函数，因为内容比较多，我们一开始只展示一部分</p>
<pre><code class="language-javascript">export default function combineReducers(reducers) {
  const reducerKeys = Object.keys(reducers)
  const finalReducers = {}
  for (let i = 0; i &lt; reducerKeys.length; i++) {
    const key = reducerKeys[i]

    if (process.env.NODE_ENV !== 'production') {
      if (typeof reducers[key] === 'undefined') {
        warning(`No reducer provided for key &quot;${key}&quot;`)
      }
    }

    if (typeof reducers[key] === 'function') {
      finalReducers[key] = reducers[key]
    }
  }
  const finalReducerKeys = Object.keys(finalReducers)

  // This is used to make sure we don't warn about the same
  // keys multiple times.
  let unexpectedKeyCache
  if (process.env.NODE_ENV !== 'production') {
    unexpectedKeyCache = {}
  }

  let shapeAssertionError
  try {
    assertReducerShape(finalReducers)
  } catch (e) {
    shapeAssertionError = e
  }

  return function combination(state = {}, action) {
    if (shapeAssertionError) {
      throw shapeAssertionError
    }

    if (process.env.NODE_ENV !== 'production') {
      const warningMessage = getUnexpectedStateShapeWarningMessage(
        state,
        finalReducers,
        action,
        unexpectedKeyCache
      )
      if (warningMessage) {
        warning(warningMessage)
      }
    }

    let hasChanged = false
    const nextState = {}
    for (let i = 0; i &lt; finalReducerKeys.length; i++) {
      const key = finalReducerKeys[i]
      const reducer = finalReducers[key]
      const previousStateForKey = state[key]
      const nextStateForKey = reducer(previousStateForKey, action)
      if (typeof nextStateForKey === 'undefined') {
        const errorMessage = getUndefinedStateErrorMessage(key, action)
        throw new Error(errorMessage)
      }
      nextState[key] = nextStateForKey
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey
    }
    return hasChanged ? nextState : state
  }
}

</code></pre>
<p>首先只要用过<code>combineReducers</code>函数，大家都知道，<code>combineReducers</code>返回的是一个新的<code>reducer</code>,那么它是怎么实现，把<code>action</code>分发到不同的<code>reducer</code>，大家可以先思考一下</p>
<p>仔细想一想，还是挺好实现的，其实就是循环调用每个<code>reducer</code>，传入<code>action</code>,我们知道<code>reducer</code>里面是有<code>switch</code>语句的，它是一个纯函数，不会造成其他的副作用，所以一定会有对应的<code>action</code>会被触发，下面我们具体分析</p>
<pre><code class="language-javascript">  const reducerKeys = Object.keys(reducers)
  const finalReducers = {}
  for (let i = 0; i &lt; reducerKeys.length; i++) {
    const key = reducerKeys[i]

    if (process.env.NODE_ENV !== 'production') {
      if (typeof reducers[key] === 'undefined') {
        warning(`No reducer provided for key &quot;${key}&quot;`)
      }
    }

    if (typeof reducers[key] === 'function') {
      finalReducers[key] = reducers[key]
    }
  }
</code></pre>
<p>首先是拿到了所有的<code>reducer</code>函数，获取到它的<code>keys</code>,根据<code>key</code>值，遍历所有的<code>reducer</code></p>
<p>第一个判断：<code>reducer</code>是否是函数，是否不存在，如果都不成立就报出警告</p>
<p>第二个判断：相当于一层过滤，防止有不是函数的<code>reducer</code>，然后把正确的<code>reducer</code>放在了一个新对象<code>finalReducers</code>中</p>
<pre><code class="language-javascript">  const finalReducerKeys = Object.keys(finalReducers)

  // This is used to make sure we don't warn about the same
  // keys multiple times.
  let unexpectedKeyCache
  if (process.env.NODE_ENV !== 'production') {
    unexpectedKeyCache = {}
  }
  let shapeAssertionError
  try {
    assertReducerShape(finalReducers)
  } catch (e) {
    shapeAssertionError = e
  }
</code></pre>
<p>首先获取到<code>reducer</code>的<code>keys</code>数组，这个暂时不讲，后面有用到，大家先留个印象，然后再开发环境，创建了一个<code>unexpectedKeyCache</code>对象，然后在后面又调用了<code>assertReducerShape(finalReducers)</code>函数，它的实现如下</p>
<pre><code class="language-javascript">function assertReducerShape(reducers) {
  Object.keys(reducers).forEach(key =&gt; {
    const reducer = reducers[key]
    const initialState = reducer(undefined, { type: ActionTypes.INIT })
    if (typeof initialState === 'undefined') {
      throw new Error(
        `Reducer &quot;${key}&quot; returned undefined during initialization. ` +
          `If the state passed to the reducer is undefined, you must ` +
          `explicitly return the initial state. The initial state may ` +
          `not be undefined. If you don't want to set a value for this reducer, ` +
          `you can use null instead of undefined.`
      )
    }

    if (
      typeof reducer(undefined, {
        type: ActionTypes.PROBE_UNKNOWN_ACTION()
      }) === 'undefined'
    ) {
      throw new Error(
        `Reducer &quot;${key}&quot; returned undefined when probed with a random type. ` +
          `Don't try to handle ${ActionTypes.INIT} or other actions in &quot;redux/*&quot; ` +
          `namespace. They are considered private. Instead, you must return the ` +
          `current state for any unknown actions, unless it is undefined, ` +
          `in which case you must return the initial state, regardless of the ` +
          `action type. The initial state may not be undefined, but can be null.`
      )
    }
  })
}
</code></pre>
<p>整个函数所做的事还是挺简单的，遍历了所有的<code>reducer</code>,然后调用<code>reducer</code>，判断它的返回值，如果为<code>undefined</code>就抛出错误，一般来说这种报错都是我们没有设置<code>state</code>默认值或者在<code>switch</code>中没有<code>default</code>默认返回<code>state</code></p>
<p>我们回到刚才的讲解,大家应该还记得<code>shapeAssertionError</code>这个变量吧,如果我们在<code>reducer</code>中没有返回默认值，就会把错误记录在这个变量中，然后我们继续看<code>combineReducers</code>返回的函数</p>
<pre><code class="language-javascript">export default function combineReducers(reducers) {
  // .. .....
  
  return function combination(state = {}, action) {
    if (shapeAssertionError) {
      throw shapeAssertionError
    }

    if (process.env.NODE_ENV !== 'production') {
      const warningMessage = getUnexpectedStateShapeWarningMessage(
        state,
        finalReducers,
        action,
        unexpectedKeyCache
      )
      if (warningMessage) {
        warning(warningMessage)
      }
    }

    let hasChanged = false
    const nextState = {}
    for (let i = 0; i &lt; finalReducerKeys.length; i++) {
      const key = finalReducerKeys[i]
      const reducer = finalReducers[key]
      const previousStateForKey = state[key]
      const nextStateForKey = reducer(previousStateForKey, action)
      if (typeof nextStateForKey === 'undefined') {
        const errorMessage = getUndefinedStateErrorMessage(key, action)
        throw new Error(errorMessage)
      }
      nextState[key] = nextStateForKey
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey
    }
    return hasChanged ? nextState : state
  }
}
</code></pre>
<p>从它的参数来看，就是一个<code>reducer</code>所具备的参数</p>
<p>第一个判断：<code>shapeAssertionError</code>如果存在就抛出错误，这个刚刚我们讲过</p>
<p>第二个判断：如果在开发环境，就调用<code>getUnexpectedStateShapeWarningMessage</code>函数，从这个函数的字面意思相信大家都知道了，获取不在预期形式<code>state</code>的警号信息，没错就是用来获取警告信息，然后判断警告信息如果存在就在开发环境警告,具体看下<code>getUnexpectedStateShapeWarningMessage</code>函数实现,因为内容实在太多，而且并不是很重要，我就把讲解写在注释中</p>
<pre><code class="language-javascript">// 调用
const warningMessage = getUnexpectedStateShapeWarningMessage(
   state,  // 传入reducer的默认state
   finalReducers,  // reducers对象
   action, 
   unexpectedKeyCache  // 一个空对象
)
</code></pre>
<pre><code class="language-javascript">// 实现
function getUnexpectedStateShapeWarningMessage(
  inputState,
  reducers,
  action,
  unexpectedKeyCache
) {
  // 获取reducers中的keys
  const reducerKeys = Object.keys(reducers)
  const argumentName =
    action &amp;&amp; action.type === ActionTypes.INIT
      ? 'preloadedState argument passed to createStore'
      : 'previous state received by the reducer'
  
  
  // 如果我们调用combineReducers但是没有传入任何reducer就会直接返回错误信息
  if (reducerKeys.length === 0) {
    return (
      'Store does not have a valid reducer. Make sure the argument passed ' +
      'to combineReducers is an object whose values are reducers.'
    )
  }

   // 如果state不是一个对象，就返回错误信息
  if (!isPlainObject(inputState)) {
    return (
      `The ${argumentName} has unexpected type of &quot;` +
      {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] +
      `&quot;. Expected argument to be an object with the following ` +
      `keys: &quot;${reducerKeys.join('&quot;, &quot;')}&quot;`
    )
  }
// 给state中存在而reducer中不存在的属性添加缓存标识
  const unexpectedKeys = Object.keys(inputState).filter(
    key =&gt; !reducers.hasOwnProperty(key) &amp;&amp; !unexpectedKeyCache[key]
  )
  // 设置缓存
  unexpectedKeys.forEach(key =&gt; {
    unexpectedKeyCache[key] = true
  })
// 如果调用replaceReducer会触发这里的返回，详细参见replaceReducer具体实现
  if (action &amp;&amp; action.type === ActionTypes.REPLACE) return
  // 如果unexpectedKeys有内容就返回错误信息
  if (unexpectedKeys.length &gt; 0) {
    return (
      `Unexpected ${unexpectedKeys.length &gt; 1 ? 'keys' : 'key'} ` +
      `&quot;${unexpectedKeys.join('&quot;, &quot;')}&quot; found in ${argumentName}. ` +
      `Expected to find one of the known reducer keys instead: ` +
      `&quot;${reducerKeys.join('&quot;, &quot;')}&quot;. Unexpected keys will be ignored.`
    )
  }
}
</code></pre>
<p>讲完这些，我们看最后的一些代码</p>
<pre><code class="language-javascript">    let hasChanged = false
    const nextState = {}
    for (let i = 0; i &lt; finalReducerKeys.length; i++) {
      const key = finalReducerKeys[i]
      const reducer = finalReducers[key]
      const previousStateForKey = state[key]
      const nextStateForKey = reducer(previousStateForKey, action)
      if (typeof nextStateForKey === 'undefined') {
        const errorMessage = getUndefinedStateErrorMessage(key, action)
        throw new Error(errorMessage)
      }
      nextState[key] = nextStateForKey
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey
    }
    return hasChanged ? nextState : state
</code></pre>
<p>简单来讲，本质上还是调用了<code>reducer</code>,而且是调用了每个<code>reducer</code></p>
<p><code>hasChanged</code>用于判断，如果前后值并没有发生改变，就返回原本的值，否则返回新的<code>state</code>值</p>
<p><code>nextState</code>保存新的<code>state</code>值</p>
<pre><code class="language-javascript">      const key = finalReducerKeys[i]
      const reducer = finalReducers[key]
      const previousStateForKey = state[key]
      const nextStateForKey = reducer(previousStateForKey, action)
</code></pre>
<p>这些代码就不多做解释了，重要一点的是<code>state[key]</code>,他把<code>reducer</code>的<code>key</code>,作为<code>state</code>的<code>key</code>,例如</p>
<pre><code class="language-javascript">combineReducer({
    user,
    cart
})

// 使用state
const state = store.getState()
const userState = state.user
</code></pre>
<pre><code class="language-javascript">      if (typeof nextStateForKey === 'undefined') {
        const errorMessage = getUndefinedStateErrorMessage(key, action)
        throw new Error(errorMessage)
      }
      nextState[key] = nextStateForKey
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey
</code></pre>
<p>最后就是上面这段代码</p>
<p>判断：如果此reducer返回的新的state是undefined，抛出异常</p>
<p>然后把新的<code>state</code>放入<code>nextState</code>对象中，并返回，最后对前后的值进行了对比，也是一种优化</p>
<h3 id="applymiddleware">applyMiddleware</h3>
<pre><code class="language-javascript">export default function applyMiddleware(...middlewares) {
  return createStore =&gt; (...args) =&gt; {
    const store = createStore(...args)
    let dispatch = () =&gt; {
      throw new Error(
        'Dispatching while constructing your middleware is not allowed. ' +
          'Other middleware would not be applied to this dispatch.'
      )
    }

    const middlewareAPI = {
      getState: store.getState,
      dispatch: (...args) =&gt; dispatch(...args)
    }
    const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))
    dispatch = compose(...chain)(store.dispatch)

    return {
      ...store,
      dispatch
    }
  }
}

</code></pre>
<p>中间件的作用实际上是对<code>dispatch</code>进行了包装,<code>applyMiddleware</code>函数，连续返回了两个函数，包括它本身，就有三层函数，这三层函数为什么这么设计，我也不清楚，我个人认为一层也可以。</p>
<p>然后又调用<code>createStore</code>,拿到了当前的<code>store</code>,之后对<code>store</code>中的<code>dispatch</code>方法进行了处理</p>
<pre><code class="language-javascript">    const middlewareAPI = {
      getState: store.getState,
      dispatch: (...args) =&gt; dispatch(...args)
    }
    const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))
    dispatch = compose(...chain)(store.dispatch)

</code></pre>
<p>这段代码其实是有点难理解的，我们拆分来讲</p>
<pre><code class="language-javascript">    const middlewareAPI = {
      getState: store.getState,
      dispatch: (...args) =&gt; dispatch(...args)
    }
    const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))
</code></pre>
<p>大家可能不知道这到底干了什么，先卖个关子，<code>middlewareAPI</code>的作用是给中间件传入<code>dispatch</code>方法和<code>getState</code>，它利用了闭包的特性，至于它的使用，在后面实现中间件的时候会有讲解</p>
<pre><code class="language-javascript">dispatch = compose(...chain)(store.dispatch)
</code></pre>
<p>最关键的代码来了，下面详细讲解<code>compose</code>函数</p>
<h3 id="compose">compose</h3>
<pre><code class="language-javascript">export default function compose(...funcs) {
  if (funcs.length === 0) {
    return arg =&gt; arg
  }

  if (funcs.length === 1) {
    return funcs[0]
  }

  return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))
}

</code></pre>
<p><code>compose</code>的实现非常简单，但是又非常重要，它是<code>applyMiddleware</code>的核心与关键，在讲<code>compose</code>之前我先从三个方面介绍这个函数</p>
<ul>
<li>
<p><code>redux</code>中间件参照了<code>koa</code>中间件的实现，以后我在讲解<code>koa</code>源码分析系列也会讲到</p>
</li>
<li>
<p>洋葱模型</p>
<p><img src="C:%5CUsers%5C86176%5CDesktop%5C2474077171-5ab493c984bf8_articlex.png" alt=""></p>
<p>大家把洋葱的中心想象成<code>dispatch</code>函数，后面大家会明白</p>
</li>
<li>
<p>函数组合</p>
</li>
</ul>
<p>以上三者是什么，大家如果有不知道的，希望可以查一下方便大家理解</p>
<p>总的来说这个函数所作的事情，就是把一个函数的返回值，作为另一个函数的参数，不断地迭代</p>
<p>在<code>redux</code>的角度来讲：对<code>dispatch</code>进行了一层层的包装，有点像装饰器，我再画一张图方便理解</p>
<p><img src="C:%5CUsers%5C86176%5CDesktop%5CQQ%E6%88%AA%E5%9B%BE20190727011616.png" alt=""></p>
<p>如果我们有使用中间件，我们拿到的<code>dispatch</code>实际上是被包装后的<code>dispatch</code>，对于<code>compose</code>的代码，希望大家多看几遍</p>
<h3 id="logger中间件实现">logger中间件实现</h3>
<pre><code class="language-javascript">const logger1 = function({ dispatch, getState }) {
  return function(next) {
    return function(action) {
      // 打印旧state
      console.log('old', getState());
      next(action)
      // 打印新state
      console.log('new', getState());
    }
  }
}
</code></pre>
<p>首先中间件返回了一个函数,还记得<code>middlewareAPI</code>吗，第一层的函数就是用来保存<code>middlewareAPI</code>中的方法，</p>
<p>第二层函数：这个函数的参数，是经过上一层中间件包装后的或者原始的<code>dispatch</code>方法</p>
<p>第三层函数：参数是<code>action</code>，它是包装后的<code>dispatch</code>，假如还有下一个中间件，就会把第三层函数，作为参数，传给下一个中间件的第二层函数，也就是<code>next</code></p>
<p>讲完这些可能还是没明白，希望大家结合上面的图，多看几遍,理解之后看后面的中间件实现旧方便很多</p>
<h3 id="redux-thunk中间件实现">redux-thunk中间件实现</h3>
<pre><code class="language-javascript">const thunk = ({ dispatch, getState }) =&gt; next =&gt; action =&gt; {
  if (typeof action === 'function') {
    action(dispatch, getState)
  } else {
    next(action)
  }
}
</code></pre>
<h3 id="redux-promise中间件实现">redux-promise中间件实现</h3>
<pre><code class="language-javascript">const promise = ({ dispatch, getState }) =&gt; next =&gt; action =&gt; {
   if (action.then) {
      action.then(function(data) {
        dispatch(data)
      })
   } else {
      next(action)
   }
}

</code></pre>
<h2 id="react-redux">React-Redux</h2>
<p>虽然讲完了<code>redux</code>，但是它在<code>react</code>中使用还是要借助<code>react-redux</code>的，下面我将从入口文件开始</p>
<pre><code class="language-javascript">import Provider from './components/Provider'
import connectAdvanced from './components/connectAdvanced'
import { ReactReduxContext } from './components/Context'
import connect from './connect/connect'

import { useDispatch } from './hooks/useDispatch'
import { useSelector } from './hooks/useSelector'
import { useStore } from './hooks/useStore'

import { setBatch } from './utils/batch'
import { unstable_batchedUpdates as batch } from './utils/reactBatchedUpdates'
import shallowEqual from './utils/shallowEqual'

setBatch(batch)

export {
  Provider,
  connectAdvanced,
  ReactReduxContext,
  connect,
  batch,
  useDispatch,
  useSelector,
  useStore,
  shallowEqual
}


</code></pre>
<p>从这个文件来看，<code>react-redux</code>，返回了这些函数</p>
<pre><code class="language-javascript">  Provider,
  connectAdvanced,
  ReactReduxContext,
  connect,
  batch,
  useDispatch,
  useSelector,
  useStore,
  shallowEqual
</code></pre>
<p><code>Provider</code>,<code>connect</code>这两个是我们常用的函数，但其它的，在这里说实话我从来没用过，这也是在我看源码的时候才知道的API，看源码的过程就是学习API的过程，在我看来也算是种查漏补缺</p>
<p>同时如果有注意到的话能够发现，它导出了<code>batch</code>,而在上面的<code>setBatch(batch)</code>，也有使用到,那么这个<code>batch</code>又是什么呢，先从<code>setBatch</code>讲起</p>
<h3 id="batch">batch</h3>
<pre><code class="language-javascript">// batch.js
function defaultNoopBatch(callback) {
  callback()
}

let batch = defaultNoopBatch

// Allow injecting another batching function later
export const setBatch = newBatch =&gt; (batch = newBatch)

// Supply a getter just to skip dealing with ESM bindings
export const getBatch = () =&gt; batch
</code></pre>
<p>手写给<code>batch</code>设置了一个默认函数<code>defaultNoopBatch</code>,它没有做什么处理，只是调用了传入的回调函数</p>
<p>这个文件导出了两个函数<code>setBatch</code>和<code>getBatch</code>,分别用于设置和获取<code>batch</code></p>
<pre><code class="language-javascript">import { unstable_batchedUpdates as batch } from './utils/reactBatchedUpdates'


setBatch(batch)
</code></pre>
<p>我们知道在<code>index.js</code>种调用了<code>setBatch</code>方法，并传入了<code>batch</code>,来看下这个<code>batch</code>是什么</p>
<pre><code class="language-javascript">export { unstable_batchedUpdates } from 'react-dom'
</code></pre>
<p>没想到尽然是<code>react-deom</code>里面的一个方法，<code>unstable_batchedUpdates</code>又是啥，其实在看源码之前我也是不知道的，看源码真的是能学到东西啊，嘿嘿，为了方便介绍<code>unstable_batchedUpdates</code>,下面举个例子</p>
<pre><code class="language-javascript">class Sub extends PureComponent {
    state = {
        b: false,
        a: false
    }

    handleClick = () =&gt; {
		this.setState({
            a: true
        })
        this.setState({
            b: true
        })
    }

    render() {
    	return &lt;button onClick={this.handleClick}&gt;Click&lt;/button&gt;
    }
}
</code></pre>
<p>在这个点击事件中，更新总是<strong>按照它们发生的顺序进行浅合并</strong>, <strong>在 React 事件处理程序中，不论 setState() 调用了多少次，也不论 setState()被多少个组件调用，它们在事件结束时只会生成一次重新渲染</strong>**</p>
<pre><code class="language-javascript">promise.then(() =&gt; {
  // 强制批量处理
  ReactDOM.unstable_batchedUpdates(() =&gt; {
    this.setState({a: true}); // 不重新渲染
    this.setState({b: true}); // 不重新渲染
    this.props.setParentState(); // 不重新渲染
  });
  // 当我们退出 unstable_batchedUpdates函数后，重新渲染一次
});
</code></pre>
<p>所以<code>unstable_batchedUpdates</code>方法就是用来批量更新<code>state</code>,并只渲染一次</p>
<p>某大佬github中有更详细讲解，我也是参考了其文章：</p>
<p>知道了<code>batch</code>是干嘛的，我们回到<code>index.js</code></p>
<pre><code class="language-javascript">export {
  Provider,
  connectAdvanced,
  ReactReduxContext,
  connect,
  batch,
  useDispatch,
  useSelector,
  useStore,
  shallowEqual
}
</code></pre>
<p>接下来讲解<code>Provider</code></p>
<h3 id="provider">Provider</h3>
<pre><code class="language-javascript">import React, { Component } from 'react'
import PropTypes from 'prop-types'
import { ReactReduxContext } from './Context'
import Subscription from '../utils/Subscription'

class Provider extends Component {
  constructor(props) {
    super(props)
    const { store } = props
    this.notifySubscribers = this.notifySubscribers.bind(this)
    const subscription = new Subscription(store)
    subscription.onStateChange = this.notifySubscribers

    this.state = {
      store,
      subscription
    }

    this.previousState = store.getState()
  }

  componentDidMount() {
    this.state.subscription.trySubscribe()
    if (this.previousState !== this.props.store.getState()) {
      this.state.subscription.notifyNestedSubs()
    }
  }

  componentWillUnmount() {
    if (this.unsubscribe) this.unsubscribe()

    this.state.subscription.tryUnsubscribe()
  }

  componentDidUpdate(prevProps) {
    if (this.props.store !== prevProps.store) {
      this.state.subscription.tryUnsubscribe()
      const subscription = new Subscription(this.props.store)
      subscription.onStateChange = this.notifySubscribers
      this.setState({ store: this.props.store, subscription })
    }
  }

  notifySubscribers() {
    this.state.subscription.notifyNestedSubs()
  }

  render() {
    const Context = this.props.context || ReactReduxContext

    return (
      &lt;Context.Provider value={this.state}&gt;
        {this.props.children}
      &lt;/Context.Provider&gt;
    )
  }
}

Provider.propTypes = {
  store: PropTypes.shape({
    subscribe: PropTypes.func.isRequired,
    dispatch: PropTypes.func.isRequired,
    getState: PropTypes.func.isRequired
  }),
  context: PropTypes.object,
  children: PropTypes.any
}

export default Provider

</code></pre>
<p>由于内容较多，我们分方法来讲,先来看下构造函数</p>
<pre><code class="language-javascript">  constructor(props) {
    super(props)
    const { store } = props
    this.notifySubscribers = this.notifySubscribers.bind(this)
    const subscription = new Subscription(store)
    subscription.onStateChange = this.notifySubscribers
    this.state = {
      store,
      subscription
    }

    this.previousState = store.getState()
  }
</code></pre>
<ul>
<li>
<p>通过<code>props</code>拿到了我们传给<code>Provider</code>的<code>store</code></p>
</li>
<li>
<p>给<code>notifySubscribers</code>绑定<code>this</code></p>
<pre><code class="language-javascript">  notifySubscribers() {
    this.state.subscription.notifyNestedSubs()
  }
</code></pre>
</li>
<li>
<p>创建<code>Subscription</code>对象，并传入<code>store</code></p>
</li>
<li>
<p>将<code>notifySubscribers</code>函数作为<code>Subscription</code>对象的<code>onStateChange</code>属性</p>
</li>
<li>
<p>把<code>store</code>和<code>subscription</code>放在组件<code>state</code>中</p>
</li>
<li>
<p>获取<code>store</code>中的<code>state</code>,放在<code>previousState</code>对象属性中</p>
</li>
</ul>
<p>以上步骤仅仅是做了一些初始化，并没有调用任何方法，然后看下在组件挂载阶段做了什么</p>
<pre><code class="language-javascript">  componentDidMount() {
    this.state.subscription.trySubscribe()

    if (this.previousState !== this.props.store.getState()) {
      this.state.subscription.notifyNestedSubs()
    }
  }
</code></pre>
<p>调用了<code>subscription</code>对象中的<code>trySubscribe</code>方法，它的实现如下</p>
<pre><code class="language-javascript">export default class Subscription {
  constructor(store, parentSub) {
    this.store = store
    this.parentSub = parentSub
    this.unsubscribe = null
    this.listeners = nullListeners

    this.handleChangeWrapper = this.handleChangeWrapper.bind(this)
  }
  // ...其他  
  trySubscribe() {
    if (!this.unsubscribe) {
      this.unsubscribe = this.parentSub
        ? this.parentSub.addNestedSub(this.handleChangeWrapper)
        // 订阅handleChangeWrapper方法，其实就是notifySubscribers方法，这个方法可以通知调用所有listeners
        : this.store.subscribe(this.handleChangeWrapper)
      // 创建监听函数集合，它返回了一个对象，包含：clear方法，get方法，notify方法，subscribe方法
      this.listeners = createListenerCollection()
    }
  }
    //...其他
}
</code></pre>
<p>这里初始时<code>parentSub</code>并不存在，所以执行<code>this.store.subscribe(this.handleChangeWrapper)</code></p>
<pre><code class="language-javascript">  handleChangeWrapper() {
    if (this.onStateChange) {
      this.onStateChange()
    }
  }
</code></pre>
<p><code>handleChangeWrapper</code>方法实际上又调用了,<code>Provider</code>中的<code>notifySubscribers</code>方法</p>
<pre><code class="language-javascript">  notifySubscribers() {
    this.state.subscription.notifyNestedSubs()
  }
</code></pre>
<p>所以等价于</p>
<pre><code class="language-javascript">this.store.subscribe(function notifySubscribers() {
    // 通知调用所有listener
    this.state.subscription.notifyNestedSubs()
})
</code></pre>
<p>继续看后面的代码</p>
<pre><code class="language-javascript">this.listeners = createListenerCollection()
</code></pre>
<p>创建了一个<code>listener</code>集合，这个函数很关键</p>
<h4 id="createlistenercollection">createListenerCollection</h4>
<pre><code class="language-javascript">function createListenerCollection() {
  const batch = getBatch()
  // the current/next pattern is copied from redux's createStore code.
  // TODO: refactor+expose that code to be reusable here?
  let current = []
  let next = []

  return {
    clear() {
      next = CLEARED
      current = CLEARED
    },

    notify() {
      const listeners = (current = next)
      // 批量调用监听函数listeners
      batch(() =&gt; {
        for (let i = 0; i &lt; listeners.length; i++) {
          listeners[i]()
        }
      })
    },

    get() {
      return next
    },

    subscribe(listener) {
      let isSubscribed = true
      if (next === current) next = current.slice()
      next.push(listener)
      return function unsubscribe() {
        if (!isSubscribed || current === CLEARED) return
        isSubscribed = false

        if (next === current) next = current.slice()
        next.splice(next.indexOf(listener), 1)
      }
    }
  }
}
</code></pre>
<p>首先获取到了<code>batch</code>,这个<code>batch</code>是什么，大家应该还记得，用于批量<code>setState</code>，并且只渲染一次，别的不看，我们先看<code>notify</code></p>
<h5 id="1notify">1.notify</h5>
<pre><code class="language-javascript">    notify() {
      const listeners = (current = next)
      // 批量调用监听函数listeners
      batch(() =&gt; {
        for (let i = 0; i &lt; listeners.length; i++) {
          listeners[i]()
        }
      })
    },
</code></pre>
<p>大家应该能注意到使用<code>batch</code>,包裹的回调函数，里面循环调用了<code>listener</code>，没错最关键的就是这里了，如果多次调用<code>setState</code>,每次都要重新渲染，太过于耗费性能，使用<code>batch</code>就是必须的了</p>
<p>然后我们来看下，<code>subscribe</code>方法</p>
<h5 id="2subscribe">2.subscribe</h5>
<pre><code class="language-javascript">    subscribe(listener) {
      let isSubscribed = true
      if (next === current) next = current.slice()
      next.push(listener)
      return function unsubscribe() {
        if (!isSubscribed || current === CLEARED) return
        isSubscribed = false

        if (next === current) next = current.slice()
        next.splice(next.indexOf(listener), 1)
      }
    }
</code></pre>
<p>这个方法我觉得其实没必要解释了。。。和<code>redux</code>中的实现也是非常相似的</p>
<h5 id="3get">3.get</h5>
<pre><code class="language-javascript">    get() {
      return next
    }
</code></pre>
<p>这个方法是用来返回接下来的监听函数数组</p>
<h5 id="4clear">4.clear</h5>
<pre><code class="language-javascript">    clear() {
      next = CLEARED
      current = CLEARED
    }
</code></pre>
<p>清除当前和接下来的监听函数数组</p>
<p>讲完<code>createListenerCollection</code>函数，回到<code>trySubscribe</code>方法</p>
<pre><code class="language-javascript">  trySubscribe() {
    if (!this.unsubscribe) {
      this.unsubscribe = this.parentSub
        ? this.parentSub.addNestedSub(this.handleChangeWrapper)
        // 订阅handleChangeWrapper方法，其实就是notifySubscribers方法，这个方法可以通知调用所有listeners
        : this.store.subscribe(this.handleChangeWrapper)
      // 创建监听函数集合，它返回了一个对象，包含：clear方法，get方法，notify方法，subscribe方法
      this.listeners = createListenerCollection()
    }
  }
</code></pre>
<p>最后这个方法的作用就是：订阅<code>handleChangeWrapper</code>函数，它能够调用所有监听函数；同时创建了<code>ListenerCollection</code>,返回了一个对象，包含<code>notify</code>，<code>subscribe</code>等</p>
<p>再回到<code>Provider</code>组件中</p>
<pre><code class="language-javascript">  componentDidMount() {
    this.state.subscription.trySubscribe()
    if (this.previousState !== this.props.store.getState()) {
      this.state.subscription.notifyNestedSubs()
    }
  }
</code></pre>
<p><code>this.state.subscription.trySubscribe()</code>,刚刚分析过，然后是一个判断</p>
<pre><code class="language-javascript">    if (this.previousState !== this.props.store.getState()) {
      this.state.subscription.notifyNestedSubs()
    }
</code></pre>
<p>如果前后的<code>state</code>有变化就调用<code>notifyNestedSubs</code>,也就是说当我们调用<code>dispatch</code>，更新了<code>state</code>,就会导致状态的更新，状态更新，就需要通知监听函数调用，更新视图，继续看<code>notifyNestedSubs</code>实现</p>
<pre><code class="language-javascript">  notifyNestedSubs() {
    // 调用所有的listener,批量调用setState,但是只渲染一次
    this.listeners.notify()
  }

</code></pre>
<p>这个方法就不用我说了把，调用了监听函数，使用<code>batch</code>更新视图</p>
<p>继续。。。</p>
<pre><code class="language-javascript">  class Provider extends Component {
      componentWillUnmount() {
        if (this.unsubscribe) this.unsubscribe()
        this.state.subscription.tryUnsubscribe()
      }  
  }

</code></pre>
<p>在组件将要卸载阶段，清除所有的监听函数</p>
<pre><code class="language-javascript">  componentDidUpdate(prevProps) {
    if (this.props.store !== prevProps.store) {
      this.state.subscription.tryUnsubscribe()
      const subscription = new Subscription(this.props.store)
      subscription.onStateChange = this.notifySubscribers
      this.setState({ store: this.props.store, subscription })
    }
  }
</code></pre>
<p>在组件更新阶段，也就是我们调用<code>dispatch</code>，更新了<code>store</code>中的状态，然后所有的<code>listeners</code>被<code>notify</code>通知调用，假如前后的<code>store</code>不一样，就会重复之前<code>constructor</code>中一样的初始化操作，其实这个判断一般来说不会执行到</p>
<p>最后就是<code>render</code>函数了</p>
<pre><code class="language-javascript">  render() {
    const Context = this.props.context || ReactReduxContext
    return (
      &lt;Context.Provider value={this.state}&gt;
        {this.props.children}
      &lt;/Context.Provider&gt;
    )
  }
  
  
  
  
// 引入context  
Provider.propTypes = {
  store: PropTypes.shape({
    subscribe: PropTypes.func.isRequired,
    dispatch: PropTypes.func.isRequired,
    getState: PropTypes.func.isRequired
  }),
  context: PropTypes.object,
  children: PropTypes.any
}
</code></pre>
<p><code>Provider</code>最核心的功能就是给后代组件提供<code>store</code>,它利用了React的<code>Context</code>，因为React16引入了<code>createContext</code>，而且还有以前的<code>Context</code>用法，所以<code>Provider</code>会根据情况使用相应的<code>Context</code></p>
<pre><code class="language-javascript">// 优先采用原本的context
const Context = this.props.context || ReactReduxContext

// 新版本的context
export const ReactReduxContext = React.createContext(null)
</code></pre>
<p>关于<code>context</code>的用法不是本文重点，大家可以参考官方文档</p>
<h3 id="connectadvanced">connectAdvanced</h3>
<p>以下摘抄了文档中的介绍，毕竟比自己写的详细很多</p>
<p>它是一个将 React 组件连接到 Redux store 的函数。这个函数是 <code>connect()</code> 的基础，但是对于如何把<code>state</code>, <code>props</code>, 和 <code>dispatch</code> 组合到最后的 props 中，则不那么自以为是。它不对默认值或结果的记录做任何假设，而是将这些责任留给调用者。</p>
<p>它不修改传递给它的组件类；相反，它<em>返回</em>一个新的、已连接的组件类，供您使用。</p>
<h4 id="参数">参数</h4>
<ul>
<li><code>selectorFactory(dispatch, factoryOptions): selector(state, ownProps): props</code> (<em>Function</em>):初始化选择器函数 (在每个实例的构造函数中)。该选择器函数是在 connector 组件需要重新计算一个新的 props 时调用，作为 store 的 state 改变或者接收到一个新的 props 的结果。<code>selector</code> 的结果应该是一个普通对象，作为被包裹的组件的 props 传递。如果连续调用 <code>selector</code> 都返回与上一次调用相同的对象(<code>===</code>)，则不会重新渲染该组件。<code>selector</code> 的责任是在适当的时候返回以前的对象。</li>
<li>[<code>connectOptions</code>] <em>(Object)</em> 如果指定，则进一步自定义连接器(connector)的行为。
<ul>
<li>[<code>getDisplayName</code>] <em>(Function)</em>: 计算连接器组件相对于被包裹的组件的 DisplayName 属性。 通常被包裹函数覆盖。 默认值: <code>name =&gt; 'ConnectAdvanced('+name+')'</code></li>
<li>[<code>methodName</code>] <em>(String)</em>:显示在错误消息中。 通常被包裹函数覆盖。 默认值: <code>'connectAdvanced'</code></li>
<li>[<code>renderCountProp</code>] <em>(String)</em>: 如果被定义, 名为此值的属性将添加到传递给被包裹组件的 props 中。它的值将是组件被渲染的次数，这对于跟踪不必要的重新渲染非常有用。默认值: <code>undefined</code></li>
<li>[<code>shouldHandleStateChanges</code>] <em>(Boolean)</em>: 控制连接器（connector）组件是否订阅 redux store 的 state 更改。 如果设置为 false，则只会在<code>componentWillReceiveProps</code>中重新渲染。 默认值: <code>true</code></li>
<li>[<code>storeKey</code>] <em>(String)</em>: 可以获取 store 的 props/context key。 当你不明智地使用了多个 store 的时候，你才可能需要这个。默认值: <code>'store'</code></li>
<li>[<code>withRef</code>] <em>(Boolean)</em>: 如果为 true，则将一个引用存储到被包裹的组件实例中，并通过 <code>getWrappedInstance()</code> 方法使其可用。 默认值: <code>false</code></li>
<li>此外，通过 <code>connectOptions</code> 传递的任何额外选项都将传递给 <code>factorOptions</code> 参数中的 <code>selectorFactory</code>。</li>
</ul>
</li>
</ul>
<h4 id="返回值">返回值</h4>
<p>一个高阶 React 组件类，它从 store 的 state 生成 props 并将它们传递给被包裹的组件。高阶组件是接受组件参数并返回新组件的函数.</p>
<h5 id="静态属性">静态属性</h5>
<ul>
<li><code>WrappedComponent</code> <em>(Component)</em>: 原始组件类传递给 <code>connectAdvanced(...)(Component)</code>.</li>
</ul>
<h5 id="静态函数">静态函数</h5>
<ul>
<li>组件的所有原始静态方法都被挂起。</li>
</ul>
<h5 id="实例方法">实例方法</h5>
<ul>
<li><code>getWrappedInstance(): ReactComponent</code></li>
</ul>
<p>返回被包裹组件的实例。只有当你传递 <code>{ withRef: true }</code> 作为<code>options</code> 的参数才可用。</p>
<h4 id="注意">注意</h4>
<ul>
<li>因为 <code>connectAdvanced</code> 返回一个高阶组件，所以需要调用它两次。 第一次使用上面描述的参数，第二次使用组件： <code>connectAdvanced(selectorFactory)(MyComponent)</code>.</li>
<li><code>connectAdvanced</code> 不修改传递的 React 组件。它返回一个新的连接组件，您应该使用它。</li>
</ul>
<p>例子：</p>
<pre><code class="language-javascript">import * as actionCreators from './actionCreators'
import { bindActionCreators } from 'redux'

function selectorFactory(dispatch) {
  let ownProps = {}
  let result = {}
  const actions = bindActionCreators(actionCreators, dispatch)
  const addTodo = text =&gt; actions.addTodo(ownProps.userId, text)
  return (nextState, nextOwnProps) =&gt; {
    const todos = nextState.todos[nextOwnProps.userId]
    const nextResult = { ...nextOwnProps, todos, addTodo }
    ownProps = nextOwnProps
    if (!shallowEqual(result, nextResult)) result = nextResult
    return result
  }
}
export default connectAdvanced(selectorFactory)(TodoApp)
</code></pre>
<p><code>selectorFactory</code>作用其实很简单，通俗来讲就是，把<code>自己在store中选择的一些state或dispatch</code>， <code>ownProps</code>进行合并，传入到组件中，并且自己也可以进行判断前后的变化，进而确定是否要更新组件</p>
<p>看完上面这些介绍，我们直接开始讲源码，由于内容太多，就先只截取一部分</p>
<pre><code class="language-javascript">export default function connectAdvanced(
  selectorFactory,
  {
    getDisplayName = name =&gt; `ConnectAdvanced(${name})`,
    methodName = 'connectAdvanced',
    renderCountProp = undefined,
    shouldHandleStateChanges = true,
    storeKey = 'store',
    withRef = false,  // 如果为 true，则将一个引用存储到被包裹的组件实例中，并通过 getWrappedInstance() 方法使其可用。 默认值: false
    forwardRef = false,
    context = ReactReduxContext,
    ...connectOptions
  } = {}
) {
    // 。。。
  return function wrapWithConnect(WrappedComponent) {
      // 。。。
      return hoistStatics(Connect, WrappedComponent)
  }
  // 。。。。
  
}
</code></pre>
<p>整个函数最终返回了一个高阶组件，也就是被处理过的组件，我们在<code>selectorFactory</code>调用返回的对象，也会作为<code>props</code>传给原本的组件，下面跟着源码一段段分析</p>
<pre><code class="language-javascript">  invariant(
    renderCountProp === undefined,
    `renderCountProp is removed. render counting is built into the latest React Dev Tools profiling extension`
  )

  invariant(
    !withRef,
    'withRef is removed. To access the wrapped instance, use a ref on the connected component'
  )

  const customStoreWarningMessage =
    'To use a custom Redux store for specific components, create a custom React context with ' +
    &quot;React.createContext(), and pass the context object to React Redux's Provider and specific components&quot; +
    ' like: &lt;Provider context={MyContext}&gt;&lt;ConnectedComponent context={MyContext} /&gt;&lt;/Provider&gt;. ' +
    'You may also pass a {context : MyContext} option to connect'

  invariant(
    storeKey === 'store',
    'storeKey has been removed and does not do anything. ' +
      customStoreWarningMessage
  )
  const Context = context
</code></pre>
<ul>
<li>
<p>第一个<code>invariant</code>:</p>
<p>判断<code>renderCountProp</code>是否是<code>undefined</code>,如果是，就报出警告，这个属性基本上用不到，而且上面写了<code>renderCountProp已删除。渲染计数内置于最新的React Dev工具分析扩展中</code></p>
</li>
<li>
<p>第二个<code>invariant</code></p>
<p>判断<code>withRef</code>是否存在，如果存在也会报出警告，<code>withRef被删除。要访问包装的实例，请在连接的组件上使用引用</code></p>
</li>
<li>
<p>第三个<code>invariant</code></p>
<p>判断<code>storeKey</code>是否为<code>store</code>,如果是，就报出警告<code>StoreKey已被删除，不执行任何操作。</code></p>
</li>
</ul>
<p>然后又创建了一个<code>context</code>,这个其实是在参数上设置了一个默认函数</p>
<pre><code class="language-javascript">const Context = context

// Context.js
export const ReactReduxContext = React.createContext(null)

</code></pre>
<p>接下来具体分析返回的高阶函数</p>
<pre><code class="language-javascript">  return function wrapWithConnect(WrappedComponent) {
      // 。。。
    return hoistStatics(Connect, WrappedComponent)
  }
</code></pre>
<h4 id="wrapwithconnect">wrapWithConnect</h4>
<p>又是一大段代码，太长了。。。。，还是一点点分析</p>
<pre><code class="language-javascript">    if (process.env.NODE_ENV !== 'production') {
      invariant(
        isValidElementType(WrappedComponent),
        `You must pass a component to the function returned by ` +
          `${methodName}. Instead received ${stringifyComponent(
            WrappedComponent
          )}`
      )
    }
// typescript类型保护
export function isValidElementType(value: any): value is ReactType;
</code></pre>
<p>这段代码简单来说就是判断组件是否是合法的组件类型,否则警告，这里就不深入介绍了</p>
<pre><code class="language-javascript">    const wrappedComponentName =
      WrappedComponent.displayName || WrappedComponent.name || 'Component'

    const displayName = getDisplayName(wrappedComponentName)
    // getDisplayName = name =&gt; `ConnectAdvanced(${name})`,
    const selectorFactoryOptions = {
      ...connectOptions,
      getDisplayName, // 计算连接器组件相对于被包裹的组件的 DisplayName 属性。 通常被包裹函数覆盖。 默认值: name =&gt; 'ConnectAdvanced('+name+')'
      methodName,  // 示在错误消息中。 通常被包裹函数覆盖。 默认值: 'connectAdvanced'
      renderCountProp,// 如果被定义, 名为此值的属性将添加到传递给被包裹组件的 props 中。它的值将是组件被渲染的次数，这对于跟踪不必要的重新渲染非常有用。默认值: undefined
      shouldHandleStateChanges, // 控制连接器（connector）组件是否订阅 redux store 的 state 更改。 如果设置为 false，则只会在componentWillReceiveProps中重新渲染。 默认值: true
      storeKey,// 可以获取 store 的 props/context key。 当你不明智地使用了多个 store 的时候，你才可能需要这个
      displayName,
      wrappedComponentName,
      WrappedComponent
    }
    // connect中pure为true
    const { pure } = connectOptions

</code></pre>
<ul>
<li>
<p><strong>wrappedComponentName</strong>: 组件名称</p>
</li>
<li>
<p><strong>displayName</strong>： 拼接ConnectAdvanced后的组件名</p>
</li>
<li>
<p><strong>selectorFactoryOptions</strong>: 选项合并，其中有处理过后的组件名</p>
</li>
<li>
<p><strong>pure</strong>： 是否使用<code>pure</code>组件，可以对数据进行浅比较</p>
</li>
</ul>
<p>继续来看</p>
<pre><code class="language-javascript">    function createChildSelector(store) {
      return selectorFactory(store.dispatch, selectorFactoryOptions)
    }
	const usePureOnlyMemo = pure ? useMemo : callback =&gt; callback()
    
    function ConnectFunction(props) {
        //...
    }
    const Connect = pure ? React.memo(ConnectFunction) : ConnectFunction
</code></pre>
<p>首先创建了一个<code>createChildSelector</code>内部函数，调用了<code>selectorFactory</code>,传入了<code>dispatch</code>方法和刚才的<code>selectorFactoryOptions</code>对象，注意此时的<code>selectorFactoryOptions</code>还不是最新的</p>
<p>然后判断<code>pure</code>是否为<code>true</code>，如果是就使用<code>useMemo</code>函数，这个函数是<code>React Hooks</code>中的一个方法，这个函数这里简单介绍一下</p>
<pre><code class="language-javascript">const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);
</code></pre>
<p><code>把“创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算。</code></p>
<p>这句话什么意思呢，其实就是,如果<code>a</code>或者<code>b</code>发生改变，才会调用回调函数中的<code>computeExpensiveValue</code>,并返回了新的<code>computeExpensiveValue</code>返回值，这是一种优化的手段，简单介绍完<code>useMemo</code>，我们继续来讲</p>
<p>又是一个<code>ConnectFunction</code>内部函数，这个暂时先不讲，内容太多</p>
<pre><code class="language-javascript">const Connect = pure ? React.memo(ConnectFunction) : ConnectFunction
</code></pre>
<p>然后判断<code>pure</code>是否为真，如果是就用<code>React.memo</code>创建一个<code>pure</code>函数式组件，这是<code>React 16</code>中的一个新API，<code>React.memo()</code> 和 <code>PureComponent</code> 很相似，它帮助我们控制何时重新渲染组件。</p>
<p>简单点来讲就是</p>
<ul>
<li>React.memo()用于<strong>函数式组件</strong></li>
<li>PureComponent用于<strong>class组件</strong></li>
</ul>
<p>至于用法，请大家参考官方文档，不是本文重点</p>
<pre><code class="language-javascript">Connect.WrappedComponent = WrappedComponent
Connect.displayName = displayName
</code></pre>
<p>然后就是在函数上添加了两个属性</p>
<pre><code class="language-javascript">    if (forwardRef) {
      const forwarded = React.forwardRef(function forwardConnectRef(
        props,
        ref
      ) {
        return &lt;Connect {...props} forwardedRef={ref} /&gt;
      })

      forwarded.displayName = displayName
      forwarded.WrappedComponent = WrappedComponent
      return hoistStatics(forwarded, WrappedComponent)
    }
</code></pre>
<p>这段代码，判断<code>forwardRef</code>是否存在，这个属性也是在参数的配置对象中传入的，初始为<code>false</code>, 它在源码注释中的介绍是这样的<code>使用react的forwardRef公开包装组件的引用</code></p>
<pre><code class="language-javascript">      const forwarded = React.forwardRef(function forwardConnectRef(
        props,
        ref
      ) {
        return &lt;Connect {...props} forwardedRef={ref} /&gt;
      })

      forwarded.displayName = displayName
      forwarded.WrappedComponent = WrappedComponent
      return hoistStatics(forwarded, WrappedComponent)
</code></pre>
<p>这段代码比较关键的是<code>React.forwardRef</code>，这也是<code>React 16</code>中的一个api,用过的同志们可能会比较熟悉，它可以用将<code>ref</code>转发到子组件中，在这里其实是把<code>ref</code>再次传递到了<code>Connect</code>组件中，注意<code>Connect</code>函数组件其实是<code>ConnectFunction</code>函数，接下来这个函数就是重点了</p>
<h4 id="connectfunction">ConnectFunction</h4>
<p>在讲这个函数组件之前，就默认为大家会<code>React Hooks</code>了，因为里面大量的使用到了<code>React Hooks</code>中的一些<code>API</code>,另外，由于代码太多，我将会以注释的形式讲解，有重要的会在后面单独说</p>
<p>还有一件事：真的很长 。。。而且比较绕，我也是看了很久</p>
<p>这段代码太长，大家如果不太好理解，参考后面总结的代码</p>
<pre><code class="language-javascript">    function ConnectFunction(props) {
      // 当props中有值改变，才会调用回调函数
      const [propsContext, forwardedRef, wrapperProps] = useMemo(() =&gt; {
        const { forwardedRef, ...wrapperProps } = props
        // 返回context, forwardedRef,wrapperProps
        return [props.context, forwardedRef, wrapperProps]
      }, [props])


      // 当propsContext和Context有属性值发生变化，就会调用这里面的回调函数
      const ContextToUse = useMemo(() =&gt; {
        // 这里使用来判断是否是原始的context还是createContext创建的context,经过处理后，返回对应的context
        return propsContext &amp;&amp;
          propsContext.Consumer &amp;&amp;
          isContextConsumer(&lt;propsContext.Consumer /&gt;)
          ? propsContext
          : Context
      }, [propsContext, Context])

      // 使用useContext获取context中的值
      const contextValue = useContext(ContextToUse)

      // 判断是否是来自props中的store
      const didStoreComeFromProps = Boolean(props.store)
      // 判断是否是来自context中的store
      const didStoreComeFromContext =
        Boolean(contextValue) &amp;&amp; Boolean(contextValue.store)

      invariant(
        didStoreComeFromProps || didStoreComeFromContext,
        `Could not find &quot;store&quot; in the context of ` +
          `&quot;${displayName}&quot;. Either wrap the root component in a &lt;Provider&gt;, ` +
          `or pass a custom React context provider to &lt;Provider&gt; and the corresponding ` +
          `React context consumer to ${displayName} in connect options.`
      )
      
      // 优先使用props中的store
      const store = props.store || contextValue.store

      // 如果store中的属性值发生了变化，才会调用回调，其中调用了selectorFactory
      // selectorFactory是用来对props和context中的数据进行筛选和处理
      // 这个非常重要，因为它返回的值讲作为props传给组件
      const childPropsSelector = useMemo(() =&gt; {
        return createChildSelector(store)
      }, [store])


      const [subscription, notifyNestedSubs] = useMemo(() =&gt; {
        // shouldHandleStateChanges：是否处理state更改，默认为true,所以正常不会返回NO_SUBSCRIPTION_ARRAY
        if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY

        // 创建Subscription对象，
        const subscription = new Subscription(
          store,
          // 如果store是来自props中的store，就传入context中的subscription对象
          didStoreComeFromProps ? null : contextValue.subscription
        )

        // notifyNestedSubs：用来调用所有的listeners
        // 当调用这个函数的时候，实际上调用的是contextValue.subscription中的listeners
        const notifyNestedSubs = subscription.notifyNestedSubs.bind(
          subscription
        )

        // 返回subscription对象和notifyNestedSubs通知函数
        return [subscription, notifyNestedSubs]
      }, [store, didStoreComeFromProps, contextValue])


      // 按字面意思是用来覆盖ContextValue
      const overriddenContextValue = useMemo(() =&gt; {
        // 如果store是来自props中的，返回contextValue
        if (didStoreComeFromProps) {
          return contextValue
        }
        return {
          ...contextValue,
          subscription
        }
      }, [didStoreComeFromProps, contextValue, subscription])


      // userReducer:这里它的用法不做介绍，参见官网用法：https://zh-hans.reactjs.org/docs/hooks-reference.html#usereducer
      // storeStateUpdatesReducer： 是react-redux内置reducer,用来记录更新次数
      // EMPTY_ARRAY： 初始state
      // initStateUpdates: 惰性初始化
      const [
        [previousStateUpdateResult],
        forceComponentUpdateDispatch
      ] = useReducer(storeStateUpdatesReducer, EMPTY_ARRAY, initStateUpdates)


      // previousStateUpdateResult正常情况下为null ,因为initStateUpdates返回的数组第一个为null
      if (previousStateUpdateResult &amp;&amp; previousStateUpdateResult.error) {
        throw previousStateUpdateResult.error
      }

      // useRef用法参见官网：https://zh-hans.reactjs.org/docs/hooks-reference.html#useref
      const lastChildProps = useRef()
      const lastWrapperProps = useRef(wrapperProps)
      const childPropsFromStoreUpdate = useRef()
      const renderIsScheduled = useRef(false)

      // usePureOnlyMemo： pure ? useMemo : callback =&gt; callback()
      const actualChildProps = usePureOnlyMemo(() =&gt; {
        if (
          childPropsFromStoreUpdate.current &amp;&amp;
          wrapperProps === lastWrapperProps.current
        ) {
          return childPropsFromStoreUpdate.current
        }
        // 这里实际上是调用了selectorFactory返回的函数
        return childPropsSelector(store.getState(), wrapperProps)
      }, [store, previousStateUpdateResult, wrapperProps])


      // useEffect官网用法:https://zh-hans.reactjs.org/docs/hooks-reference.html#useeffect
      useIsomorphicLayoutEffect(() =&gt; {
        // 一些赋值操作
        lastWrapperProps.current = wrapperProps
        lastChildProps.current = actualChildProps
        renderIsScheduled.current = false

        if (childPropsFromStoreUpdate.current) {
          childPropsFromStoreUpdate.current = null
          // 通知listeners执行
          notifyNestedSubs()
        }
      })

      useIsomorphicLayoutEffect(() =&gt; {
        if (!shouldHandleStateChanges) return
        let didUnsubscribe = false
        let lastThrownError = null
        const checkForUpdates = () =&gt; {
          if (didUnsubscribe) {
            return
          }

          const latestStoreState = store.getState()

          let newChildProps, error
          try {
            // 传入最新的store和props
            newChildProps = childPropsSelector(
              latestStoreState,
              lastWrapperProps.current
            )
          } catch (e) {
            error = e
            lastThrownError = e
          }

          if (!error) {
            lastThrownError = null
          }
          // 如果前后的proos相同
          if (newChildProps === lastChildProps.current) {
            // renderIsScheduled.current为true，才会触发notifyNestedSubs
            if (!renderIsScheduled.current) {
              notifyNestedSubs()
            }
          } else {
            lastChildProps.current = newChildProps
            childPropsFromStoreUpdate.current = newChildProps
            renderIsScheduled.current = true
            // 强制组件更新的dispatch
            forceComponentUpdateDispatch({
              type: 'STORE_UPDATED',
              payload: {
                latestStoreState,
                error
              }
            })
          }
        }

        // 重新设置listener订阅函数
        subscription.onStateChange = checkForUpdates
        // 重新订阅
        subscription.trySubscribe()

        checkForUpdates()

        const unsubscribeWrapper = () =&gt; {
          didUnsubscribe = true
          subscription.tryUnsubscribe()
          if (lastThrownError) {
            throw lastThrownError
          }
        }

        // 返回清除函数，这个用法在官方文档中也有示例
        return unsubscribeWrapper
      }, [store, subscription, childPropsSelector])

      // 这里是关键，真正要渲染的组件，传入了处理后的props
      const renderedWrappedComponent = useMemo(
        () =&gt; &lt;WrappedComponent {...actualChildProps} ref={forwardedRef} /&gt;,
        [forwardedRef, WrappedComponent, actualChildProps]
      )

      // 这段代码就不多说了吧，如果了解createContext
      const renderedChild = useMemo(() =&gt; {
        if (shouldHandleStateChanges) {
          return (
            &lt;ContextToUse.Provider value={overriddenContextValue}&gt;
              {renderedWrappedComponent}
            &lt;/ContextToUse.Provider&gt;
          )
        }

        return renderedWrappedComponent
      }, [ContextToUse, renderedWrappedComponent, overriddenContextValue])

      // 返回组件
      return renderedChild
    }
</code></pre>
<p>接下来我将代码缩减，来整体说明<code>connectAdvanced</code>做了哪些事</p>
<pre><code class="language-javascript">function connectAdvanced(...args) {
    return function wrapWithConnect(WrappedComponent) {
        // 组件名
        const displayName = ComponentName
        // 一些配置
        const selectorFactoryOptions = {
            ...arg,
            ...options
        }
        // 判断是否应该使用pure组件
        const usePureOnlyMemo = pure ? useMemo : callback =&gt; callback()
        
        function ConnectFunction(props) {
          // props变化，获取最新的context,forwardedRef以及组件其他props
          const [propsContext, forwardedRef, wrapperProps] = useMemo(() =&gt; {...}, [props])
          
          // propsContext或Context发生变化，如果propsContext存在则优先使用
          const ContextToUse = useMemo(() =&gt; {...}, [propsContext, Context])}
                                       
          // 获取context中的值，也就是store
          const contextValue = useContext(ContextToUse)
          
          // 判断是否是来自props中的store
      	  const didStoreComeFromProps = Boolean(props.store)
          
          // 判断是否是来自context中的store
          const didStoreComeFromContext = Boolean(contextValue) &amp;&amp; Boolean(contextValue.store)
          
          // 优先使用props中的store
      	  const store = props.store || contextValue.store
          
          // 创建Selector
          const childPropsSelector = useMemo(() =&gt; {
              ...
        	  return createChildSelector(store)
          }, [store])
          
          // 创建subscription对象和notifyNestedSubs函数
          const [subscription, notifyNestedSubs] = useMemo(() =&gt; {
              ...
        	  return [subscription, notifyNestedSubs]
      	  }, [store, didStoreComeFromProps, contextValue])
          
          // 覆盖ContextValue，其实就是覆盖store
          const overriddenContextValue = useMemo(() =&gt; {
              ...
              return {
                  ...contextValue,
                  subscription
              }
      	  }, [didStoreComeFromProps, contextValue, subscription])
          
          // react-redux内置reducer,用来记录更新次数
          const [
            [previousStateUpdateResult],
            forceComponentUpdateDispatch
          ] = useReducer(storeStateUpdatesReducer, EMPTY_ARRAY, initStateUpdates)
          
          // 调用selector并传入返回函数最新的state以及组件props(不包含context)
          // 返回的actualChildProps，将用来传给要被包装的组件
          const actualChildProps = usePureOnlyMemo(() =&gt; {
			 ...
              return childPropsSelector(store.getState(), wrapperProps)
          }, [store, previousStateUpdateResult, wrapperProps])    
          
          // 一些属性的初始化
          useIsomorphicLayoutEffect(() =&gt; {
         	
      	  })
                                                                            
          useIsomorphicLayoutEffect(() =&gt; {
            // 调用内置reducer,记录更新次数，强制组件更新，因为subscription订阅了该函数，所以能触发组件更新
              const checkForUpdates = () =&gt; {}
                 // 检查state是否更新的listener
                subscription.onStateChange = checkForUpdates
                 // 调用listeners
                 subscription.trySubscribe()
                 // 先调用一次进行初始化
                 checkForUpdates()
              })         
              // 清除订阅                                                                  
             const unsubscribeWrapper = () =&gt; { ... }      
          })
          
          // 最终的被包装组件，传入了最新的props
          const renderedWrappedComponent = useMemo(
            () =&gt; &lt;WrappedComponent {...actualChildProps} ref={forwardedRef} /&gt;,
            [forwardedRef, WrappedComponent, actualChildProps]
          )
          
          const renderedChild = useMemo(() =&gt; {
            if (shouldHandleStateChanges) {
              return (
                &lt;ContextToUse.Provider value={overriddenContextValue}&gt;
                  {renderedWrappedComponent}
                &lt;/ContextToUse.Provider&gt;
              )
            }
            return renderedWrappedComponent
          }, [ContextToUse, renderedWrappedComponent, overriddenContextValue])
          
          // 返回真正的高阶组件
          return renderedChild
	  }	
      
      // 防止Component上面绑定了一些static方法丢失
      return hoistStatics(ConnectFunction, WrappedComponent)
    }
}
</code></pre>
<p>终于讲完了<code>connectAdvanced</code>,其实整体理解起来并不困难，比较难的是大量使用到了<code>React Hooks</code>，通过这一部分的学习，也让我对这些<code>hooks</code>有了更多的认识与理解</p>
<h3 id="connect">connect</h3>
<p>下面来看<code>connect</code>的源码实现</p>
<p>首先截取到<code>connect.js</code>里的关键代码</p>
<pre><code class="language-javascript">export function createConnect({
  connectHOC = connectAdvanced,
  mapStateToPropsFactories = defaultMapStateToPropsFactories,
  mapDispatchToPropsFactories = defaultMapDispatchToPropsFactories,
  mergePropsFactories = defaultMergePropsFactories,
  selectorFactory = defaultSelectorFactory
} = {}) {
  return function connect(
    mapStateToProps,
    mapDispatchToProps,
    mergeProps,
    {
      pure = true,
      areStatesEqual = strictEqual,
      areOwnPropsEqual = shallowEqual,
      areStatePropsEqual = shallowEqual,
      areMergedPropsEqual = shallowEqual,
      ...extraOptions
    } = {}
  ) {


    // 如果定义该参数，组件将会监听 Redux store 的变化。任何时候，只要 Redux store 发生改变，mapStateToProps 函数就会被调用
    // 该回调函数必须返回一个纯对象，这个对象会与组件的 props 合并。如果你省略了这个参数，你的组件将不会监听 Redux store。
    // 如果指定了该回调函数中的第二个参数 ownProps，则该参数的值为传递到组件的 props，
    // 而且只要组件接收到新的 props，mapStateToProps 也会被调用
    // （例如，当 props 接收到来自父组件一个小小的改动，那么你所使用的 ownProps 参数，mapStateToProps 都会被重新计算）。
    const initMapStateToProps = match(
      mapStateToProps,
      mapStateToPropsFactories,
      'mapStateToProps'
    )

    const initMapDispatchToProps = match(
      mapDispatchToProps,
      mapDispatchToPropsFactories,
      'mapDispatchToProps'
    )

    const initMergeProps = match(mergeProps, mergePropsFactories, 'mergeProps')
    return connectHOC(selectorFactory, {
      // used in error messages
      methodName: 'connect',

      // used to compute Connect's displayName from the wrapped component's displayName.
      getDisplayName: name =&gt; `Connect(${name})`,

      // if mapStateToProps is falsy, the Connect component doesn't subscribe to store state changes
      shouldHandleStateChanges: Boolean(mapStateToProps),
      initMapStateToProps,
      initMapDispatchToProps,
      initMergeProps,
      pure,
      areStatesEqual,
      areOwnPropsEqual,
      areStatePropsEqual,
      areMergedPropsEqual,

      // any extra options args can override defaults of connect or connectAdvanced
      ...extraOptions
    })
  }
}

</code></pre>
<p>其他不看，一步一步分析</p>
<h4 id="mapstatetoprops">mapStateToProps</h4>
<pre><code class="language-javascript">    const initMapStateToProps = match(
      mapStateToProps,
      mapStateToPropsFactories,
      'mapStateToProps'
    )
</code></pre>
<ul>
<li>
<p>mapStateToProps: <code>connect</code>传入的</p>
</li>
<li>
<p>mapStateToPropsFactories:</p>
<p>它是一个数组，包含以下两个函数，我们先暂时不讲</p>
<pre><code class="language-javascript">import { wrapMapToPropsConstant, wrapMapToPropsFunc } from './wrapMapToProps'
export function whenMapStateToPropsIsFunction(mapStateToProps) {
  // 判断是否是函数，如果是调用wrapMapToPropsFunc
  return typeof mapStateToProps === 'function'
    ? wrapMapToPropsFunc(mapStateToProps, 'mapStateToProps')
    : undefined
}

export function whenMapStateToPropsIsMissing(mapStateToProps) {
  return !mapStateToProps ? wrapMapToPropsConstant(() =&gt; ({})) : undefined
}

export default [whenMapStateToPropsIsFunction, whenMapStateToPropsIsMissing]

</code></pre>
</li>
</ul>
<p>关键是<code>match</code>方法</p>
<pre><code class="language-javascript">function match(arg, factories, name) {
  for (let i = factories.length - 1; i &gt;= 0; i--) {
    const result = factories[i](arg)
    if (result) return result
  }
  return (dispatch, options) =&gt; {
    throw new Error(
      `Invalid value of type ${typeof arg} for ${name} argument when connecting component ${
        options.wrappedComponentName
      }.`
    )
  }
}
</code></pre>
<p><code>match</code>函数实现就比较简单了，从右到左依次调用<code>[whenMapStateToPropsIsFunction, whenMapStateToPropsIsMissing]</code>, 并传入<code>mapStateToProps</code>函数，拿到调用结果后返回，如果结果不存在就返回一个会抛出错误的函数，这是为了防止传入不合法的<code>mapStateToProps</code></p>
<p>现在我们知道<code>mapStateToProps</code>需要经过两个函数的处理才能拿到真正的<code>mapStateToProps</code>,我们来具体看看其实现</p>
<pre><code class="language-javascript">// mapStateToProps.js
export function whenMapStateToPropsIsFunction(mapStateToProps) {
  // 判断是否是函数，如果是调用wrapMapToPropsFunc
  return typeof mapStateToProps === 'function'
    ? wrapMapToPropsFunc(mapStateToProps, 'mapStateToProps')
    : undefined
}
</code></pre>
<p>首先判断是否是一个函数，如果不是返回<code>undefined</code>，此时大家可以想到，这是不合法的类型，前面讲到的如果类型不合法，会返回一个抛出错误的函数，现在看来，<code>match</code>函数，除了调用工厂函数，还对错误进行了统一处理，它可以处理<code>mapStateToProps</code>和<code>mapDispatchToProps</code></p>
<p>如果是一个函数，调用<code>wrapMapToPropsFunc</code>,并继续把<code>mapStateToProps</code>传递进去，这个<code>wrapMapToPropsFunc</code>其实不单单对<code>mapStateToProps</code>进行了处理，还对<code>mapDispatchToProps</code>做了处理，我只单独讲一种情况</p>
<pre><code class="language-javascript">export function wrapMapToPropsFunc(mapToProps, methodName) {
  // 返回一个新方法
  return function initProxySelector(dispatch, { displayName }) {
    const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
      return proxy.dependsOnOwnProps
        ? proxy.mapToProps(stateOrDispatch, ownProps)
        : proxy.mapToProps(stateOrDispatch)
    }
    proxy.dependsOnOwnProps = true
    proxy.mapToProps = function detectFactoryAndVerify(
      stateOrDispatch,
      ownProps
    ) {
      // 把真实的mapToProps函数赋给代理方法的mapToProps
      proxy.mapToProps = mapToProps
      // 获取OwnProps
      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps)
      let props = proxy(stateOrDispatch, ownProps)
      
      if (typeof props === 'function') {
        proxy.mapToProps = props
        proxy.dependsOnOwnProps = getDependsOnOwnProps(props)
        props = proxy(stateOrDispatch, ownProps)
      }
      if (process.env.NODE_ENV !== 'production')
        verifyPlainObject(props, displayName, methodName)
      return props
    }

    return proxy
  }
}

</code></pre>
<p>整体看下来，其实最终返回了一个代理函数<code>proxy</code>，我们针对它的属性和方法来讲解</p>
<ul>
<li>
<p>proxy函数</p>
<pre><code class="language-javascript">    const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
      return proxy.dependsOnOwnProps
        ? proxy.mapToProps(stateOrDispatch, ownProps)
        : proxy.mapToProps(stateOrDispatch)
    }
</code></pre>
<p>这个其实就是处理过后的<code>mapStateToProps</code>或者<code>mapDispatchToProps</code></p>
<p>如果指定了该函数中的第二个参数 <code>ownProps</code>，则该参数的值为传递到组件的 props，而且只要组件接收到新的 props，<code>mapStateToProps</code> 也会被调用（例如，当 props 接收到来自父组件一个小小的改动，那么你所使用的 ownProps 参数，mapStateToProps 都会被重新计算）。</p>
</li>
<li>
<p>proxy.dependsOnOwnProps</p>
<p>默认为true</p>
</li>
<li>
<p>proxy.mapToProps</p>
<pre><code class="language-javascript">    proxy.mapToProps = function detectFactoryAndVerify(
      stateOrDispatch,
      ownProps
    ) {
      // 把真实的mapToProps函数赋给代理方法的mapToProps
      proxy.mapToProps = mapToProps
      // 获取OwnProps
      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps)
		
      // 调用了mapStateToProps,传入state，以及我们手动传入的props
      let props = proxy(stateOrDispatch, ownProps)
      
      if (typeof props === 'function') {
        proxy.mapToProps = props
        proxy.dependsOnOwnProps = getDependsOnOwnProps(props)
        props = proxy(stateOrDispatch, ownProps)
      }
      if (process.env.NODE_ENV !== 'production')
        verifyPlainObject(props, displayName, methodName)
      return props
    }

</code></pre>
<p>这段函数，调用了其实还是调用了<code>mapStateToProps</code>或者<code>mapDipsatchToProps</code>，拿到返回的<code>state</code>或者<code>dispatch</code>，最终返回，至于其他东西实际上上是对<code>OwnProps</code>做的一些处理</p>
</li>
</ul>
<p>我们会到之前说的那两个函数，已讲其一, <strong>注意：之前忘记说了，<code>whenMapStateToPropsIsMissing</code>函数实际上是先执行的。。</strong></p>
<pre><code class="language-javascript">export function whenMapStateToPropsIsFunction(mapStateToProps) {
  // 判断是否是函数，如果是调用wrapMapToPropsFunc
  return typeof mapStateToProps === 'function'
    ? wrapMapToPropsFunc(mapStateToProps, 'mapStateToProps')
    : undefined
}
export function whenMapStateToPropsIsMissing(mapStateToProps) {
  return !mapStateToProps ? wrapMapToPropsConstant(() =&gt; ({})) : undefined
}

export default [whenMapStateToPropsIsFunction, whenMapStateToPropsIsMissing]
</code></pre>
<pre><code class="language-javascript">export function whenMapStateToPropsIsMissing(mapStateToProps) {
  return !mapStateToProps ? wrapMapToPropsConstant(() =&gt; ({})) : undefined
}
</code></pre>
<p><code>whenMapStateToPropsIsMissing</code>函数实现就非常简单了，它是防止我们没有传入<code>mapStateToProps</code>,就设置了一个默认函数，他没有做任何事情</p>
<p>讲完上面这些，回到<code>connect</code>函数</p>
<pre><code class="language-javascript">
    const initMapDispatchToProps = match(
      mapDispatchToProps,
      mapDispatchToPropsFactories,
      'mapDispatchToProps'
    )
    
   
</code></pre>
<p>需要注意的是,它的第二个参数是<code>mapDispatchToPropsFactories</code></p>
<h4 id="mapdispatchtoprops">mapDispatchToProps</h4>
<pre><code class="language-javascript">import { bindActionCreators } from 'redux'
import { wrapMapToPropsConstant, wrapMapToPropsFunc } from './wrapMapToProps'

export function whenMapDispatchToPropsIsFunction(mapDispatchToProps) {
  return typeof mapDispatchToProps === 'function'
    ? wrapMapToPropsFunc(mapDispatchToProps, 'mapDispatchToProps')
    : undefined
}

export function whenMapDispatchToPropsIsMissing(mapDispatchToProps) {
  return !mapDispatchToProps
    ? wrapMapToPropsConstant(dispatch =&gt; ({ dispatch }))
    : undefined
}

export function whenMapDispatchToPropsIsObject(mapDispatchToProps) {
  return mapDispatchToProps &amp;&amp; typeof mapDispatchToProps === 'object'
    ? wrapMapToPropsConstant(dispatch =&gt;
        bindActionCreators(mapDispatchToProps, dispatch)
      )
    : undefined
}

export default [
  whenMapDispatchToPropsIsFunction,
  whenMapDispatchToPropsIsMissing,
  whenMapDispatchToPropsIsObject
]

</code></pre>
<p>可以看到，<code>mapDispatchToProps</code>,经过了三次处理，其他两个不讲，主要讲一下<code>whenMapDispatchToPropsIsObject</code></p>
<pre><code class="language-javascript">export function whenMapDispatchToPropsIsObject(mapDispatchToProps) {
  return mapDispatchToProps &amp;&amp; typeof mapDispatchToProps === 'object'
    ? wrapMapToPropsConstant(dispatch =&gt;
        bindActionCreators(mapDispatchToProps, dispatch)
      )
    : undefined
}
</code></pre>
<p>在看这段代码之前，我其实是不知道<code>actionCreator</code>可以直接作为<code>mapDispatchToProps</code>的，如果传递的是一个对象，那么每个定义在该对象的函数都将被当作 Redux action creator，对象所定义的方法名将作为属性名，举个例子</p>
<pre><code class="language-javascript">import actionCreators from './actionCreators'
connct(mapStateToProps, actionCreators)(App)
</code></pre>
<p>在来看看<code>wrapMapToPropsConstant</code>函数实现,直接看注释</p>
<pre><code class="language-javascript">export function wrapMapToPropsConstant(getConstant) {
  return function initConstantSelector(dispatch, options) {
    // 调用getConstant，实际上调用了bindActionCreators
    const constant = getConstant(dispatch, options)
    function constantSelector() {
      return constant
    }
    // 没有依赖自己定义的props
    constantSelector.dependsOnOwnProps = false
    // 返回新mapDispatchToProps函数
    return constantSeletor
  }
}
</code></pre>
<p>讲完<code>mapDispatchToProps</code>回到<code>connect</code></p>
<h4 id="mergeprops">mergeProps</h4>
<pre><code class="language-javascript"> const initMergeProps = match(mergeProps, mergePropsFactories, 'mergeProps')
</code></pre>
<p><code>mergeProps</code>是什么鬼，其实在看源码之前，我是不知道这个api的，官网说明是这样的:</p>
<p><strong>[<code>mergeProps(stateProps, dispatchProps, ownProps): props</code>] (<em>Function</em>): 如果指定了这个参数，<code>mapStateToProps()</code> 与 <code>mapDispatchToProps()</code> 的执行结果和组件自身的 <code>props</code> 将传入到这个回调函数中。该回调函数返回的对象将作为 props 传递到被包装的组件中。你也许可以用这个回调函数，根据组件的 props 来筛选部分的 state 数据，或者把 props 中的某个特定变量与 action creator 绑定在一起。如果你省略这个参数，默认情况下返回 <code>Object.assign({}, ownProps, stateProps, dispatchProps)</code> 的结果。</strong></p>
<p>好东西！这个API，其实挺有用的，可以对<code>props</code>中的<code>state, dispatch, ownProps</code>进行筛选，它是一个函数，返回值将作为<code>props</code>传给组件</p>
<p>说完这些有个东西需要注意,<code>mergePropsFactories</code>,第二个参数是<code>mergePropsFactories</code></p>
<pre><code class="language-javascript">export function whenMergePropsIsFunction(mergeProps) {
  return typeof mergeProps === 'function'
    ? wrapMergePropsFunc(mergeProps)
    : undefined
}

export function whenMergePropsIsOmitted(mergeProps) {
  return !mergeProps ? () =&gt; defaultMergeProps : undefined
}

export default [whenMergePropsIsFunction, whenMergePropsIsOmitted]

</code></pre>
<p>其他不看，只看<code>wrapMergePropsFunc</code></p>
<pre><code class="language-javascript">export function wrapMergePropsFunc(mergeProps) {
  return function initMergePropsProxy(
    dispatch,
    { displayName, pure, areMergedPropsEqual }
  ) {
    let hasRunOnce = false
    let mergedProps

    return function mergePropsProxy(stateProps, dispatchProps, ownProps) {
      const nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps)

      if (hasRunOnce) {
        if (!pure || !areMergedPropsEqual(nextMergedProps, mergedProps))
          mergedProps = nextMergedProps
      } else {
        hasRunOnce = true
        mergedProps = nextMergedProps

        if (process.env.NODE_ENV !== 'production')
          verifyPlainObject(mergedProps, displayName, 'mergeProps')
      }

      return mergedProps
    }
  }
}
</code></pre>
<p>其实看过<code>mergeProps</code>用法的同学，猜都能猜到它做了什么，没错，传入三个参数</p>
<pre><code class="language-javascript"> const nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps)
</code></pre>
<p>最终还是返回了这个合并后的<code>props</code>，其他的我就不讲了，也很好理解</p>
<p>再回到<code>conncet</code></p>
<pre><code class="language-javascript">    return connectHOC(selectorFactory, {
      // used in error messages
      methodName: 'connect',

      // used to compute Connect's displayName from the wrapped component's displayName.
      getDisplayName: name =&gt; `Connect(${name})`,

      // if mapStateToProps is falsy, the Connect component doesn't subscribe to store state changes
      shouldHandleStateChanges: Boolean(mapStateToProps),
      initMapStateToProps,
      initMapDispatchToProps,
      initMergeProps,
      pure,
      areStatesEqual,
      areOwnPropsEqual,
      areStatePropsEqual,
      areMergedPropsEqual,

      // any extra options args can override defaults of connect or connectAdvanced
      ...extraOptions
    })
</code></pre>
<p><code>connectHOC</code>其实就是<code>connectAdvanced</code>,这在前面也有讲过，它最终返回了一个高阶组件，而且是<code>pure</code>组件，这里我们主要关注<code>selectorFactory</code></p>
<pre><code class="language-javascript">export default function finalPropsSelectorFactory(
  dispatch,
  { initMapStateToProps, initMapDispatchToProps, initMergeProps, ...options }
) {
  const mapStateToProps = initMapStateToProps(dispatch, options)
  const mapDispatchToProps = initMapDispatchToProps(dispatch, options)
  const mergeProps = initMergeProps(dispatch, options)

  if (process.env.NODE_ENV !== 'production') {
    verifySubselectors(
      mapStateToProps,
      mapDispatchToProps,
      mergeProps,
      options.displayName
    )
  }

  const selectorFactory = options.pure
    ? pureFinalPropsSelectorFactory
    : impureFinalPropsSelectorFactory

  return selectorFactory(
    mapStateToProps,
    mapDispatchToProps,
    mergeProps,
    dispatch,
    options
  )
}
</code></pre>
<p>这段代码其实也挺好理解，前三行调用了被处理过的<code>mapStateToProps</code>,<code>mapDispatchToProps</code>, <code>mergeProps</code>，拿到最新的<code>props</code>，然后是对这些<code>props</code>进行校验</p>
<pre><code class="language-javascript">  const selectorFactory = options.pure
    ? pureFinalPropsSelectorFactory
    : impureFinalPropsSelectorFactory
</code></pre>
<p>然后是这一段，<code>pure</code>在默认情况下为true</p>
<p>一看吓一跳，又是这么长的代码。。。。,</p>
<pre><code class="language-javascript">export function pureFinalPropsSelectorFactory(
  mapStateToProps,
  mapDispatchToProps,
  mergeProps,
  dispatch,
  { areStatesEqual, areOwnPropsEqual, areStatePropsEqual }
) {
  let hasRunAtLeastOnce = false
  let state
  let ownProps
  let stateProps
  let dispatchProps
  let mergedProps

  // ....
  return function pureFinalPropsSelector(nextState, nextOwnProps) {
    return hasRunAtLeastOnce
      ? handleSubsequentCalls(nextState, nextOwnProps)
      : handleFirstCall(nextState, nextOwnProps)
  }
}
</code></pre>
<p>其他我先省略掉，太多，只看返回的函数,从名字就可以知道，它是最终的<code>selector</code>，我们去看下它是在哪被调用的</p>
<pre><code class="language-javascript">// connectAdvanced.js    

const selectorFactoryOptions = {
  ...connectOptions,
  getDisplayName, // 计算连接器组件相对于被包裹的组件的 DisplayName 属性。 通常被包裹函数覆盖。 默认值: name =&gt; 'ConnectAdvanced('+name+')'
  methodName,  // 示在错误消息中。 通常被包裹函数覆盖。 默认值: 'connectAdvanced'
  renderCountProp,// 如果被定义, 名为此值的属性将添加到传递给被包裹组件的 props 中。它的值将是组件被渲染的次数，这对于跟踪不必要的重新渲染非常有用。默认值: undefined
  shouldHandleStateChanges, // 控制连接器（connector）组件是否订阅 redux store 的 state 更改。 如果设置为 false，则只会在componentWillReceiveProps中重新渲染。 默认值: true
  storeKey,// 可以获取 store 的 props/context key。 当你不明智地使用了多个 store 的时候，你才可能需要这个
  displayName,
  wrappedComponentName,
  WrappedComponent
}

...
function createChildSelector(store) {
   return selectorFactory(store.dispatch, selectorFactoryOptions)
}

...
const childPropsSelector = useMemo(() =&gt; {
    return createChildSelector(store)
}, [store])
</code></pre>
<p>如果是第一次调用<code>hasRunAtLeastOnce</code>肯定为false,所以会执行<code>handleFirstCall</code></p>
<pre><code class="language-javascript">  function handleFirstCall(firstState, firstOwnProps) {
    state = firstState  // dispatch
    ownProps = firstOwnProps  // selectorFactoryOptions
    stateProps = mapStateToProps(state, ownProps)
    dispatchProps = mapDispatchToProps(dispatch, ownProps)
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps)
    hasRunAtLeastOnce = true
    return mergedProps 
  }

</code></pre>
<p>看完这些需要注意：<code>hasRunAtLeastOnce = true</code>,也就说它只能被执行依次，下一次将会执行<code>impureFinalPropsSelectorFactory</code></p>
<pre><code class="language-javascript">export function impureFinalPropsSelectorFactory(
  mapStateToProps,
  mapDispatchToProps,
  mergeProps,
  dispatch
) {
  return function impureFinalPropsSelector(state, ownProps) {
    return mergeProps(
      mapStateToProps(state, ownProps),
      mapDispatchToProps(dispatch, ownProps),
      ownProps
    )
  }
}
</code></pre>
<p>这段代码，eemmmm,各位大佬还需要我说吗。。</p>
<p>所以整个<code>finalPropsSelectorFactory</code>函数做的事情就是，判断是否是第一次执行来返回对应的<code>selector</code></p>
<p>至此<code>connect</code>也讲完了，还有那些api还没讲呢</p>
<pre><code class="language-javascript">  useDispatch,
  useSelector,
  useStore,
  shallowEqual
</code></pre>
<p>还有这些，看源码的道路真的很漫长，。</p>
<h3 id="usestore">useStore</h3>
<p>可以拿到<code>context</code>中的<code>store</code></p>
<pre><code class="language-javascript">export function useStore() {
  const { store } = useReduxContext()
  return store
}

export function useReduxContext() {
  const contextValue = useContext(ReactReduxContext)
  invariant(
    contextValue,
    'could not find react-redux context value; please ensure the component is wrapped in a &lt;Provider&gt;'
  )
  return contextValue
}
</code></pre>
<p>它的实现也很简单，利用了<code>useContext</code>这个React Hooks</p>
<h3 id="usedispatch">useDispatch</h3>
<p>拿到<code>store</code>中的<code>dispatch</code>函数</p>
<pre><code class="language-javascript">export function useDispatch() {
  const store = useStore()
  return store.dispatch
}
</code></pre>
<p>本质上调用了<code>useStore</code>,返回<code>store.dispatch</code></p>
<h3 id="useselector">useSelector</h3>
<p>能自定义<code>selector</code>，筛选数据</p>
<pre><code class="language-javascript">export function useSelector(selector, equalityFn = refEquality) {
  invariant(selector, `You must pass a selector to useSelectors`)

  // 
  const { store, subscription: contextSub } = useReduxContext()
 
  const [, forceRender] = useReducer(s =&gt; s + 1, 0)

  // 如果store发生变化，Subscription对象
  const subscription = useMemo(() =&gt; new Subscription(store, contextSub), [
    store,
    contextSub
  ])

  const latestSubscriptionCallbackError = useRef()
  // 最新的selector
  const latestSelector = useRef()
  // 最新的selector返回的state
  const latestSelectedState = useRef()

  let selectedState

  try {
    if (
      selector !== latestSelector.current ||
      latestSubscriptionCallbackError.current
    ) {
      // 第一次调用selector,传入最新的state
      selectedState = selector(store.getState())
    } else {
      selectedState = latestSelectedState.current
    }
  } catch (err) {
    let errorMessage = `An error occured while selecting the store state: ${err.message}.`

    if (latestSubscriptionCallbackError.current) {
      errorMessage += `\nThe error may be correlated with this previous error:\n${latestSubscriptionCallbackError.current.stack}\n\nOriginal stack trace:`
    }

    throw new Error(errorMessage)
  }

    // 使用useIsomorphicLayoutEffect能够执行一些副作用操作
  useIsomorphicLayoutEffect(() =&gt; {
    latestSelector.current = selector
    latestSelectedState.current = selectedState
    latestSubscriptionCallbackError.current = undefined
  })

  useIsomorphicLayoutEffect(() =&gt; {
    function checkForUpdates() {
      try {
        // 调用selector
        const newSelectedState = latestSelector.current(store.getState())
        if (equalityFn(newSelectedState, latestSelectedState.current)) {
          return
        }

         // 设置最新的state
        latestSelectedState.current = newSelectedState
      } catch (err) {
        latestSubscriptionCallbackError.current = err
      }

      // 强制组件渲染
      forceRender({})
    }

    // 重新设置通知函数
    subscription.onStateChange = checkForUpdates
    // 订阅checkForUpdates函数
    subscription.trySubscribe()
    checkForUpdates()
    return () =&gt; subscription.tryUnsubscribe()
  }, [store, subscription])
  return selectedState
}

</code></pre>
<p>整个函数所作的事</p>
<ol>
<li>设置最新的<code>selector</code>和它返回的最新<code>state</code>，下次调用如果没有发生变化，就使用之前的<code>state</code></li>
<li>在组件渲染以后，重新订阅<code>checkForUpdates函数</code>, 当调用<code>dispatch</code>,更新<code>state</code>,会触发<code>checkForUpdates</code>,执行<code>selector</code>,传入最新的<code>state</code></li>
</ol>
<h2 id="总结">总结</h2>
<p>整篇文章总体来说，写的不太好，因为<code>react-redux</code>相对<code>redux</code>更难一些，也比较绕，不太好写，有很多东西可能没有讲到，在以后我会继续补充这篇文章，有问题欢迎指正，谢谢</p>
<h2 id="下一章">下一章</h2>
<p>逐行级源码分析系列(三) Vue-Router源码</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[逐行级源码分析系列(一) Vuex]]></title>
        <id>https://1131153523.github.io/post/zhu-xing-ji-yuan-ma-fen-xi-xi-lie-yi-vuex</id>
        <link href="https://1131153523.github.io/post/zhu-xing-ji-yuan-ma-fen-xi-xi-lie-yi-vuex">
        </link>
        <updated>2019-08-09T15:08:13.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>首先这篇文章也是本人第一次发这种技术文章，错别字，分析错误，不知道的东西在所难免，希望大家指正，目前本人还是一位即将大四的学生，写这个系列的目的也是为了记录在源码中学习，通过写博客让我更加熟悉了源码及其内部完完整整的实现，通过这篇文章也让我对vuex的源码变得非常熟悉，在写这完篇文章之前，因为时间原因，断断续续写了两个星期，虽然已经看完了，但是要全部分析完并写出来，太耗费精力和时间。然后这个系列我打算按照这个顺序来写，我会尽量写完，也并非大放厥词，以下本人都已看完源码，排版可能有点差，我会慢慢学习，如果里面有错误，大佬轻喷。。</p>
<ul>
<li>逐行级源码分析系列(一) Vuex 源码</li>
<li>逐行级源码分析系列(二) Redux和React-Redux源码</li>
<li>逐行级源码分析系列(三) Vue-Router源码</li>
<li>逐行级源码分析系列(四) React-Router-Dom源码</li>
<li>逐行级源码分析系列(五) Express源码</li>
<li>逐行级源码分析系列(六) Koa核心源码</li>
<li>逐行级源码分析系列(六) Typescript版Axios源码</li>
</ul>
<h2 id="install">install</h2>
<p>当我们使用<code>Vue.use</code>会调用vuex的<code>install</code>方法，它的实现如下</p>
<pre><code class="language-javascript">export function install (_Vue) {
  if (Vue &amp;&amp; _Vue === Vue) {
    if (process.env.NODE_ENV !== 'production') {
      console.error(
        '[vuex] already installed. Vue.use(Vuex) should be called only once.'
      )
    }
    return
  }
  Vue = _Vue
  applyMixin(Vue)
}

</code></pre>
<p>这个方法传入了Vue构造函数,然后判断如果<code>_Vue === Vue</code>，则说明已经安装过了就直接返回，不做处理。然后调用了<code>applyMixin(Vue)</code>方法，我们来看下<code>applyMixin</code>方法实现</p>
<h2 id="applymixin">applyMixin</h2>
<pre><code class="language-javascript">
export default function (Vue) {
  const version = Number(Vue.version.split('.')[0])
  if (version &gt;= 2) {
    // 混入beforeCreate，vuexInit方法
    Vue.mixin({ beforeCreate: vuexInit })
  } else {
    const _init = Vue.prototype._init
    // 重写_init方法，把vuexInit方法，挂载到options中
    Vue.prototype._init = function (options = {}) {
      // 这里做了兼容处理，如果有其他库也使用了init方法，就把vuexInit添加到Init数组中
      options.init = options.init
        ? [vuexInit].concat(options.init)
        : vuexInit
      _init.call(this, options)
    }
  }

  /**
   * Vuex init hook, injected into each instances init hooks list.
   */

   // 这个方法的作用就是可以让每个组件都能通过this.$store放问到store对象
  function vuexInit () {
    // 获取mergeoptios选线
    const options = this.$options
    // 如果存在store属性
    if (options.store) {
      // 如果store是一个方法，就调用store，否则直接使用
      this.$store = typeof options.store === 'function'
        ? options.store()
        : options.store
    } else if (options.parent &amp;&amp; options.parent.$store) {
      // 获取父亲的$store属性
      this.$store = options.parent.$store
    }
  }
}

</code></pre>
<p>其实整个函数看起来似乎有点复杂</p>
<pre><code class="language-javascript">Vue.mixin({ beforeCreate: vuexInit })
</code></pre>
<p>其实只是调用了这段代码,因为这是vue2.0版本及以上才有的方法，我们这里只讨论vue2.0的情况，关于<code>mixin</code>的用法，这里不做介绍，它为所有的组件添加<code>beforeCreate</code>生命周期钩子</p>
<p>下面我们看一下<code>vuexInit</code>方法的实现</p>
<pre><code class="language-javascript">   // 这个方法的作用就是可以让每个组件都能通过this.$store放问到store对象
  function vuexInit () {
    // 获取mergeoptions的选项
    const options = this.$options
    // 这段if逻辑其实实在根组件中，添加了一个store属性，并赋给this.$store
    if (options.store) {
      // 如果store是一个方法，就调用store，否则直接使用
      this.$store = typeof options.store === 'function'
        ? options.store()
        : options.store
    } else if (options.parent &amp;&amp; options.parent.$store) {
      // 获取父亲的$store属性
      this.$store = options.parent.$store
    }
  }
</code></pre>
<p>首先，获取了<code>this.$options</code>,这段代码，如果大家有看过vue源码的应该知道，这是<code>mergeOptions</code>后的<code>options</code>, 先是判断是否存在<code>store</code>属性，如果不存在，就在父组件中查找，如果有就使用父组件中的<code>$store</code>，通过这种方式，能够在组件之间形成一种链式查找，其实本质上是引用了，根组件中的<code>store</code>,举个例子</p>
<pre><code class="language-javascript">new Vue({
  router,
  store,   // $store实际最终指向的都是这里的store
  render: h =&gt; h(App)
}).$mount('#app')
</code></pre>
<h2 id="new-vuexstoreoptions">new Vuex.Store(options)</h2>
<p>安装<code>install</code>完成之后，我们来看看<code>new Vuex.Store(options)</code>发生了什么,由于源码太多，就只截取构造函数中的代码，一起来看，vuex进行了哪些初始化操作</p>
<pre><code class="language-javascript">  constructor (options = {}) {
    if (!Vue &amp;&amp; typeof window !== 'undefined' &amp;&amp; window.Vue) {
      install(window.Vue)
    }

    if (process.env.NODE_ENV !== 'production') {
      assert(Vue, `must call Vue.use(Vuex) before creating a store instance.`)
      assert(typeof Promise !== 'undefined', `vuex requires a Promise polyfill in this browser.`)
      assert(this instanceof Store, `store must be called with the new operator.`)
    }

    const {
      plugins = [],
      strict = false //使 Vuex store 进入严格模式，在严格模式下，任何 mutation 处理函数以外修改 Vuex state 都会抛出错误。
    } = options


    this._committing = false   // 正在提交
    this._actions = Object.create(null)  // actions对象
    this._actionSubscribers = []  // actions订阅数组
    this._mutations = Object.create(null)  
    this._wrappedGetters = Object.create(null)
    this._modules = new ModuleCollection(options)  // 收集modules,
    this._modulesNamespaceMap = Object.create(null)
    this._subscribers = []
    this._watcherVM = new Vue()

    // bind commit and dispatch to self
    const store = this
    const { dispatch, commit } = this
    this.dispatch = function boundDispatch (type, payload) {
      return dispatch.call(store, type, payload)
    }
    this.commit = function boundCommit (type, payload, options) {
      return commit.call(store, type, payload, options)
    }

    // strict mode
    this.strict = strict

    // 根module的state属性
    const state = this._modules.root.state

    // init root module.
    // this also recursively registers all sub-modules
    // and collects all module getters inside this._wrappedGetters
    installModule(this, state, [], this._modules.root)

    // initialize the store vm, which is responsible for the reactivity
    // (also registers _wrappedGetters as computed properties)
    resetStoreVM(this, state)

    // apply plugins
    plugins.forEach(plugin =&gt; plugin(this))

    const useDevtools = options.devtools !== undefined ? options.devtools : Vue.config.devtools
    if (useDevtools) {
      devtoolPlugin(this)
    }
  }

</code></pre>
<pre><code class="language-javascript">    if (!Vue &amp;&amp; typeof window !== 'undefined' &amp;&amp; window.Vue) {
      install(window.Vue)
    }

    if (process.env.NODE_ENV !== 'production') {
      assert(Vue, `must call Vue.use(Vuex) before creating a store instance.`)
      assert(typeof Promise !== 'undefined', `vuex requires a Promise polyfill in this browser.`)
      assert(this instanceof Store, `store must be called with the new operator.`)
    }
</code></pre>
<p>这段代码我们不做讨论，相信大家也知道什么意思</p>
<pre><code class="language-javascript">    const {
     //一个数组，包含应用在 store 上的插件方法。这些插件直接接收 store 作为唯一参数，可以监听 mutation（用于外部地数据持久化、记录或调试）或者提交 mutation （用于内部数据，例如 websocket 或 某些观察者）
      plugins = [],
        
        
      strict = false //使 Vuex store 进入严格模式，在严格模式下，任何 mutation 处理函数以外修改 Vuex state 都会抛出错误。
    } = options
</code></pre>
<p>上面这段代码，获取了我们传入的配置<code>plugins</code>和<code>strict</code>，上面代码中标注有每个属性的作用，关于详细的使用可以到官网查看，以后会有讲解</p>
<pre><code class="language-javascript">    this._committing = false  
    this._actions = Object.create(null) 
    this._actionSubscribers = [] 

    this._mutations = Object.create(null)  

    this._wrappedGetters = Object.create(null)
    this._modules = new ModuleCollection(options) 
    this._modulesNamespaceMap = Object.create(null)
    this._subscribers = []
    this._watcherVM = new Vue()
</code></pre>
<p>这些代码做了一些属性的初始化，我们暂且不看具体是干什么用的，关键是下面这段代码</p>
<pre><code class="language-javascript">this._modules = new ModuleCollection(options) 
</code></pre>
<p>看到这段代码，我们肯定能立马想到，我们传入的<code>modules</code>配置，我们来看看<code>modules</code>做了哪些初始化</p>
<h3 id="new-modulecollectionoptions">new ModuleCollection(options)</h3>
<pre><code class="language-javascript">  constructor (rawRootModule) {
    this.register([], rawRootModule, false)
  }
</code></pre>
<p>这个类的构造函数只有简简单单的一行代码，它的参数<code>rawRootModule</code>,是我们给<code>Vuex.Store(options)</code>传入的完整的<code>options</code>,接下来看看<code>register</code>方法做了什么</p>
<pre><code class="language-javascript">  register (path, rawModule, runtime = true) {
    if (process.env.NODE_ENV !== 'production') {
      assertRawModule(path, rawModule)
    }
    // 创建Module对象，初始runtime为false
    const newModule = new Module(rawModule, runtime)
    if (path.length === 0) {
      // this.root = new Module(rawModule, runtime)
      this.root = newModule
    } else {
      // 如果path = ['user', 'login']， path.slice(0, -1) = ['user']   会去掉最后一个
      // parent是根模块
      const parent = this.get(path.slice(0, -1)) 
      // 把模块添加到根Module对象的_children对象中，形式如下
      // _children = {
      //   user: new Module(user, runtime)
      // }
      parent.addChild(path[path.length - 1], newModule)
    }
    // 如果options中存在modules属性
    if (rawModule.modules) {
      // 遍历modules都西昂
      forEachValue(rawModule.modules, (rawChildModule, key) =&gt; {
        // 获取每个module对应的options
        /*{
          modules: {
            user: {
              state,
              mutations
            },
            login
          },
          state: {

          },
          mutations: {
            
          }
        }*/

        // 看到上面的形式，如果modules里有options,继续递归遍历， 
        // path = ['user', 'login']
        this.register(path.concat(key), rawChildModule, runtime)
      })
    }
  }
</code></pre>
<pre><code>const newModule = new Module(rawModule, runtime)
</code></pre>
<p>代码一上来就创建了一个<code>Module</code>对象,并把<code>options</code>作为参数传入，我们继续看看<code>Module</code>这个类中做了哪些操作</p>
<pre><code class="language-javascript">export default class Module {
  constructor (rawModule, runtime) {
    this.runtime = runtime
    this._children = Object.create(null)
    this._rawModule = rawModule
    // 获取state
    const rawState = rawModule.state

    // 如果state是个方法就调用
    this.state = (typeof rawState === 'function' ? rawState() : rawState) || {}
  }

   // ...其他方法
}

</code></pre>
<p>上面的构造函数进行了一些初始化，<code>this.runtime</code>记录了是否是运行时，<code>this._children</code>初始化为空对象，它主要是用来，保存当前模块的子模块，<code>this._rawModule</code>记录了，当前模块的配置，然后又对<code>state</code>进行了些处理。然后我们大概知道了<code>new Module</code>做了什么</p>
<ol>
<li>创建了一个_children对象</li>
<li>_rawModule记录模块配置</li>
</ol>
<p>其他并不是很重要，我们先不提，再回到<code>new ModuleCollection(options)</code>,构造函数中</p>
<pre><code class="language-javascript">const newModule = new Module(rawModule, runtime)
</code></pre>
<p>这里拿到了<code>Module</code>对象</p>
<pre><code class="language-javascript">    if (path.length === 0) {
      // this.root = new Module(rawModule, runtime)
      this.root = newModule
    } else {
      // 如果path = ['user', 'login']， path.slice(0, -1) = ['user']   会去掉最后一个
      // parent是根模块
      const parent = this.get(path.slice(0, -1)) 
      // 把模块添加到根Module对象的_children对象中，形式如下
      // _children = {
      //   user: new Module(user, runtime)
      // }
      parent.addChild(path[path.length - 1], newModule)
    }
</code></pre>
<p>这是一段逻辑判断，而这个<code>path</code>是在<code>ModuleCollection</code>构造函数中,传入的,初始时为空</p>
<pre><code class="language-javascript">this.register([], rawRootModule, false)  

/**
   * 
   * @param {*} path 初始为空数组
   * @param {*} rawModule options
   * @param {*} runtime  初始为false
   */
  register (path, rawModule, runtime = true) {...}
  
  
</code></pre>
<pre><code class="language-javascript">    if (path.length === 0) {
      // this.root = new Module(rawModule, runtime)
      this.root = newModule
    } else {...}
</code></pre>
<p>他把<code>ModuleCollection</code>对象的root属性设置为一个<code>Module</code>对象，也就是代表根module,而else中的逻辑我们暂时不看，因为后面会有递归，下个周期时会进入else分支</p>
<pre><code class="language-javascript">    // 如果options中存在modules属性
    if (rawModule.modules) {
      // 遍历modules
      forEachValue(rawModule.modules, (rawChildModule, key) =&gt; {
        // 获取每个module对应的options

        /*{
          modules: {
            user: {
              state,
              mutations
            },
            login
          },
          state: {

          },
          mutations: {
            
          }
        }*/

        // 看到上面的形式，如果modules里有options,继续递归遍历， 
        // path = ['user', 'login']
        this.register(path.concat(key), rawChildModule, runtime)
      })
    }
</code></pre>
<p>这段代码，拿到了当前模块的配置，注意：根模块的配置其实就是<code>options</code>, 然后判断是否存在<code>modules</code>,如果存在，就遍历每个模块，这个<code>forEachValue</code>方法，其实实现非常简单，感兴趣的可以去看一下，最终回调函数遍历到每个<code>module</code>,并获取到<code>module</code>对象和它的模块对象的<code>key</code>,也就是模块名。</p>
<p>之后再次调用了下<code>register</code>方法，递归执行</p>
<pre><code class="language-javascript">this.register(path.concat(key), rawChildModule, runtime)
</code></pre>
<p><strong>注意</strong>：<code>path.concat(key)</code>, path本来是空数组，在每次递归时都会拼接模块的名字，这段代码非常关键，后面的<code>namespace</code>会有用到</p>
<p>然后我们再次回到<code>register</code>方法的开始</p>
<pre><code class="language-javascript">    // 创建Module对象，初始runtime为false
    const newModule = new Module(rawModule, runtime)
      
    if (path.length === 0) {
      // this.root = new Module(rawModule, runtime)
      this.root = newModule
    } else {
      // 如果path = ['user', 'login']， path.slice(0, -1) = ['user']   会去掉最后一个
      // parent是根模块
      const parent = this.get(path.slice(0, -1)) 
      // 把模块添加到根Module对象的_children对象中，形式如下
      // _children = {
      //   user: new Module(user, runtime)
      // }
      parent.addChild(path[path.length - 1], newModule)
    }
</code></pre>
<p>依然是创建了<code>Module</code>对象，此时的<code>Module</code>已经是子<code>Module</code>了, <code>if-else</code>判断也会执行到<code>else</code>中</p>
<pre><code class="language-javascript">    if (path.length === 0) {
 		//...
    } else {
      // 如果path = ['user', 'login']， path.slice(0, -1) = ['user']   会去掉最后一个
      // parent是根模块
      const parent = this.get(path.slice(0, -1)) 
      // 把模块添加到根Module对象的_children对象中，形式如下
      // _children = {
      //   user: new Module(user, runtime)
      // }
      parent.addChild(path[path.length - 1], newModule)
    }
</code></pre>
<p>假如我们有两个<code>module</code>,它会获取到除了最后一个的所有<code>module</code>的key列表，并调用<code>get</code>方法</p>
<pre><code class="language-javascript">  get (path) {
    return path.reduce((module, key) =&gt; {
      // 获取子模块
      return module.getChild(key)
    }, this.root)
  }
</code></pre>
<p>这段是<code>get</code>方法的实现,它其实是返回path对应模块的子模块</p>
<pre><code>parent.addChild(path[path.length - 1], newModule)
</code></pre>
<p>从最后，把模块添加到，当前模块的<code>_children</code>对象中</p>
<pre><code class="language-javascript">  addChild (key, module) {
    this._children[key] = module
  }
</code></pre>
<p>最后，通过<code>ModuleCollection</code>对象的<code>root</code>,就可以拿到<code>Module</code>对象树</p>
<p>类似这样</p>
<pre><code class="language-javascript">new Vuex.Store({
	modules:{
	    user: {
	       modules:{
               login
           }
	    },
	    cart: {
	        
	    }
	}
})
// 模拟一下
ModuleCollection = {
    root = 根Module: {
            _children: {
                子module(user): {
                	_children: {
                        子module(login)
                    }
                 },
                子module(cart)
            }
        }
}
</code></pre>
<blockquote>
<p>小总结：new ModuleCollection(options)在root这个属性上挂载了一个由module对象组成的树</p>
</blockquote>
<p>我们回到<code>new Vuex.Store(options)</code>时的构造函数</p>
<pre><code class="language-javascript">this._modules = new ModuleCollection(options)
</code></pre>
<p><code>this._modules</code>拿到了模块的集合</p>
<pre><code class="language-javascript">    // bind commit and dispatch to self
    const store = this
    const { dispatch, commit } = this
    this.dispatch = function boundDispatch (type, payload) {
      return dispatch.call(store, type, payload)
    }
    this.commit = function boundCommit (type, payload, options) {
      return commit.call(store, type, payload, options)
    }
</code></pre>
<p>这段代码，重写了<code>dispatch</code>和<code>commit</code>方法，其实相当于调用了<code>bind</code>方法,我个人认为也可以改写成这样</p>
<pre><code class="language-javascript">this.dispatch = this.dispatch.bind(store, type, payload)
this.commit = this.commit.bind(store, type, payload)
</code></pre>
<p>继续后面的步骤</p>
<pre><code>this.strict = strict
</code></pre>
<p><code>strict</code>使 Vuex store 进入严格模式，在严格模式下，任何 mutation 处理函数以外修改 Vuex state 都会抛出错误</p>
<pre><code class="language-javascript">    // 根module的state属性
    const state = this._modules.root.state
</code></pre>
<p>保存根模块的<code>state</code>属性</p>
<pre><code class="language-javascript">installModule(this, state, [], this._modules.root)
</code></pre>
<p>这段代码虽然简短，但是非常重要，我们来具体分析<code>installModule</code>方法</p>
<h3 id="installmodule">installModule</h3>
<pre><code class="language-javascript">/**
 * 
 * @param {*} store store对象
 * @param {*} rootState 根module的state对象
 * @param {*} path 初始为空数组
 * @param {*} module 根module对象
 * @param {*} hot 
 */
function installModule (store, rootState, path, module, hot) {
	
}
</code></pre>
<p>它的参数如上</p>
<pre><code class="language-javascript">  // 如果是空数组，说明是根module
  const isRoot = !path.length
</code></pre>
<p>判断是否是根模块</p>
<pre><code class="language-javascript">  // 返回由module名字 拼接成的字符串
  const namespace = store._modules.getNamespace(path)
</code></pre>
<p>这段代码很有意思，我们来看下<code>getNamespace</code>方法，它在<code>ModuleCollection</code>类中</p>
<pre><code class="language-javascript">  getNamespace (path) {
    // 根module
    let module = this.root

    return path.reduce((namespace, key) =&gt; {
      // 获取子module
      module = module.getChild(key)
      // 如果模块的namespace存在， 举个列子： 一层模块 user/， 二层模块： user/login/
      return namespace + (module.namespaced ? key + '/' : '')
    }, '')
  }
</code></pre>
<p>直接做一个简单的例子，如果我们在每个模块中使用了<code>namespaced</code>，设置为<code>true</code>，当我们调用<code>commit</code>,<code>dispatch</code>等方法时，我们需要这样做</p>
<pre><code class="language-javascript">this.$store.dispatch('count/increment')

this.$store.commit('count/INCREMENT')
</code></pre>
<p><code>getNamespace</code>要做的其实就是获取到<code>count/increment</code>前面的<code>count/</code>,并返回</p>
<pre><code class="language-javascript">  // 如果namespaced存在
  if (module.namespaced) {
    // 初始时store._modulesNamespaceMap[namespace]是不存在的
    if (store._modulesNamespaceMap[namespace] &amp;&amp; process.env.NODE_ENV !== 'production') {
      console.error(`[vuex] duplicate namespace ${namespace} for the namespaced module ${path.join('/')}`)
    }
    // namespace对应module
    store._modulesNamespaceMap[namespace] = module
  }
</code></pre>
<p>这段代码做的事情，就是把<code>namespace</code>和<code>module</code>作为key,value保存在<code>store</code>对象的<code>_modulesNamespaceMap</code>属性上,关于这个属性在什么地方用，可以参考<code>helper.js</code>的<code>getModuleByNamespace</code>方法，这个方法是实现<code>mapActions</code>，<code>mapMutations</code>的关键，以后也会讲到</p>
<p>然后是这段代码</p>
<pre><code class="language-javascript">  // 如果不是根root module   ，初始时hot也不存在， 初始时hot为ture,所以不会执行下面的
  if (!isRoot &amp;&amp; !hot) {
    const parentState = getNestedState(rootState, path.slice(0, -1))
    const moduleName = path[path.length - 1]
    store._withCommit(() =&gt; {
      Vue.set(parentState, moduleName, module.state)
    })
  }
</code></pre>
<p><code>isRoot</code>想必不用多说，就是判断是否是根模块，而<code>hot</code>这个变量又是哪里来的呢，他是<code>installModule</code>方法传入的一个参数，初始时他是空的，但这又有什么用处呢；emmm,由于我自己很少用到，我就不多做详细介绍了（因为菜，所以没用过），具体用法官方文档有详细介绍</p>
<p>我们继续，前面说到，<code>hot</code>是不存在的，而当前又是根节点，所以也不会执行这个if逻辑，但是我们还是要讲一下，不然一会还要回来讲，首先看一下<code>getNestedState</code>方法实现</p>
<pre><code class="language-javascript">const parentState = getNestedState(rootState, path.slice(0, -1))

// 具体实现
function getNestedState (state, path) {
  return path.length
    ? path.reduce((state, key) =&gt; state[key], state)
    : state
}

</code></pre>
<p>首先它的第一个参数是<code>state</code>,也就是当前模块的<code>state</code>,注意不一定是<code>rootState</code>，不要被调用参数误解，实际上是递归引用的传递，这个函数就是判断当前<code>path</code>是否为空，如果为空，表示它是根模块的<code>state</code>,不为空表示为子模块的<code>state</code>，要注意的是<code>path.slice(0, -1)</code>，它获取了除了本身模块名之前的模块名数组，<code>getNestedState</code>函数直接来说就是用来获取父模块的<code>state</code>,从字面意思也可以理解，至于reduce的一些操作就不详细讲解了。</p>
<pre><code class="language-javascript">const moduleName = path[path.length - 1]
</code></pre>
<p>然后就是获取了当前模块名,接下来关键来了</p>
<pre><code class="language-javascript">    store._withCommit(() =&gt; {
      Vue.set(parentState, moduleName, module.state)
    })
</code></pre>
<p>从字面意思，好像是跟随commit调用？没错就是这样。。</p>
<pre><code class="language-javascript">  _withCommit (fn) {
 
    const committing = this._committing
    this._committing = true
    fn()
    // 重新设置之前的提交状态
    this._committing = committing
  }
</code></pre>
<p>它就简单的调用了传入的回调函数，设置了前后的状态，然后来看下回调函数的内部</p>
<pre><code class="language-javascript">parentState:父模块的state
moduleName:当前模块名
module.state:当前模块的state

Vue.set(parentState, moduleName, module.state)
</code></pre>
<p>关于<code>Vue.set</code>方法的介绍：<strong>向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性，因为 Vue 无法探测普通的新增属性</strong></p>
<p>也就是说，它可以在把每个<code>state</code>属性变为响应式，在<code>commit</code>之前，为什么在之前呢，因为这是初始化阶段，我们没有主动调用<code>commit</code></p>
<p>我们继续后面的代码</p>
<pre><code class="language-javascript">  // 重写了dispatch, commit ,getter,state等方法，全部挂载到了当前模块的context属性上
  const local = module.context = makeLocalContext(store, namespace, path)
</code></pre>
<p>下面我将详细讲解<code>makeLocalContext</code>方法</p>
<h4 id="makelocalcontext">makeLocalContext</h4>
<pre><code class="language-javascript">function makeLocalContext (store, namespace, path) {
  const noNamespace = namespace === ''

  const local = {
    // 如果不存在namespace，就重写dispatch方法
    dispatch: noNamespace ? store.dispatch : (_type, _payload, _options) =&gt; {
      const args = unifyObjectStyle(_type, _payload, _options)
      const { payload, options } = args
      let { type } = args
      if (!options || !options.root) {
        // 使用namespace拼接action的类型
        type = namespace + type
        // 如果不使用 namespace/action的形式调用action就会报错
        if (process.env.NODE_ENV !== 'production' &amp;&amp; !store._actions[type]) {
          console.error(`[vuex] unknown local action type: ${args.type}, global type: ${type}`)
          return
        }
      }
      return store.dispatch(type, payload)
    },

    commit: noNamespace ? store.commit : (_type, _payload, _options) =&gt; {
      const args = unifyObjectStyle(_type, _payload, _options)
      const { payload, options } = args
      let { type } = args
      if (!options || !options.root) {
        type = namespace + type
        if (process.env.NODE_ENV !== 'production' &amp;&amp; !store._mutations[type]) {
          console.error(`[vuex] unknown local mutation type: ${args.type}, global type: ${type}`)
          return
        }
      }
      store.commit(type, payload, options)
    }
  }

  // getters and state object must be gotten lazily
  // because they will be changed by vm update
  Object.defineProperties(local, {
    getters: {
      get: noNamespace
        ? () =&gt; store.getters
        : () =&gt; makeLocalGetters(store, namespace)
    },
    state: {
      get: () =&gt; getNestedState(store.state, path)
    }
  })

  return local
}
</code></pre>
<p>这面代码返回了一个local对象，并且这些对象对<code>dispatch</code>,<code>commit</code>等方法还有<code>state</code>,<code>getter</code>进行了包装</p>
<pre><code class="language-javascript">const noNamespace = namespace === ''
</code></pre>
<p>这段代码用来判断是否存在命名空间<code>namespace</code>，然后我们再来看下<code>dispatch</code></p>
<h5 id="1dispatch">1.dispatch</h5>
<pre><code class="language-javascript">    dispatch: noNamespace ? store.dispatch : (_type, _payload, _options) =&gt; {
      const args = unifyObjectStyle(_type, _payload, _options)
      const { payload, options } = args
      let { type } = args
      if (!options || !options.root) {
        // 使用namespace拼接action的类型
        type = namespace + type
        // 如果不使用 namespace/action的形式调用action就会报错
        if (process.env.NODE_ENV !== 'production' &amp;&amp; !store._actions[type]) {
          console.error(`[vuex] unknown local action type: ${args.type}, global type: ${type}`)
          return
        }
      }
      return store.dispatch(type, payload)
    },
</code></pre>
<p>首先判断是否有命名空间，如果没有就是正常的<code>dispatch</code>,如果存在，则先统一对象风格<code>unifyObjectStyle</code></p>
<p>先来看下<code>unifyObjectStyle</code>实现,具体讲解就写在注释里了</p>
<pre><code class="language-javascript">// 统一对象风格
function unifyObjectStyle (type, payload, options) {
    // 
  if (isObject(type) &amp;&amp; type.type) {
    options = payload
    payload = type
    type = type.type
  }

  if (process.env.NODE_ENV !== 'production') {
    assert(typeof type === 'string', `expects string as the type, but found ${typeof type}.`)
  }

  return { type, payload, options }
}
</code></pre>
<p>在看这段代码之前，先说一下，一般来说我们都是这样使用<code>dispatch</code></p>
<pre><code class="language-javascript">store.dispatch('incrementAsync', {
  amount: 10
})
</code></pre>
<p>但其实也可以这样,并且官方文档也有例子</p>
<pre><code class="language-javascript">store.dispatch({
  type: 'incrementAsync',
  amount: 10
})
</code></pre>
<p>知道这些我们就继续往下分析</p>
<pre><code class="language-javascript">  if (isObject(type) &amp;&amp; type.type) {
    options = payload
    payload = type
    type = type.type
  }
</code></pre>
<p>这里是对参数进行了简单的处理，统一处理成了我们平常使用的模式，最后返回了相应的<code>type, payload, options</code></p>
<p>接下来，回到<code>makeLocalContext</code>方法</p>
<pre><code class="language-javascript">    dispatch: noNamespace ? store.dispatch : (_type, _payload, _options) =&gt; {
      const args = unifyObjectStyle(_type, _payload, _options)
      const { payload, options } = args
      let { type } = args
      if (!options || !options.root) {
        // 使用namespace拼接action的类型
        type = namespace + type
        // 如果不使用 namespace/action的形式调用action就会报错
        if (process.env.NODE_ENV !== 'production' &amp;&amp; !store._actions[type]) {
          console.error(`[vuex] unknown local action type: ${args.type}, global type: ${type}`)
          return
        }
      }
      return store.dispatch(type, payload)
    },
</code></pre>
<p>统一这些参数以后，又是一个if判断，第三个参数用的也很少，但是官方文档是有说明的，<code>options</code> 里可以有 <code>root: true</code>，它允许在<a href="https://vuex.vuejs.org/zh/guide/modules.html#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">命名空间模块</a>里提交根的 <code>mutation或action</code>，然后返回了调用<code>store.dispatch</code>方法的返回值，然后我们来看看包装后的<code>commit</code></p>
<h5 id="2commit">2.commit</h5>
<pre><code class="language-javascript">    commit: noNamespace ? store.commit : (_type, _payload, _options) =&gt; {
      const args = unifyObjectStyle(_type, _payload, _options)
      const { payload, options } = args
      let { type } = args
      if (!options || !options.root) {
        type = namespace + type
        if (process.env.NODE_ENV !== 'production' &amp;&amp; !store._mutations[type]) {
          console.error(`[vuex] unknown local mutation type: ${args.type}, global type: ${type}`)
          return
        }
      }
      store.commit(type, payload, options)
    }
</code></pre>
<p>这段代码和<code>dispatch</code>的实现非常相似，就不讲解了，所做的事情就是对参数进行统一</p>
<pre><code class="language-javascript">  Object.defineProperties(local, {
    getters: {
      get: noNamespace
        ? () =&gt; store.getters
        : () =&gt; makeLocalGetters(store, namespace)
    },
    state: {
      get: () =&gt; getNestedState(store.state, path)
    }
  })
</code></pre>
<p>然后这段代码是把<code>state</code>和<code>getter</code>代理到了local对象上，</p>
<h5 id="3getter">3.getter</h5>
<p>判断当前模块是否有命名空间，如果不是，就不做任何处理，否则调用<code>makeLocalGetters</code>方法，并传入<code>store</code>对象和<code>namespace</code>完整模块字符串，至于这个<code>namespace</code>是什么，可以往前翻一翻，有具体的讲解。比如<code>user/login</code>，表示user模块下的login模块的namespace。然后我们来看看<code>makeLocalGetters</code>做了什么</p>
<pre><code class="language-javascript">
function makeLocalGetters (store, namespace) {
  const gettersProxy = {}
  const splitPos = namespace.length
  Object.keys(store.getters).forEach(type =&gt; {
    // 截取getter中的namespace，如果不相等，就不做处理
    if (type.slice(0, splitPos) !== namespace) return

    // 获取getter 的namespace后面的字符串
    const localType = type.slice(splitPos)


    Object.defineProperty(gettersProxy, localType, {
      // 把getters中的属性方法，代理到新的对象中
      get: () =&gt; store.getters[type],
      enumerable: true
    })
  })

  return gettersProxy
}
</code></pre>
<p>这个函数被调用说明一定是有<code>namespace</code>的，然后遍历<code>getter</code>，此时的<code>getter</code>的属性名是包含有<code>namespace</code>的，至于为什么会有，这个在以后的<code>registerGetters</code>中会有讲解。然后获取到<code>namespace</code>后面真实的<code>getter</code>属性名，并被代理到一个新的对象中，并且被获取时，仍然是使用了完整的<code>namespace</code>，举个例子</p>
<pre><code>假设模块:  user/todo
store.getters.doSomething()   
等价于
store.getters['user/todo/doSomething']()
</code></pre>
<p>看完这些相信大家都明白了</p>
<h5 id="4state">4.state</h5>
<p>调用了<code>getNestedState</code>方法，这个方法想必不用多说，前面也有讲过，用来获取模块的父模块<code>state</code>，并返回</p>
<p>我们再回到一开始，调用<code>makeLocalContext</code>的位置, 返回的local对象，最终放在了模块的<code>context</code>属性上</p>
<pre><code class="language-javascript">const local = module.context = makeLocalContext(store, namespace, path)
</code></pre>
<p>接下来我们继续分析，后面的内容</p>
<h4 id="registermutation">registerMutation</h4>
<pre><code class="language-javascript">  // 遍历mutations
  module.forEachMutation((mutation, key) =&gt; {
    // 把namespace和mutation名进行拼接
    const namespacedType = namespace + key
    registerMutation(store, namespacedType, mutation, local)
  })
</code></pre>
<p>这段代码，简单来说就是遍历了，当前模块的所有<code>mutations</code>，并对每个<code>mutation</code>调用了<code>registerMutation</code>方法，传入了<code>store</code>对象，完整的<code>namespace + commit名</code>，<code>mutation函数</code>,以及<code>local</code>对象，接下来看看<code>registerMutation</code>方法实现，至于<code>forEachMutation</code>方法，大家可以自己看一下，实现也很简单</p>
<pre><code class="language-javascript">function registerMutation (store, type, handler, local) {
  const entry = store._mutations[type] || (store._mutations[type] = [])
  entry.push(function wrappedMutationHandler (payload) {
    // 调用mutation, 并传入state和参数
    handler.call(store, local.state, payload)
  })
}
</code></pre>
<p>这个函数，实际上是把当前模块的<code>mutation</code>放在了一个<code>_mutations</code>对象中，那这个属性在哪定义的呢</p>
<pre><code class="language-javascript">this._mutations = Object.create(null)
</code></pre>
<p>实际上在<code>Store</code>类的构造函数的时候已经初始化为了一个空对象，<code>registerMutation</code>所做的事情，就是把<code>mutations</code>和<code>namespaceType</code>,形成一个映射关系，并且<code>mutations</code>是一个数组，比如这样</p>
<pre><code>{
	'user/todo/INCREMENT': [
		function() {...}
	]
}
</code></pre>
<p>这里之所以用数组的形式存储函数，我觉得是为了防止重复定义<code>mutation</code>，因为调用之后只有最后一个会生效</p>
<pre><code class="language-javascript">  entry.push(function wrappedMutationHandler (payload) {
    // 调用mutation, 并传入state和参数
    handler.call(store, local.state, payload)
  })
</code></pre>
<p>然后就是把<code>mutation</code>的调用放在一个函数中，传入了state，payload，在真正调用<code>commit</code>的时候才会循环调用，真实的<code>mutation</code></p>
<p>下面我们继续看后面的代码</p>
<h4 id="registeraction">registerAction</h4>
<pre><code class="language-javascript">  module.forEachAction((action, key) =&gt; {
    // namespace + type
    const type = action.root ? key : namespace + key

    const handler = action.handler || action
    registerAction(store, type, handler, local)
  })
</code></pre>
<p>这里和前面的处理差不多，只是有个判断，如果action存在root说明是根模块，所以直接用<code>key</code>就好了,<code>options</code> 里可以有 <code>root: true</code>，它允许在<a href="https://vuex.vuejs.org/zh/guide/modules.html#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">命名空间模块</a>里提交根的 mutation，否则就使用<code>namespace</code>和<code>key</code>拼接成的action名，然后我们来看<code>registerAction</code>是实现</p>
<pre><code class="language-javascript">function registerAction (store, type, handler, local) {
  const entry = store._actions[type] || (store._actions[type] = [])
  entry.push(function wrappedActionHandler (payload, cb) {
    let res = handler.call(store, {
      dispatch: local.dispatch,
      commit: local.commit,
      getters: local.getters,
      state: local.state,
      rootGetters: store.getters,
      rootState: store.state
    }, payload, cb)
    if (!isPromise(res)) {
      res = Promise.resolve(res)
    }
      // 这是给devTool用的，可以不用关心
    if (store._devtoolHook) {
      return res.catch(err =&gt; {
        store._devtoolHook.emit('vuex:error', err)
        throw err
      })
    } else {
      return res
    }
  })
}

</code></pre>
<p>我们暂且不看<code>wrappedActionHandler</code>函数里面的内容，它的处理依旧和<code>mutation</code>的处理一样，也是把action放在<code>_actions</code>对象中，然后再看<code>wrappedActionHandler</code>里的内容，它调用了<code>action</code>,并且让他this指向了<code>store</code>,传入了，<code>local</code>对象中的<code>dispatch</code>,<code>commit</code>等方法还有<code>state</code>,<code>getter</code>,这不就是我们之前看到的，经过处理后的API方法吗。</p>
<p>然后它拿到<code>action</code>调用之后的返回值，最终返回了一个<code>Promise.resolve(res)</code>,也就是一个Promise</p>
<p>通过上面这些代码，我们能在实际中这么用</p>
<p>注意：<strong>commit, dispatch,getters,state都是当前模块里的方法和对象</strong></p>
<pre><code class="language-javascript">{
	actions: {
		async increment({ commit, dispatch, getters,state, rootGetters, rootState }) {
		 	return await getData()
		}
	}
}
</code></pre>
<p>说完了<code>registerAction</code>，我们来说一说<code>registerGetter</code></p>
<h4 id="registergetter">registerGetter</h4>
<pre><code class="language-javascript">  module.forEachGetter((getter, key) =&gt; {
    const namespacedType = namespace + key
    registerGetter(store, namespacedType, getter, local)
  })
</code></pre>
<p>不多废话，直接看<code>registerGetter</code>的实现</p>
<pre><code class="language-javascript">function registerGetter (store, type, rawGetter, local) {
  if (store._wrappedGetters[type]) {
    if (process.env.NODE_ENV !== 'production') {
      console.error(`[vuex] duplicate getter key: ${type}`)
    }
    return
  }
  store._wrappedGetters[type] = function wrappedGetter (store) {
    return rawGetter(
      local.state, // local state
      local.getters, // local getters
      store.state, // root state
      store.getters // root getters
    )
  }
}
</code></pre>
<p>一上来就是一个判断，简单点来说就是，不允许有重复定义的<code>getters</code>，我们之前是看到<code>actions</code>和<code>mutation</code>是可以重复定义的。然后再来看其他的，它和之前的处理有所不同，但也相差不大，因为不允许有重复，所以就不需要push一个函数了，直接调用了<code>getter</code>方法，传入了<code>state</code>,<code>getters</code>,根<code>state</code>,根<code>getters</code>，我们可以这样用</p>
<pre><code class="language-javascript">{
	['INCREMENT']: function(state, getters, rootState, rootGetters){
		//...
	}
}
</code></pre>
<p>讲完这些<code>installModule</code>基本上要结束了，我们看最后一段代码</p>
<pre><code class="language-javascript">  module.forEachChild((child, key) =&gt; {
    installModule(store, rootState, path.concat(key), child, hot)
  })
</code></pre>
<p>没错，是个递归，它拿到了子模块进行了递归，大家可以翻到前面梳理一下流程</p>
<p><code>installModule</code>方法我们也讲完了，我们要回到Store类的构造函数中，看看还有些什么初始化操作</p>
<pre><code class="language-javascript">resetStoreVM(this, state)

plugins.forEach(plugin =&gt; plugin(this))

const useDevtools = options.devtools !== undefined ? options.devtools : Vue.config.devtools
if (useDevtools) {
   devtoolPlugin(this)
}
</code></pre>
<p>接下来分析<code>resetStoreVM</code></p>
<h3 id="resetstorevm">resetStoreVM</h3>
<pre><code class="language-javascript">function resetStoreVM (store, state, hot) {
  const oldVm = store._vm
  // bind store public getters
  store.getters = {}
  const wrappedGetters = store._wrappedGetters
  const computed = {}
  forEachValue(wrappedGetters, (fn, key) =&gt; {
    // use computed to leverage its lazy-caching mechanism
    // direct inline function use will lead to closure preserving oldVm.
    // using partial to return function with only arguments preserved in closure enviroment.
    computed[key] = partial(fn, store)
    Object.defineProperty(store.getters, key, {
      get: () =&gt; store._vm[key],
      enumerable: true // for local getters
    })
  })

  // use a Vue instance to store the state tree
  // suppress warnings just in case the user has added
  // some funky global mixins
  const silent = Vue.config.silent
  Vue.config.silent = true
  store._vm = new Vue({
    data: {
      $$state: state
    },
    computed
  })
  Vue.config.silent = silent

  // enable strict mode for new vm
  if (store.strict) {
    enableStrictMode(store)
  }

  if (oldVm) {
    if (hot) {
      // dispatch changes in all subscribed watchers
      // to force getter re-evaluation for hot reloading.
      store._withCommit(() =&gt; {
        oldVm._data.$$state = null
      })
    }
    Vue.nextTick(() =&gt; oldVm.$destroy())
  }
}
</code></pre>
<p>首先看一下<code>store._vm</code>是什么，如果有注意到这个函数中间的一段代码的话可以看到，<code>_vm</code>是又创建了一个Vue实例，这个我们后面讲。然后在<code>store</code>上定义了一个对象<code>getters</code>，然后遍历之前，<code>registerGetters</code>注册的<code>getter</code>,然后是这段代码</p>
<pre><code class="language-javascript">  forEachValue(wrappedGetters, (fn, key) =&gt; {
    // use computed to leverage its lazy-caching mechanism
    // direct inline function use will lead to closure preserving oldVm.
    // using partial to return function with only arguments preserved in closure enviroment.
    computed[key] = partial(fn, store)
    Object.defineProperty(store.getters, key, {
      get: () =&gt; store._vm[key],
      enumerable: true // for local getters
    })
  })


// partial函数实现
export function partial (fn, arg) {
  return function () {
    return fn(arg)
  }
}
</code></pre>
<p>首先是遍历所有<code>getters</code>,调用<code>partial</code>函数，返回了一个新函数，并把它放入<code>computed</code>对象中，后面的代码其实是做了这件事</p>
<pre><code>$store.getter
等价于
$store._vm.getter
</code></pre>
<p>把<code>getter</code>代理到了一个新的Vue实例的<code>computed</code>对象上，这在后面的代码有所体现</p>
<pre><code class="language-javascript">  const silent = Vue.config.silent
  // 启动Vue的日志和警告
  Vue.config.silent = true
  store._vm = new Vue({
    data: {
      // 把state放在Vue的data中
      $$state: state
    },
    computed  // 把所有getter放在了computed中
  })
</code></pre>
<p>这段代码相信不会陌生，vuex之所以能够响应式，原因就在这里，我们通过调用<code>mutation</code>,修改了<code>state</code>,会触发页面更新，其实是Vue的帮助</p>
<h4 id="strict">strict</h4>
<p>我们继续看后面的代码</p>
<pre><code class="language-javascript">  if (store.strict) {
    enableStrictMode(store)
  }

  if (oldVm) {
    if (hot) {
     // 强制getters重新计算
      store._withCommit(() =&gt; {
        oldVm._data.$$state = null
      })
    }
    // 防止重复创建Vue实例（个人理解）
    Vue.nextTick(() =&gt; oldVm.$destroy())
  }
</code></pre>
<p>首先是判断<code>strict</code>是否为true, 表示是严格模式，如果直接更改state，会报错，我们看一下它的实现</p>
<pre><code class="language-javascript">function enableStrictMode (store) {
  store._vm.$watch(function () { return this._data.$$state }, () =&gt; {
    if (process.env.NODE_ENV !== 'production') {
      assert(store._committing, `do not mutate vuex store state outside mutation handlers.`)
    }
  }, { deep: true, sync: true })
}
</code></pre>
<p>很关键的是中间的箭头函数，我们可以直接看一下Vue源码的实现，它是如何实现修改state报错</p>
<pre><code class="language-javascript">  Vue.prototype.$watch = function (
    expOrFn: string | Function,
    cb: any,
    options?: Object
  ): Function {
    const vm: Component = this
    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options)
    }
    options = options || {}

    options.user = true  // 很关键的属性

    const watcher = new Watcher(vm, expOrFn, cb, options)

    if (options.immediate) {
      try {
        cb.call(vm, watcher.value)
      } catch (error) {
        handleError(error, vm, `callback for immediate watcher &quot;${watcher.expression}&quot;`)
      }
    }
    return function unwatchFn () {
      watcher.teardown()
    }
  }
</code></pre>
<p>这段代码有个地方很关键,<code>options.user = true</code>，它被传入了<code>Watcher</code>对象中，还有我们传入了箭头函数<code>cb</code></p>
<p>我们看看Watcher哪里有使用到<code>user</code>属性</p>
<pre><code class="language-javascript">class Watcher {
    
  // ...
    
  update () {
    /* istanbul ignore else */
    if (this.lazy) {
      this.dirty = true
    } else if (this.sync) {
      this.run()
    } else {
      queueWatcher(this)
    }
  }
  run () {
    if (this.active) {
      const value = this.get()
      if (
        value !== this.value ||
        // Deep watchers and watchers on Object/Arrays should fire even
        // when the value is the same, because the value may
        // have mutated.
        isObject(value) ||
        this.deep
      ) {
        // set new value
        const oldValue = this.value
        this.value = value
        if (this.user) {
          try {
            this.cb.call(this.vm, value, oldValue)
          } catch (e) {
            handleError(e, this.vm, `callback for watcher &quot;${this.expression}&quot;`)
          }
        } else {
          this.cb.call(this.vm, value, oldValue)
        }
      }
    }
  }
    
    // ...
}


</code></pre>
<p>我先说一下，这个<code>run</code>方法在什么时机调用的，它是在<code>set</code>属性访问器内部调用<code>notify</code>之后，<code>watcher</code>会调用自身的<code>update</code>方法,然后<code>run</code>就会被调用，可能说的不太清楚，如果各位有时间可以看一下，这里只针对<code>strict</code>原理来讲</p>
<p>下面我们只看这段代码</p>
<pre><code class="language-javascript">        if (this.user) {
          try {
            this.cb.call(this.vm, value, oldValue)
          } catch (e) {
            handleError(e, this.vm, `callback for watcher &quot;${this.expression}&quot;`)
          }
        } else {
          this.cb.call(this.vm, value, oldValue)
        }
</code></pre>
<p>我们知道之前传入的<code>user</code>属性为true, 如果调用回调是一定会抛出错误的</p>
<pre><code class="language-javascript">    if (process.env.NODE_ENV !== 'production') {
      assert(store._committing, `do not mutate vuex store state outside mutation handlers.`)
    }
</code></pre>
<p>这就是<code>strict</code>模式下，直接修改<code>state</code>会报错的原因</p>
<p>讲完这些，其实后面的代码就简单略过了，也不是很重要（懒？）</p>
<p>然后我们来看<code>Store</code>构造函数中最后一点内容</p>
<pre><code class="language-javascript">    plugins.forEach(plugin =&gt; plugin(this))

    const useDevtools = options.devtools !== undefined ? options.devtools : Vue.config.devtools
    if (useDevtools) {
      devtoolPlugin(this)
   }
</code></pre>
<p>首先调用了所有的<code>plugin</code>,并传入了<code>store</code>对象，关于<code>plugin</code>的用法官方文档都有介绍。然后关于<code>useDevtools</code>内容我就不讲解了，它和devTool相关</p>
<p>终于讲完了初始化，我们开始讲<code>Vuex</code>的一些API</p>
<h2 id="api">API</h2>
<p>我们按照官方文档一个个来</p>
<h4 id="1-commit">1. commit</h4>
<p>​	<code>commit</code>的用法就不用介绍了，直接看源码</p>
<pre><code class="language-javascript">  commit (_type, _payload, _options) {
    // check object-style commit
    const {
      type,
      payload,
      options
    } = unifyObjectStyle(_type, _payload, _options)

    const mutation = { type, payload }
    const entry = this._mutations[type]
    if (!entry) {
      if (process.env.NODE_ENV !== 'production') {
        console.error(`[vuex] unknown mutation type: ${type}`)
      }
      return
    }
    this._withCommit(() =&gt; {
      // 遍历type对应的mutation数组
      entry.forEach(function commitIterator (handler) {
        handler(payload)
      })
    })
    // 遍历所有订阅，并传入mutation对象和状态
    this._subscribers.forEach(sub =&gt; sub(mutation, this.state))

    if (
      process.env.NODE_ENV !== 'production' &amp;&amp;
      options &amp;&amp; options.silent
    ) {
      console.warn(
        `[vuex] mutation type: ${type}. Silent option has been removed. ` +
        'Use the filter functionality in the vue-devtools'
      )
    }
  }
</code></pre>
<p>首先是调用<code>unifyObjectStyle</code>方法，统一对象风格，如果有看前面的内容的话，应该知道，这是用来处理以下两种情况的参数</p>
<pre><code>commit(type: string, payload?: any, options?: Object)
commit(mutation: Object, options?: Object)
</code></pre>
<p>然后是下面这段</p>
<pre><code class="language-javascript">    const mutation = { type, payload }
    const entry = this._mutations[type]
    if (!entry) {
      if (process.env.NODE_ENV !== 'production') {
        console.error(`[vuex] unknown mutation type: ${type}`)
      }
      return
    }
</code></pre>
<p>如果<code>commit</code>的<code>mutation</code>不存在的话，就会报出警告,并返回不做处理</p>
<pre><code class="language-javascript">    this._withCommit(() =&gt; {
      // 遍历type对应的mutation数组
      entry.forEach(function commitIterator (handler) {
        handler(payload)
      })
    })
</code></pre>
<p><code>_withCommit</code>方法前面也有讲过，简单点说其实就是调用传入的回调函数，这里循环调用了<code>mutation</code>，至于为什么是数组，前面有讲到，是在<code>registerMutation</code>方法</p>
<p>我们继续来看</p>
<pre><code class="language-javascript">    // 遍历所有订阅，并传入mutation对象和状态
    this._subscribers.forEach(sub =&gt; sub(mutation, this.state))
    
    //  silent属性已经被删除，不让使用
    if (
      process.env.NODE_ENV !== 'production' &amp;&amp;
      options &amp;&amp; options.silent
    ) {
      console.warn(
        `[vuex] mutation type: ${type}. Silent option has been removed. ` +
        'Use the filter functionality in the vue-devtools'
      )
    }
</code></pre>
<p><code>this._subscribers</code>属性也是在<code>Store</code>对象的构造函数初始化时创建的一个数组，看到这个数组的名字，不用多说肯定是发布订阅模式，然后循环调用订阅的回调函数,它是在<code>mutation</code>被调用后执行, 但是在哪里订阅的呢，其实是在<code>subscribe</code>方法，它也是Vuex的一个API，下面我们来具体讲讲</p>
<h4 id="2-subscribe">2. subscribe</h4>
<p>订阅 store 的 mutation。<code>handler</code> 会在每个 <code>mutation</code>完成后调用，接收 mutation 和经过 mutation 后的状态作为参数</p>
<pre><code class="language-javascript">  subscribe (fn) {
    return genericSubscribe(fn, this._subscribers)
  }
</code></pre>
<pre><code class="language-javascript">function genericSubscribe (fn, subs) {
  if (subs.indexOf(fn) &lt; 0) {
    subs.push(fn)
  }
  return () =&gt; {
    const i = subs.indexOf(fn)
    if (i &gt; -1) {
      subs.splice(i, 1)
    }
  }
}
</code></pre>
<p>这就是一个简单的发布订阅模式的应用，把回调存储在了订阅数组中，其中<code>genericSubscribe</code>方法利用了闭包，返回了一个函数，调用它之后就可以取消订阅,其实还有其他的订阅方法,<code>subscribeAction</code></p>
<h4 id="3-subscribeaction">3. subscribeAction</h4>
<pre><code class="language-javascript">  subscribeAction (fn) {
    const subs = typeof fn === 'function' ? { before: fn } : fn
    return genericSubscribe(subs, this._actionSubscribers)
  }
</code></pre>
<p>判断是否是一个函数，如果是默认为<code>before</code>函数，也就是在<code>dispatch</code>调用<code>action</code>之前调用，如果是<code>{after: fn}</code>就会在<code>action</code>之后调用</p>
<h4 id="4-dispatch">4. dispatch</h4>
<pre><code class="language-javascript">  // 执行了beforeActions所有回调
  // 执行所有actions,并拿到所有promise返回的结果
  // 执行了afterActions所有回调
  dispatch (_type, _payload) {
    // check object-style dispatch
    const {
      type,
      payload
    } = unifyObjectStyle(_type, _payload)

    const action = { type, payload }
    const entry = this._actions[type]
    if (!entry) {
      if (process.env.NODE_ENV !== 'production') {
        console.error(`[vuex] unknown action type: ${type}`)
      }
      return
    }

    try {
      this._actionSubscribers
        .filter(sub =&gt; sub.before)
        .forEach(sub =&gt; sub.before(action, this.state))
    } catch (e) {
      if (process.env.NODE_ENV !== 'production') {
        console.warn(`[vuex] error in before action subscribers: `)
        console.error(e)
      }
    }

    const result = entry.length &gt; 1
      ? Promise.all(entry.map(handler =&gt; handler(payload)))
      : entry[0](payload)

    return result.then(res =&gt; {
      try {
        this._actionSubscribers
          .filter(sub =&gt; sub.after)
          .forEach(sub =&gt; sub.after(action, this.state))
      } catch (e) {
        if (process.env.NODE_ENV !== 'production') {
          console.warn(`[vuex] error in after action subscribers: `)
          console.error(e)
        }
      }
      return res
    })
  }
</code></pre>
<p>前面关于对象统一，以及是否存在<code>action</code>的判断就不讲了</p>
<pre><code class="language-javascript">    try {
      this._actionSubscribers
        .filter(sub =&gt; sub.before)
        .forEach(sub =&gt; sub.before(action, this.state))
    } catch (e) {
      if (process.env.NODE_ENV !== 'production') {
        console.warn(`[vuex] error in before action subscribers: `)
        console.error(e)
      }
    }
</code></pre>
<p>然后过滤筛选获取到了订阅的一些<code>before</code>函数,也就是在调用<code>action</code>之前调用，并传入了<code>action</code>, <code>action = { type, payload }</code>以及<code>state</code></p>
<h4 id="5-watch">5. watch</h4>
<p>响应式地侦听 <code>fn</code> 的返回值，当值改变时调用回调函数。<code>fn</code> 接收 store 的 state 作为第一个参数，其 getter 作为第二个参数。最后接收一个可选的对象参数表示 Vue 的 <a href="https://cn.vuejs.org/v2/api/#vm-watch"><code>vm.$watch</code></a> 方法的参数。</p>
<pre><code class="language-javascript">  watch (getter, cb, options) {
    if (process.env.NODE_ENV !== 'production') {
      assert(typeof getter === 'function', `store.watch only accepts a function.`)
    }
    return this._watcherVM.$watch(() =&gt; getter(this.state, this.getters), cb, options)
  }

// Store构造函数初始化时
this._watcherVM = new Vue()
</code></pre>
<p>这里给侦听函数里的，<code>getter</code>传入了<code>state</code>和<code>getters</code>, 当<code>state</code>发生变化时，侦听函数的返回值也发生了变化，值改变后就会触发<code>cb</code>回调函数, 关于<code>vm.$watch</code>的用法，可以参考Vue的官方文档<a href="https://cn.vuejs.org/v2/api/#vm-watch"><code>vm.$watch</code></a></p>
<h4 id="6-replacestate">6. replaceState</h4>
<p>替换 store 的根状态，仅用状态合并或时光旅行调试。</p>
<pre><code class="language-javascript">    this._withCommit(() =&gt; {
      this._vm._data.$$state = state
    })
</code></pre>
<p>直接替换掉了<code>$$state</code>原本状态</p>
<h4 id="7-registermodule">7. registerModule</h4>
<p>可以注册模块，例子：</p>
<pre><code class="language-javascript">// 注册模块 `myModule`
store.registerModule('myModule', {
  // ...
})
// 注册嵌套模块 `nested/myModule`
store.registerModule(['nested', 'myModule'], {
  // ...
})
</code></pre>
<pre><code class="language-javascript">  registerModule (path, rawModule, options = {}) {
    if (typeof path === 'string') path = [path]

    if (process.env.NODE_ENV !== 'production') {
      assert(Array.isArray(path), `module path must be a string or an Array.`)
      assert(path.length &gt; 0, 'cannot register the root module by using registerModule.')
    }

    this._modules.register(path, rawModule)
    installModule(this, this.state, path, this._modules.get(path), options.preserveState)
    // reset store to update getters...
    resetStoreVM(this, this.state)
  }
</code></pre>
<p>首先时统一处理了一下<code>path</code>和一些断言，然后调用了<code>register</code>方法<code>installModule</code>方法，<code>resetStoreVM</code>方法，这几个方法前面都有讲到，相当于又创建了一个<code>Store</code>对象，流程也差不多</p>
<h4 id="8-unregistermodule">8. unregisterModule</h4>
<p>卸载一个动态模块。</p>
<pre><code class="language-javascript">  unregisterModule (path) {
    if (typeof path === 'string') path = [path]
    if (process.env.NODE_ENV !== 'production') {
      assert(Array.isArray(path), `module path must be a string or an Array.`)
    }

    this._modules.unregister(path)
    this._withCommit(() =&gt; {
      const parentState = getNestedState(this.state, path.slice(0, -1))
      Vue.delete(parentState, path[path.length - 1])
    })
    resetStore(this)
  }
</code></pre>
<p>前面是对<code>path</code>模块名进行了处理以及断言是否是数组，然后调用<code>unregister</code></p>
<pre><code class="language-javascript">this._modules.unregister(path)


unregister (path) {
    const parent = this.get(path.slice(0, -1))
    const key = path[path.length - 1]
    if (!parent.getChild(key).runtime) return

    parent.removeChild(key)
}
</code></pre>
<p>这里获取到了传入模块名，也就是<code>path</code>的父模块，然后获取子模块判断是否存在<code>runtime</code>属性，这个属性是干嘛的，我也不是很清楚，希望又大佬解惑（菜 ！- -,没办法啊）</p>
<pre><code class="language-javascript">  parent.removeChild(key)

  removeChild (key) {
    delete this._children[key]
  }
</code></pre>
<p>最后删除了子模块,也就是我们要删除的模块</p>
<h4 id="9-hotupdate">9. hotUpdate</h4>
<p>热替换新的 action 和 mutation</p>
<p><strong>官方的例子</strong></p>
<pre><code class="language-javascript">// store.js
import Vue from 'vue'
import Vuex from 'vuex'
import mutations from './mutations'
import moduleA from './modules/a'

Vue.use(Vuex)

const state = { ... }

const store = new Vuex.Store({
  state,
  mutations,
  modules: {
    a: moduleA
  }
})

if (module.hot) {
  // 使 action 和 mutation 成为可热重载模块
  module.hot.accept(['./mutations', './modules/a'], () =&gt; {
    // 获取更新后的模块
    // 因为 babel 6 的模块编译格式问题，这里需要加上 `.default`
    const newMutations = require('./mutations').default
    const newModuleA = require('./modules/a').default
    // 加载新模块
    store.hotUpdate({
      mutations: newMutations,
      modules: {
        a: newModuleA
      }
    })
  })
}
</code></pre>
<p>热模块更新源码如下</p>
<pre><code class="language-javascript">  hotUpdate (newOptions) {
    this._modules.update(newOptions)
    resetStore(this, true)
  }
</code></pre>
<p><code>this._modules.update(newOptions)</code>方法是在<code>module-collection.js</code>文件中定义</p>
<pre><code class="language-javascript">  update (rawRootModule) {
    update([], this.root, rawRootModule)
  }

</code></pre>
<pre><code class="language-javascript">function update (path, targetModule, newModule) {
  if (process.env.NODE_ENV !== 'production') {
    assertRawModule(path, newModule)
  }

  // update target module
  targetModule.update(newModule)

  // update nested modules
  if (newModule.modules) {
    for (const key in newModule.modules) {
       // 如果传入的配置中没有该模块就报错
      if (!targetModule.getChild(key)) {
        if (process.env.NODE_ENV !== 'production') {
          console.warn(
            `[vuex] trying to add a new module '${key}' on hot reloading, ` +
            'manual reload is needed'
          )
        }
        return
      }
      update(
        path.concat(key),
        targetModule.getChild(key),
        newModule.modules[key]
      )
    }
  }
}

</code></pre>
<p>以上代码总的来说就是递归遍历模块，并更新模块，其中涉及到三个<code>update</code>方法，大家不要弄混。</p>
<pre><code>update([], this.root, rawRootModule)
</code></pre>
<p>主要传入了，一个空数组，原本的根模块对象，要用来替换的模块配置</p>
<pre><code class="language-javascript">function update (path, targetModule, newModule) {
  if (process.env.NODE_ENV !== 'production') {
    assertRawModule(path, newModule)
  }

  // update target module
  targetModule.update(newModule)

  // update nested modules
  if (newModule.modules) {
    for (const key in newModule.modules) {
       // 如果传入的配置中没有该模块就报错
      if (!targetModule.getChild(key)) {
        if (process.env.NODE_ENV !== 'production') {
          console.warn(
            `[vuex] trying to add a new module '${key}' on hot reloading, ` +
            'manual reload is needed'
          )
        }
        return
      }
      update(
        path.concat(key),
        targetModule.getChild(key),
        newModule.modules[key]
      )
    }
  }
</code></pre>
<p>递归遍历，原本的模块树，使用新模块替换掉原本模块</p>
<p>以上代码中还有一个模块中的<code>update</code>方法,即<code>targetModule.update(newModule)</code></p>
<pre><code class="language-javascript">// update target module
targetModule.update(newModule)

// module.js
update (rawModule) {
    this._rawModule.namespaced = rawModule.namespaced
    if (rawModule.actions) {
      this._rawModule.actions = rawModule.actions
    }
    if (rawModule.mutations) {
      this._rawModule.mutations = rawModule.mutations
    }
    if (rawModule.getters) {
      this._rawModule.getters = rawModule.getters
    }
  }
</code></pre>
<p>这个方法其实很简单，替换掉了原本的模块。</p>
<h2 id="辅助函数">辅助函数</h2>
<p><code>mapXXX</code>方法都在<code>helper.js</code>文件中</p>
<pre><code class="language-javascript">// helper.js
export const mapState = normalizeNamespace((namespace, states) =&gt; {
  //..
})

export const mapMutations = normalizeNamespace((namespace, mutations) =&gt; {
  // ..
})
// ...
</code></pre>
<p>可以看到他们都调用了<code>normalizeNamespace</code>方法，我们知道<code>mapXxx</code>是一个方法，所以它一定会返回一个方法</p>
<pre><code class="language-javascript">function normalizeNamespace (fn) {
  return (namespace, map) =&gt; {
    if (typeof namespace !== 'string') {
      map = namespace
      namespace = ''
    } else if (namespace.charAt(namespace.length - 1) !== '/') {
      namespace += '/'
    }
    return fn(namespace, map)
  }
}
</code></pre>
<p>这个方法实际上是对参数进行了处理，判断如果<code>namespace</code>不是字符串，也就是说它可能不存在，<code>namespace</code>就设置为一个空字符串，比如这样</p>
<pre><code>{
	computed: {
		...mapState(['username'])
	}
}
</code></pre>
<p>如果传入了<code>namespace</code>字符串，并且最后没有斜杠，就自动帮它加上，最后才是调用真实的<code>mapXXX</code>，比如这样</p>
<pre><code>{
	computed: {
		...mapState('user/', ['username'])
	}
}
</code></pre>
<p>接下来我们看一下<code>mapState</code>实现</p>
<h4 id="mapstate">mapState</h4>
<pre><code class="language-javascript">export const mapState = normalizeNamespace((namespace, states) =&gt; {
  const res = {}
  normalizeMap(states).forEach(({ key, val }) =&gt; {
    res[key] = function mappedState () {
      let state = this.$store.state
      let getters = this.$store.getters
      if (namespace) {
        const module = getModuleByNamespace(this.$store, 'mapState', namespace)
        if (!module) {
          return
        }
        state = module.context.state
        getters = module.context.getters
      }
      return typeof val === 'function'
        ? val.call(this, state, getters)
        : state[val]
    }
    // mark vuex getter for devtools
    res[key].vuex = true
  })
  return res
})
</code></pre>
<p>首先又是调用了一个<code>normalizeMap</code>方法，传入了我们需要获取的<code>states</code>,<code>normalizeMap</code>实现如下</p>
<pre><code class="language-javascript">function normalizeMap (map) {
  return Array.isArray(map)
    ? map.map(key =&gt; ({ key, val: key }))
    : Object.keys(map).map(key =&gt; ({ key, val: map[key] }))
}
</code></pre>
<p>这段代码看起来可能有点复杂，举个例子</p>
<pre><code class="language-javascript">normalizeMap([1, 2, 3]) =&gt; [ { key: 1, val: 1 }, { key: 2, val: 2 }, { key: 3, val: 3 } ]
normalizeMap(['user', 'count']) =&gt; [ { key: 'user', val: 'user' }, { key: 'count', val: 'count' }]

normalizeMap({a: 1, b: 2, c: 3}) =&gt; [ { key: 'a', val: 1 }, { key: 'b', val: 2 }, { key: 'c', val: 3 } ]
</code></pre>
<p>然后我们回到之前的代码</p>
<pre><code class="language-javascript">export const mapState = normalizeNamespace((namespace, states) =&gt; {
  const res = {}
  normalizeMap(states).forEach(({ key, val }) =&gt; {
    res[key] = function mappedState () {
      let state = this.$store.state
      let getters = this.$store.getters
      if (namespace) {
        const module = getModuleByNamespace(this.$store, 'mapState', namespace)
        if (!module) {
          return
        }
        state = module.context.state
        getters = module.context.getters
      }
      return typeof val === 'function'
        ? val.call(this, state, getters)
        : state[val]
    }
    // mark vuex getter for devtools
    res[key].vuex = true
  })
  return res
})
</code></pre>
<p>细心的童鞋可能注意到了，整个<code>mapState</code>返回的是一个对象，其形式如下，其他<code>mapMutations</code>,<code>mapActions</code>都可以这样</p>
<pre><code class="language-javascript">mapState('user', ['username', 'password'])

{
	username: function(){},
	password: function(){}
}

mapMutation('count', ['increment'])
</code></pre>
<p>现在知道为啥<code>mapState</code>要写在<code>computed</code>里了吧！原因就在这里。为了方便我就直接用注释分析了</p>
<pre><code class="language-javascript">    res[key] = function mappedState () {
      // store对象中的state,这个state是根state 
      let state = this.$store.state
      // 根getters
      let getters = this.$store.getters
      // 如果传入了namespace
      if (namespace) {
        // 调用getModuleByNamespace方法，源码实现在下方,它返回namespace对应的模块
        const module = getModuleByNamespace(this.$store, 'mapState', namespace)
        if (!module) {
          return
        }
        // 有看过前面源码应该记得，很多方法和对象都挂载到了context属性上
        state = module.context.state
        getters = module.context.getters
      }
      // 调用val或获取state
      return typeof val === 'function'
        ? val.call(this, state, getters)
        : state[val]
    }
    // mark vuex getter for devtools
    res[key].vuex = true
  })
</code></pre>
<pre><code class="language-javascript">function getModuleByNamespace (store, helper, namespace) {
   // _modulesNamespaceMap属性是不是很眼熟？
   // 它是在Store类的installModule方法中使用到，记录了namespace对应的module 
  const module = store._modulesNamespaceMap[namespace]
  if (process.env.NODE_ENV !== 'production' &amp;&amp; !module) {
    console.error(`[vuex] module namespace not found in ${helper}(): ${namespace}`)
  }
  return module
}
</code></pre>
<p>上面这些代码有几个注意点</p>
<ol>
<li>
<p><code>getModuleByNamespace</code>方法中的<code>store._modulesNamespaceMap[namespace]</code>是在<code>installModules</code>中进行的初始化</p>
</li>
<li>
<p><code>mapState</code>是可以传入回调函数的</p>
<pre><code>{
  computed: mapState({
    // 箭头函数可使代码更简练
    count: state =&gt; state.count,

    // 传字符串参数 'count' 等同于 `state =&gt; state.count`
    countAlias: 'count',

    // 为了能够使用 `this` 获取局部状态，必须使用常规函数
    countPlusLocalState (state) {
      return state.count + this.localCount
    }
  })
}
</code></pre>
</li>
</ol>
<h4 id="mapmutations">mapMutations</h4>
<pre><code class="language-javascript">export const mapMutations = normalizeNamespace((namespace, mutations) =&gt; {
  const res = {}
  normalizeMap(mutations).forEach(({ key, val }) =&gt; {
    res[key] = function mappedMutation (...args) {
      // Get the commit method from store
      let commit = this.$store.commit
      if (namespace) {
        const module = getModuleByNamespace(this.$store, 'mapMutations', namespace)
        if (!module) {
          return
        }
        commit = module.context.commit
      }
      return typeof val === 'function'
        ? val.apply(this, [commit].concat(args))
        : commit.apply(this.$store, [val].concat(args))
    }
  })
  return res
})
</code></pre>
<p>其他相同的代码就不讲了，关键看下面的</p>
<pre><code class="language-javascript">    res[key] = function mappedMutation (...args) {
      // Get the commit method from store
      let commit = this.$store.commit
      if (namespace) {
        const module = getModuleByNamespace(this.$store, 'mapMutations', namespace)
        if (!module) {
          return
        }
        commit = module.context.commit
      }
      return typeof val === 'function'
        ? val.apply(this, [commit].concat(args))
        : commit.apply(this.$store, [val].concat(args))
    }
</code></pre>
<p>这段代码其实和<code>mapState</code>里的相差不大，都是获取到<code>commit</code>,如果有<code>namespace</code>就获取模块里的<code>commit</code>,最后调用<code>commit</code>,它也可以传入一个回调函数,不过，举个例子</p>
<pre><code class="language-javascript">methods: {
	...mapMutations(['increment']),
	//等价于
	...mapMutations({
		add: function(commit, ...args){
		   commit('increment', ...args)
	    }
	}),
     // 等价于
    ...mapMutations({
      add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')`
    })
}
// 组件中调用
this.add(1)
</code></pre>
<h4 id="mapgetters">mapGetters</h4>
<pre><code class="language-javascript">export const mapGetters = normalizeNamespace((namespace, getters) =&gt; {
  const res = {}
  normalizeMap(getters).forEach(({ key, val }) =&gt; {
    // The namespace has been mutated by normalizeNamespace
    val = namespace + val
    res[key] = function mappedGetter () {
        // 如果namespace存在但是没有找到对应的模块 就直接返回，不做处理
      if (namespace &amp;&amp; !getModuleByNamespace(this.$store, 'mapGetters', namespace)) {
        return
      }
      // 如果没有找到对应的getter会报错并返回
      if (process.env.NODE_ENV !== 'production' &amp;&amp; !(val in this.$store.getters)) {
        console.error(`[vuex] unknown getter: ${val}`)
        return
      }
      
      return this.$store.getters[val]
    }
    // mark vuex getter for devtools
    res[key].vuex = true
  })
  return res
})
</code></pre>
<p>mapGetters和其它实现有所区别</p>
<ol>
<li>
<p>所有模块的<code>getters</code>都被代理在<code>store</code>对象中，所以直接使用<code>getter</code>的<code>key</code>和<code>namespace</code>拼接获取到对应的<code>getter</code>；具体在哪代理可以参见</p>
<pre><code class="language-javascript">// store.js 的makeLocalContext方法里的实现
Object.defineProperties(local, {
    getters: {
      get: noNamespace
        ? () =&gt; store.getters
        : () =&gt; makeLocalGetters(store, namespace)
    },
    state: {
      get: () =&gt; getNestedState(store.state, path)
    }
  })
</code></pre>
</li>
<li>
<p><code>getter</code>不支持传入函数</p>
</li>
</ol>
<h4 id="mapactions">mapActions</h4>
<pre><code class="language-javascript">export const mapActions = normalizeNamespace((namespace, actions) =&gt; {
  const res = {}
  normalizeMap(actions).forEach(({ key, val }) =&gt; {
    res[key] = function mappedAction (...args) {
      // get dispatch function from store
      let dispatch = this.$store.dispatch
      if (namespace) {
        const module = getModuleByNamespace(this.$store, 'mapActions', namespace)
        if (!module) {
          return
        }
        dispatch = module.context.dispatch
      }
      return typeof val === 'function'
        ? val.apply(this, [dispatch].concat(args))
        : dispatch.apply(this.$store, [val].concat(args))
    }
  })
  return res
})
</code></pre>
<p><code>mapActions</code>的实现和<code>mutation</code>的实现一模一样？确实是这样。。。下面只说下用法</p>
<pre><code class="language-javascript">methods: {
	...mapActions(['increment']),
	//等价于
	...mapActions({
		add: function(dispatch, ...args){
		   dispatch('increment', ...args)
	    }
	}),
     // 等价于
    ...mapActions({
      add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')`
    })
}
// 组件中调用
this.add(1)
</code></pre>
<h4 id="createnamespacedhelpers">createNamespacedHelpers</h4>
<pre><code class="language-javascript">export const createNamespacedHelpers = (namespace) =&gt; ({
  mapState: mapState.bind(null, namespace),
  mapGetters: mapGetters.bind(null, namespace),
  mapMutations: mapMutations.bind(null, namespace),
  mapActions: mapActions.bind(null, namespace)
})
</code></pre>
<p>官方例子</p>
<pre><code class="language-javascript">import { createNamespacedHelpers } from 'vuex'

const { mapState, mapActions } = createNamespacedHelpers('some/nested/module')

export default {
  computed: {
    // 在 `some/nested/module` 中查找
    ...mapState({
      a: state =&gt; state.a,
      b: state =&gt; state.b
    })
  },
  methods: {
    // 在 `some/nested/module` 中查找
    ...mapActions([
      'foo',
      'bar'
    ])
  }
}
</code></pre>
<p>对于这个<code>createNamespacedHelpers</code>如何实现，我想大家应该看的懂吧</p>
<h2 id="总结">总结</h2>
<p>终于分析完了<code>Vuex</code>的源码，完成这篇文章也是没事抽出空闲时间写出来的，可能会有错别字，分析错误或者有些我不知道的，欢迎大家指正，阅读源码也使我学到了很多东西，让我从陌生，逐渐开始得心应手，一直到现在，我对于源码不再是单纯的为了面试，而是一种兴趣，谢谢大家观看</p>
<h2 id="下一章">下一章</h2>
<p>逐行级源码分析系列(二) Redux和React-Redux源码（正在写作）</p>
<p>未完待续。。。</p>
]]></content>
    </entry>
</feed>