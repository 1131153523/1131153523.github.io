<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>逐行级源码分析系列(二)  Redux和React-Redux源码 | </title>
<meta name="description" content="温故而知新" />
<link rel="shortcut icon" href="https://1131153523.github.io/favicon.ico?v=1565410171978">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://1131153523.github.io/styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://1131153523.github.io">
  <img class="avatar" src="https://1131153523.github.io/images/avatar.png?v=1565410171978" alt="">
  </a>
  <h1 class="site-title">
    
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              逐行级源码分析系列(二)  Redux和React-Redux源码
            </h2>
            <div class="post-info">
              <span>
                2019-08-10
              </span>
              <span>
                34 min read
              </span>
              
            </div>
            
              <img class="post-feature-image" src="https://camo.githubusercontent.com/f28b5bc7822f1b7bb28a96d8d09e7d79169248fc/687474703a2f2f692e696d6775722e636f6d2f4a65567164514d2e706e67" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h2 id="前言">前言</h2>
<p>因为最近忙于秋招，平时只是花费空闲时间来写这篇博客，所以有些地方可能讲的不是很好，也不详细，现在看来不知道算不算是逐行了，希望大家能谅解，我一定会坚持写完这个系列。。</p>
<p>万字长文，大家谨慎观看</p>
<h2 id="系列文章">系列文章</h2>
<ul>
<li><a href="https://juejin.im/post/5d398f37e51d45106b15fff4">逐行级源码分析系列(一) Vuex</a></li>
<li><a href="https://juejin.im/post/5d4e38db5188251f6b1ef99b">逐行级源码分析系列(二)  Redux和React-Redux源码</a></li>
<li>逐行级源码分析系列(三) Vue-Router源码</li>
<li>逐行级源码分析系列(四) React-Router-Dom源码</li>
<li>逐行级源码分析系列(五) Express源码</li>
<li>逐行级源码分析系列(六) Koa核心源码</li>
<li>逐行级源码分析系列(六) Typescript版Axios源码</li>
</ul>
<h2 id="redux">Redux</h2>
<h3 id="一个例子">一个例子</h3>
<p>在看<code>redux</code>源码前，必须要理解的是发布订阅模式，下面我会用一个例子来实现一个简易版<code>redux</code>,方便大家理解</p>
<pre><code class="language-javascript">
const reducer = function(state = { count: 1 }, action) {
    switch(action.type) {
        case 'INCREMENT':
            return {
                ...state,
                count: count + 1
            }
        default:
            return state
    }
}

const createStore = function(reducer, preloadedState) {
    // 监听者数组
    const listeners = []
    // 如果有设置好的state,设置当前state
    let currentState = preloadedState
    const subscribe = function(fn) {
        listeners.push(fn)
        // 返回一个能取消订阅的函数
        return function() {
            const index = listeners.indexOf(fn)
            listeners.splice(index, 1)
        }
    }
    // 获取当前state
    const getState = function() {
        return currentState
    }
    
    const dispatch = function(action) {
        // 调用reducer，将新的state,替换掉当前的state
    	currentState = reducer(currentState, action)
        // 循环调用监听函数
        for (let i = 0;i &lt; listeners.length;i++) {
            let listener = listeners[i]
            listener()
        }
        return action
    }
    // 初始化
    dispatch({ type: ActionTypes.INIT })
    return {
        getState,
        subscribe,
        dispatch
    }
}
</code></pre>
<p>在react中使用</p>
<pre><code class="language-javascript">const store = createStore(reducer)
class App extends React.Component {
    constructor(props) {
        super(props)
        this.state = {
            store,
            count: 1
        }
    }
    componentWillMount() {
        // 当点击按钮之后，调用dispatch更新状态，然后调用订阅的监听函数，更新state
        // 在真正的react-redux中使用的其实是context来保存store
        this.state.store.subscribe(() =&gt; {
            this.setState({
                count: this.state.store.getState().count
            })
        })
    }
    handleClick = () =&gt; {
        this.state.store.dispatch({ type: 'INCREMENT' })
    }
    render() {
        return (
            &lt;div&gt;
                 &lt;button onClick={this.handleClick}&gt;&lt;/button&gt;
            	{ this.state.count }
            &lt;/div&gt;
        )
    }
}

</code></pre>
<p>看完上面的代码相信大家对<code>redux</code>会有一个比较深刻的认识，接下来我将根据源码来讲解</p>
<h3 id="入口">入口</h3>
<pre><code class="language-javascript">import createStore from './createStore'
import combineReducers from './combineReducers'
import bindActionCreators from './bindActionCreators'
import applyMiddleware from './applyMiddleware'
import compose from './compose'
import warning from './utils/warning'
import __DO_NOT_USE__ActionTypes from './utils/actionTypes'

/*
 * This is a dummy function to check if the function name has been altered by minification.
 * If the function has been minified and NODE_ENV !== 'production', warn the user.
 */
function isCrushed() {}

if (
  process.env.NODE_ENV !== 'production' &amp;&amp;
  typeof isCrushed.name === 'string' &amp;&amp;
  isCrushed.name !== 'isCrushed'
) {
  warning(
    'You are currently using minified code outside of NODE_ENV === &quot;production&quot;. ' +
      'This means that you are running a slower development build of Redux. ' +
      'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' +
      'or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) ' +
      'to ensure you have the correct code for your production build.'
  )
}

export {
  createStore,
  combineReducers,
  bindActionCreators,
  applyMiddleware,
  compose,
  __DO_NOT_USE__ActionTypes
}

</code></pre>
<p>入口代码其实非常简单，导出了一些方法,下面我们逐个分析</p>
<h3 id="createstore">createStore</h3>
<p>定位到<code>createStore.js</code>文件</p>
<p>首先我们分析以下这个方法的参数</p>
<pre><code class="language-javascript">export default function createStore(reducer, preloadedState, enhancer) {}
</code></pre>
<ul>
<li>
<p>reducer</p>
<p><strong>reducer函数</strong></p>
</li>
<li>
<p>preloadedState</p>
<p><strong>初始的state,可选参数</strong></p>
</li>
<li>
<p>enhancer</p>
<p><strong>它其实是<code>applyMiddleware</code>函数，这个函数很重要，以后也会讲到</strong></p>
</li>
</ul>
<p><strong>createStore返回的方法:</strong></p>
<ul>
<li>
<p>getState</p>
</li>
<li>
<p>subscribe</p>
</li>
<li>
<p>dispatch</p>
</li>
<li>
<p>replaceReducer</p>
</li>
<li></li>
</ul>
<p>讲完参数和返回值，继续看</p>
<pre><code class="language-javascript">  if (
    (typeof preloadedState === 'function' &amp;&amp; typeof enhancer === 'function') ||
    (typeof enhancer === 'function' &amp;&amp; typeof arguments[3] === 'function')
  ) {
    throw new Error(
      'It looks like you are passing several store enhancers to ' +
        'createStore(). This is not supported. Instead, compose them ' +
        'together to a single function.'
    )
  }
</code></pre>
<p>判断如果<code>preloadedState</code>是一个函数并且<code>enhancer</code>也是一个函数，就会抛出异常或者存在第四个参数是一个函数，也会抛出错误</p>
<pre><code class="language-javascript">  if (typeof preloadedState === 'function' &amp;&amp; typeof enhancer === 'undefined') {
    enhancer = preloadedState
    preloadedState = undefined
  }
</code></pre>
<p>对参数进行重载，如果我们只是用了<code>reducer</code>和<code>enhancer</code>，那么会对参数进行处理</p>
<p>然后是下面这段代码，也非常重要</p>
<pre><code class="language-javascript">  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error('Expected the enhancer to be a function.')
    }

    return enhancer(createStore)(reducer, preloadedState)
  }

</code></pre>
<p>这段代码实际上执行了<code>applyMiddleware</code>函数，在其中，使用中间件对<code>dispatch</code>进行了包装，返回了新的<code>store</code>,这个以后会讲到，这里提前剧透一点</p>
<pre><code class="language-javascript">export default function applyMiddleware(...middlewares) {
  return createStore =&gt; (...args) =&gt; {

    return {
      ...store,
      dispatch
    }
  }
}

</code></pre>
<p>可以看到，返回了新的<code>store</code></p>
<p>然后我们继续来看</p>
<pre><code class="language-javascript">  // 获取reducer
  let currentReducer = reducer   // 记录当前的reducer
  let currentState = preloadedState  // 记录当前state

  let currentListeners = []    // 记录监听函数
  let nextListeners = currentListeners  // 最新的Listeners

  // 是否正在Dispatch
  let isDispatching = false
</code></pre>
<p>这里初始化了一些变量，其作用不必多说，在继续后面的代码之前，大家回忆一下之前的例子，<code>createStore</code>返回了哪些方法，没错就是<code>getState</code>,<code>dispatch</code>,<code>subscribe</code>，其实并不止这些，还有<code>replaceReducer</code>以及<code>observable</code>,下面我将依次分析其源码</p>
<h4 id="getstate">getState</h4>
<pre><code class="language-javascript">  function getState() {

    // isDispatching为false不能获取当前state
    if (isDispatching) {
      throw new Error(
        'You may not call store.getState() while the reducer is executing. ' +
          'The reducer has already received the state as an argument. ' +
          'Pass it down from the top reducer instead of reading it from the store.'
      )
    }

    return currentState
  }
</code></pre>
<p>很简洁的代码，首先判断是否正在<code>dispatch</code>，如果是就会抛出异常，否则正常返回<code>currentState</code>,也就是当前最新的<code>state</code></p>
<h4 id="subscribe">subscribe</h4>
<pre><code class="language-javascript">  function subscribe(listener) {
    if (typeof listener !== 'function') {
      throw new Error('Expected the listener to be a function.')
    }

    if (isDispatching) {
      throw new Error(
        'You may not call store.subscribe() while the reducer is executing. ' +
          'If you would like to be notified after the store has been updated, subscribe from a ' +
          'component and invoke store.getState() in the callback to access the latest state. ' +
          'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.'
      )
    }

    let isSubscribed = true

    ensureCanMutateNextListeners()
    nextListeners.push(listener)

    return function unsubscribe() {
      if (!isSubscribed) {
        return
      }

      if (isDispatching) {
        throw new Error(
          'You may not unsubscribe from a store listener while the reducer is executing. ' +
            'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.'
        )
      }

      isSubscribed = false

      ensureCanMutateNextListeners()
      const index = nextListeners.indexOf(listener)
      nextListeners.splice(index, 1)
      currentListeners = null
    }
  }
</code></pre>
<p>第一个判断，确保传入的<code>listener</code>存在，第二个判断，确保能够正在<code>dispatch</code>的时候，不会<code>subscribe</code></p>
<pre><code class="language-javascript"> let isSubscribed = true
</code></pre>
<p>然后定义了一个变量，表示是否被订阅，因为如果没有被订阅，那么在调用<code>unsubscribe</code>也就是取消订阅是完全没有必要的，所以如果在<code>unsubscribe</code>中，检测到并没有被订阅，就会直接返回，不做处理</p>
<pre><code class="language-javascript">ensureCanMutateNextListeners()

function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice()
    }
}

</code></pre>
<p>然后这段代码主要是用来防止在订阅和取消订阅时出现一些问题，确保能够改变<code>nextListeners</code></p>
<pre><code class="language-javascript">nextListeners.push(listener)
</code></pre>
<p>最后把监听函数放在了<code>nextListeners</code>数组中，随后返回<code>unsubscribe</code></p>
<pre><code class="language-javascript">    return function unsubscribe() {
      if (!isSubscribed) {
        return
      }

      if (isDispatching) {
        throw new Error(
          'You may not unsubscribe from a store listener while the reducer is executing. ' +
            'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.'
        )
      }

      isSubscribed = false

      ensureCanMutateNextListeners()
      const index = nextListeners.indexOf(listener)
      nextListeners.splice(index, 1)
      currentListeners = null
    }
</code></pre>
<p>其实也是利用了闭包的特点，能够把监听函数保留在内存中</p>
<h4 id="dispatch">dispatch</h4>
<pre><code class="language-javascript">  function dispatch(action) {
    if (!isPlainObject(action)) {
      throw new Error(
        'Actions must be plain objects. ' +
          'Use custom middleware for async actions.'
      )
    }

    if (typeof action.type === 'undefined') {
      throw new Error(
        'Actions may not have an undefined &quot;type&quot; property. ' +
          'Have you misspelled a constant?'
      )
    }

    if (isDispatching) {
      throw new Error('Reducers may not dispatch actions.')
    }

    try {
      isDispatching = true
      currentState = currentReducer(currentState, action)
    } finally {
      isDispatching = false
    }

    const listeners = (currentListeners = nextListeners)
    for (let i = 0; i &lt; listeners.length; i++) {
      const listener = listeners[i]
      listener()
    }

    return action
  }
</code></pre>
<p>第一个判断<code>action</code>是否是一个对象，否则报错</p>
<p>第二个判断<code>action</code>中的类型是否存在，如果不存在也会报错</p>
<p>第三个判断，保证不会再<code>dispatch</code>的时候再<code>dispatch</code>防止出现一些无法预估的问题</p>
<p>这个方法我把它缩短点，大家就能看懂了</p>
<pre><code class="language-javascript">  function dispatch(action) {
    try {
      isDispatching = true
      currentState = currentReducer(currentState, action)
    } finally {
      isDispatching = false
    }
    const listeners = (currentListeners = nextListeners)
    for (let i = 0; i &lt; listeners.length; i++) {
      const listener = listeners[i]
      listener()
    }

    return action
  }
</code></pre>
<p>对于<code>currentReducer</code>的调用前后设置了不同的状态，给<code>currentReducer</code>函数传入了当前的<code>state</code>和<code>action</code>，然后拿到返回的新的<code>state</code>，替换掉原本的<code>state</code>,也就是<code>currentState</code>。随后依次调用<code>nextListeners</code>数组中存方的监听函数</p>
<h4 id="replacereducer">replaceReducer</h4>
<p>按照字面意思就知道是替换掉原本的<code>reducer</code>,我们看一下其实现</p>
<pre><code class="language-javascript">  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== 'function') {
      throw new Error('Expected the nextReducer to be a function.')
    }

    currentReducer = nextReducer

    // This action has a similiar effect to ActionTypes.INIT.
    // Any reducers that existed in both the new and old rootReducer
    // will receive the previous state. This effectively populates
    // the new state tree with any relevant data from the old one.
    dispatch({ type: ActionTypes.REPLACE })
  }
</code></pre>
<p>如果传入的新的<code>reducer</code>不存在就会报错</p>
<p>直接使用新的<code>reducer</code>替换掉了原本的<code>currentReducer</code>,然后调用<code>dispatch({ type: ActionTypes.REPLACE })</code>,初始化，相当于调用了<code>reducer</code>重置了<code>currentState</code>,至于<code>ActionTypes</code>其实是记录了一些状态</p>
<h4 id="observable">observable</h4>
<pre><code class="language-javascript">  function observable() {
    const outerSubscribe = subscribe
    return {
      subscribe(observer) {
        if (typeof observer !== 'object' || observer === null) {
          throw new TypeError('Expected the observer to be an object.')
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState())
          }
        }

        observeState()
        const unsubscribe = outerSubscribe(observeState)
        return { unsubscribe }
      },

      [$$observable]() {
        return this
      }
    }
  }
</code></pre>
<p><code>observable</code>函数是为<code>observable/reactive</code>库预留的交互接口，下面举个<code>Rxjs的Observable</code>例子</p>
<pre><code class="language-javascript">const observable = Rx.Observable.create(observer =&gt; {
  const id = setTimeout(() =&gt; observer.next('...'), 5000); // emit value after 5s

  return () =&gt; { clearTimeout(id); console.log('cleared!'); };
});

const subscription = observable.subscribe(value =&gt; console.log(value));

setTimeout(() =&gt; subscription.unsubscribe(), 3000); // cancel subscription after 3s

</code></pre>
<pre><code class="language-javascript">const outerSubscribe = subscribe
</code></pre>
<p>首先保留原本的<code>subscribe</code></p>
<p>然后返回了一个对象</p>
<pre><code class="language-javascript">    return {
      subscribe(observer) {
        if (typeof observer !== 'object' || observer === null) {
          throw new TypeError('Expected the observer to be an object.')
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState())
          }
        }

        observeState()
        const unsubscribe = outerSubscribe(observeState)
        return { unsubscribe }
      },

      [$$observable]() {
        return this
      }
    }
</code></pre>
<p><code>subscribe</code>中第一个判断：observer参数必须是一个对象，否则抛出异常</p>
<pre><code class="language-javascript">        function observeState() {
          if (observer.next) {
            observer.next(getState())
          }
        }
        observeState()
</code></pre>
<p>创建了一个状态变更函数，把<code>state</code>传给了<code>observer</code>,然后立即执行<code>observeState</code>函数</p>
<pre><code class="language-javascript">      [$$observable]() {
        return this
      }
</code></pre>
<p>这个函数使用来返回<code>observable</code>对象</p>
<pre><code class="language-javascript">export default function createStore(reducer, preloadedState, enhancer) {
    
    // ...一些方法
    
  dispatch({ type: ActionTypes.INIT })

  return {
    dispatch,
    subscribe,
    getState,
    replaceReducer,
    [$$observable]: observable
  }
}
</code></pre>
<p>最后调用一次<code>dispatch</code>，为什么要单独调用一次呢，其实是为了初始化<code>currentState</code>,大家可以想象以下，调用<code>dispatch</code>之后会发生什么，由于我们并没有传入<code>preloadedState</code>，所以此时的<code>currentState</code>是<code>undefined</code>,调用<code>dispatch</code>之后它会调用<code>reducer</code>，返回一个我们自己的默认<code>state</code>(注意：<code>{ type: ActionTypes.INIT }</code>其实没有任何用处，只是一种标识)</p>
<pre><code class="language-javascript"> // dispatch方法    
    try {
      isDispatching = true
      currentState = currentReducer(currentState, action)
    } finally {
      isDispatching = false
    }
</code></pre>
<p>大家看到上面的代码，相信应该能明白了吧，关于<code>createStore</code>函数的介绍就到这里了</p>
<h3 id="bindactioncreators">bindActionCreators</h3>
<p>我们直接来看下，这个函数的实现，它也是在一个单独的文件<code>bindActionCreators.js</code></p>
<pre><code class="language-javascript">function bindActionCreator(actionCreator, dispatch) {
  return function() {
    return dispatch(actionCreator.apply(this, arguments))
  }
}
</code></pre>
<p>这个文件中，有一个内部的私有方法<code>bindActionCreator</code>,它和<code>bindActionCreators</code>的唯一区别就是少了一个字母，其实它就是用来单独处理<code>action</code>和<code>dispatch</code>之间的绑定，它利用了闭包的特性，返回了一个新的函数，直接调用就相当于调用了<code>dispatch</code></p>
<pre><code class="language-javascript">export default function bindActionCreators(actionCreators, dispatch) {
  if (typeof actionCreators === 'function') {
    return bindActionCreator(actionCreators, dispatch)
  }

  if (typeof actionCreators !== 'object' || actionCreators === null) {
    throw new Error(
      `bindActionCreators expected an object or a function, instead received ${
        actionCreators === null ? 'null' : typeof actionCreators
      }. ` +
        `Did you write &quot;import ActionCreators from&quot; instead of &quot;import * as ActionCreators from&quot;?`
    )
  }

  const boundActionCreators = {}
  for (const key in actionCreators) {
    const actionCreator = actionCreators[key]
    if (typeof actionCreator === 'function') {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)
    }
  }
  return boundActionCreators
}

</code></pre>
<p>然后我们再来看<code>bindActionCreators</code>,他的第一个参数是一个由<code>actionCreator</code>组成的对象，第二个参数就是<code>dispatch</code>方法</p>
<p>第一个判断：如果只传入了一个<code>actionCreator</code>，直接调用<code>bindActionCreator</code>,返回一个函数</p>
<p>第二个判断：如果<code>actionCreators</code>不是对象，或者传入的是<code>undefined</code>，<code>null</code>就会抛出错误</p>
<pre><code class="language-javascript">  const boundActionCreators = {}
  for (const key in actionCreators) {
    const actionCreator = actionCreators[key]
    if (typeof actionCreator === 'function') {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)
    }
  }
  return boundActionCreators
</code></pre>
<p>然后是这段代码，他会遍历所有的<code>actionCreator</code>,把<code>actionCreator</code>的键作为，<code>boundActionCreators</code>对象中的一个键，并调用<code>bindActionCreator</code>对每个<code>actionCreator</code>进行处理，把处理返回的函数，作为<code>boundActionCreators</code>对象中的键的值，类似这样</p>
<pre><code class="language-javascript">{
	incrementAction(){
		return {
			type: 'INCREMENT'
		}
	},
	decrementAction(){
		return {
			type: 'DECREMENT'
		}
	}
}
// 经过bindActionCreators处理
{
	incrementAction: function() {
		dispatch(incrementAction())
	},
	decrementAction: function() {
		dispatch(decrementAction())
	}
}


// 原本我们要这么用
store.dispatch(incrementAction())

// 现在
incrementAction()
</code></pre>
<p>怎么样是不是很方便！</p>
<p>ok，现在bindActionCreators我们也讲解完了</p>
<h3 id="combinereducers">combineReducers</h3>
<p>这个函数的实现也是在一个单独文件里，它里面也有很多内置函数，因为内容比较多，我们一开始只展示一部分</p>
<pre><code class="language-javascript">export default function combineReducers(reducers) {
  const reducerKeys = Object.keys(reducers)
  const finalReducers = {}
  for (let i = 0; i &lt; reducerKeys.length; i++) {
    const key = reducerKeys[i]

    if (process.env.NODE_ENV !== 'production') {
      if (typeof reducers[key] === 'undefined') {
        warning(`No reducer provided for key &quot;${key}&quot;`)
      }
    }

    if (typeof reducers[key] === 'function') {
      finalReducers[key] = reducers[key]
    }
  }
  const finalReducerKeys = Object.keys(finalReducers)

  // This is used to make sure we don't warn about the same
  // keys multiple times.
  let unexpectedKeyCache
  if (process.env.NODE_ENV !== 'production') {
    unexpectedKeyCache = {}
  }

  let shapeAssertionError
  try {
    assertReducerShape(finalReducers)
  } catch (e) {
    shapeAssertionError = e
  }

  return function combination(state = {}, action) {
    if (shapeAssertionError) {
      throw shapeAssertionError
    }

    if (process.env.NODE_ENV !== 'production') {
      const warningMessage = getUnexpectedStateShapeWarningMessage(
        state,
        finalReducers,
        action,
        unexpectedKeyCache
      )
      if (warningMessage) {
        warning(warningMessage)
      }
    }

    let hasChanged = false
    const nextState = {}
    for (let i = 0; i &lt; finalReducerKeys.length; i++) {
      const key = finalReducerKeys[i]
      const reducer = finalReducers[key]
      const previousStateForKey = state[key]
      const nextStateForKey = reducer(previousStateForKey, action)
      if (typeof nextStateForKey === 'undefined') {
        const errorMessage = getUndefinedStateErrorMessage(key, action)
        throw new Error(errorMessage)
      }
      nextState[key] = nextStateForKey
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey
    }
    return hasChanged ? nextState : state
  }
}

</code></pre>
<p>首先只要用过<code>combineReducers</code>函数，大家都知道，<code>combineReducers</code>返回的是一个新的<code>reducer</code>,那么它是怎么实现，把<code>action</code>分发到不同的<code>reducer</code>，大家可以先思考一下</p>
<p>仔细想一想，还是挺好实现的，其实就是循环调用每个<code>reducer</code>，传入<code>action</code>,我们知道<code>reducer</code>里面是有<code>switch</code>语句的，它是一个纯函数，不会造成其他的副作用，所以一定会有对应的<code>action</code>会被触发，下面我们具体分析</p>
<pre><code class="language-javascript">  const reducerKeys = Object.keys(reducers)
  const finalReducers = {}
  for (let i = 0; i &lt; reducerKeys.length; i++) {
    const key = reducerKeys[i]

    if (process.env.NODE_ENV !== 'production') {
      if (typeof reducers[key] === 'undefined') {
        warning(`No reducer provided for key &quot;${key}&quot;`)
      }
    }

    if (typeof reducers[key] === 'function') {
      finalReducers[key] = reducers[key]
    }
  }
</code></pre>
<p>首先是拿到了所有的<code>reducer</code>函数，获取到它的<code>keys</code>,根据<code>key</code>值，遍历所有的<code>reducer</code></p>
<p>第一个判断：<code>reducer</code>是否是函数，是否不存在，如果都不成立就报出警告</p>
<p>第二个判断：相当于一层过滤，防止有不是函数的<code>reducer</code>，然后把正确的<code>reducer</code>放在了一个新对象<code>finalReducers</code>中</p>
<pre><code class="language-javascript">  const finalReducerKeys = Object.keys(finalReducers)

  // This is used to make sure we don't warn about the same
  // keys multiple times.
  let unexpectedKeyCache
  if (process.env.NODE_ENV !== 'production') {
    unexpectedKeyCache = {}
  }
  let shapeAssertionError
  try {
    assertReducerShape(finalReducers)
  } catch (e) {
    shapeAssertionError = e
  }
</code></pre>
<p>首先获取到<code>reducer</code>的<code>keys</code>数组，这个暂时不讲，后面有用到，大家先留个印象，然后再开发环境，创建了一个<code>unexpectedKeyCache</code>对象，然后在后面又调用了<code>assertReducerShape(finalReducers)</code>函数，它的实现如下</p>
<pre><code class="language-javascript">function assertReducerShape(reducers) {
  Object.keys(reducers).forEach(key =&gt; {
    const reducer = reducers[key]
    const initialState = reducer(undefined, { type: ActionTypes.INIT })
    if (typeof initialState === 'undefined') {
      throw new Error(
        `Reducer &quot;${key}&quot; returned undefined during initialization. ` +
          `If the state passed to the reducer is undefined, you must ` +
          `explicitly return the initial state. The initial state may ` +
          `not be undefined. If you don't want to set a value for this reducer, ` +
          `you can use null instead of undefined.`
      )
    }

    if (
      typeof reducer(undefined, {
        type: ActionTypes.PROBE_UNKNOWN_ACTION()
      }) === 'undefined'
    ) {
      throw new Error(
        `Reducer &quot;${key}&quot; returned undefined when probed with a random type. ` +
          `Don't try to handle ${ActionTypes.INIT} or other actions in &quot;redux/*&quot; ` +
          `namespace. They are considered private. Instead, you must return the ` +
          `current state for any unknown actions, unless it is undefined, ` +
          `in which case you must return the initial state, regardless of the ` +
          `action type. The initial state may not be undefined, but can be null.`
      )
    }
  })
}
</code></pre>
<p>整个函数所做的事还是挺简单的，遍历了所有的<code>reducer</code>,然后调用<code>reducer</code>，判断它的返回值，如果为<code>undefined</code>就抛出错误，一般来说这种报错都是我们没有设置<code>state</code>默认值或者在<code>switch</code>中没有<code>default</code>默认返回<code>state</code></p>
<p>我们回到刚才的讲解,大家应该还记得<code>shapeAssertionError</code>这个变量吧,如果我们在<code>reducer</code>中没有返回默认值，就会把错误记录在这个变量中，然后我们继续看<code>combineReducers</code>返回的函数</p>
<pre><code class="language-javascript">export default function combineReducers(reducers) {
  // .. .....
  
  return function combination(state = {}, action) {
    if (shapeAssertionError) {
      throw shapeAssertionError
    }

    if (process.env.NODE_ENV !== 'production') {
      const warningMessage = getUnexpectedStateShapeWarningMessage(
        state,
        finalReducers,
        action,
        unexpectedKeyCache
      )
      if (warningMessage) {
        warning(warningMessage)
      }
    }

    let hasChanged = false
    const nextState = {}
    for (let i = 0; i &lt; finalReducerKeys.length; i++) {
      const key = finalReducerKeys[i]
      const reducer = finalReducers[key]
      const previousStateForKey = state[key]
      const nextStateForKey = reducer(previousStateForKey, action)
      if (typeof nextStateForKey === 'undefined') {
        const errorMessage = getUndefinedStateErrorMessage(key, action)
        throw new Error(errorMessage)
      }
      nextState[key] = nextStateForKey
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey
    }
    return hasChanged ? nextState : state
  }
}
</code></pre>
<p>从它的参数来看，就是一个<code>reducer</code>所具备的参数</p>
<p>第一个判断：<code>shapeAssertionError</code>如果存在就抛出错误，这个刚刚我们讲过</p>
<p>第二个判断：如果在开发环境，就调用<code>getUnexpectedStateShapeWarningMessage</code>函数，从这个函数的字面意思相信大家都知道了，获取不在预期形式<code>state</code>的警号信息，没错就是用来获取警告信息，然后判断警告信息如果存在就在开发环境警告,具体看下<code>getUnexpectedStateShapeWarningMessage</code>函数实现,因为内容实在太多，而且并不是很重要，我就把讲解写在注释中</p>
<pre><code class="language-javascript">// 调用
const warningMessage = getUnexpectedStateShapeWarningMessage(
   state,  // 传入reducer的默认state
   finalReducers,  // reducers对象
   action, 
   unexpectedKeyCache  // 一个空对象
)
</code></pre>
<pre><code class="language-javascript">// 实现
function getUnexpectedStateShapeWarningMessage(
  inputState,
  reducers,
  action,
  unexpectedKeyCache
) {
  // 获取reducers中的keys
  const reducerKeys = Object.keys(reducers)
  const argumentName =
    action &amp;&amp; action.type === ActionTypes.INIT
      ? 'preloadedState argument passed to createStore'
      : 'previous state received by the reducer'
  
  
  // 如果我们调用combineReducers但是没有传入任何reducer就会直接返回错误信息
  if (reducerKeys.length === 0) {
    return (
      'Store does not have a valid reducer. Make sure the argument passed ' +
      'to combineReducers is an object whose values are reducers.'
    )
  }

   // 如果state不是一个对象，就返回错误信息
  if (!isPlainObject(inputState)) {
    return (
      `The ${argumentName} has unexpected type of &quot;` +
      {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] +
      `&quot;. Expected argument to be an object with the following ` +
      `keys: &quot;${reducerKeys.join('&quot;, &quot;')}&quot;`
    )
  }
// 给state中存在而reducer中不存在的属性添加缓存标识
  const unexpectedKeys = Object.keys(inputState).filter(
    key =&gt; !reducers.hasOwnProperty(key) &amp;&amp; !unexpectedKeyCache[key]
  )
  // 设置缓存
  unexpectedKeys.forEach(key =&gt; {
    unexpectedKeyCache[key] = true
  })
// 如果调用replaceReducer会触发这里的返回，详细参见replaceReducer具体实现
  if (action &amp;&amp; action.type === ActionTypes.REPLACE) return
  // 如果unexpectedKeys有内容就返回错误信息
  if (unexpectedKeys.length &gt; 0) {
    return (
      `Unexpected ${unexpectedKeys.length &gt; 1 ? 'keys' : 'key'} ` +
      `&quot;${unexpectedKeys.join('&quot;, &quot;')}&quot; found in ${argumentName}. ` +
      `Expected to find one of the known reducer keys instead: ` +
      `&quot;${reducerKeys.join('&quot;, &quot;')}&quot;. Unexpected keys will be ignored.`
    )
  }
}
</code></pre>
<p>讲完这些，我们看最后的一些代码</p>
<pre><code class="language-javascript">    let hasChanged = false
    const nextState = {}
    for (let i = 0; i &lt; finalReducerKeys.length; i++) {
      const key = finalReducerKeys[i]
      const reducer = finalReducers[key]
      const previousStateForKey = state[key]
      const nextStateForKey = reducer(previousStateForKey, action)
      if (typeof nextStateForKey === 'undefined') {
        const errorMessage = getUndefinedStateErrorMessage(key, action)
        throw new Error(errorMessage)
      }
      nextState[key] = nextStateForKey
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey
    }
    return hasChanged ? nextState : state
</code></pre>
<p>简单来讲，本质上还是调用了<code>reducer</code>,而且是调用了每个<code>reducer</code></p>
<p><code>hasChanged</code>用于判断，如果前后值并没有发生改变，就返回原本的值，否则返回新的<code>state</code>值</p>
<p><code>nextState</code>保存新的<code>state</code>值</p>
<pre><code class="language-javascript">      const key = finalReducerKeys[i]
      const reducer = finalReducers[key]
      const previousStateForKey = state[key]
      const nextStateForKey = reducer(previousStateForKey, action)
</code></pre>
<p>这些代码就不多做解释了，重要一点的是<code>state[key]</code>,他把<code>reducer</code>的<code>key</code>,作为<code>state</code>的<code>key</code>,例如</p>
<pre><code class="language-javascript">combineReducer({
    user,
    cart
})

// 使用state
const state = store.getState()
const userState = state.user
</code></pre>
<pre><code class="language-javascript">      if (typeof nextStateForKey === 'undefined') {
        const errorMessage = getUndefinedStateErrorMessage(key, action)
        throw new Error(errorMessage)
      }
      nextState[key] = nextStateForKey
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey
</code></pre>
<p>最后就是上面这段代码</p>
<p>判断：如果此reducer返回的新的state是undefined，抛出异常</p>
<p>然后把新的<code>state</code>放入<code>nextState</code>对象中，并返回，最后对前后的值进行了对比，也是一种优化</p>
<h3 id="applymiddleware">applyMiddleware</h3>
<pre><code class="language-javascript">export default function applyMiddleware(...middlewares) {
  return createStore =&gt; (...args) =&gt; {
    const store = createStore(...args)
    let dispatch = () =&gt; {
      throw new Error(
        'Dispatching while constructing your middleware is not allowed. ' +
          'Other middleware would not be applied to this dispatch.'
      )
    }

    const middlewareAPI = {
      getState: store.getState,
      dispatch: (...args) =&gt; dispatch(...args)
    }
    const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))
    dispatch = compose(...chain)(store.dispatch)

    return {
      ...store,
      dispatch
    }
  }
}

</code></pre>
<p>中间件的作用实际上是对<code>dispatch</code>进行了包装,<code>applyMiddleware</code>函数，连续返回了两个函数，包括它本身，就有三层函数，这三层函数为什么这么设计，我也不清楚，我个人认为一层也可以。</p>
<p>然后又调用<code>createStore</code>,拿到了当前的<code>store</code>,之后对<code>store</code>中的<code>dispatch</code>方法进行了处理</p>
<pre><code class="language-javascript">    const middlewareAPI = {
      getState: store.getState,
      dispatch: (...args) =&gt; dispatch(...args)
    }
    const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))
    dispatch = compose(...chain)(store.dispatch)

</code></pre>
<p>这段代码其实是有点难理解的，我们拆分来讲</p>
<pre><code class="language-javascript">    const middlewareAPI = {
      getState: store.getState,
      dispatch: (...args) =&gt; dispatch(...args)
    }
    const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))
</code></pre>
<p>大家可能不知道这到底干了什么，先卖个关子，<code>middlewareAPI</code>的作用是给中间件传入<code>dispatch</code>方法和<code>getState</code>，它利用了闭包的特性，至于它的使用，在后面实现中间件的时候会有讲解</p>
<pre><code class="language-javascript">dispatch = compose(...chain)(store.dispatch)
</code></pre>
<p>最关键的代码来了，下面详细讲解<code>compose</code>函数</p>
<h3 id="compose">compose</h3>
<pre><code class="language-javascript">export default function compose(...funcs) {
  if (funcs.length === 0) {
    return arg =&gt; arg
  }

  if (funcs.length === 1) {
    return funcs[0]
  }

  return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))
}

</code></pre>
<p><code>compose</code>的实现非常简单，但是又非常重要，它是<code>applyMiddleware</code>的核心与关键，在讲<code>compose</code>之前我先从三个方面介绍这个函数</p>
<ul>
<li>
<p><code>redux</code>中间件参照了<code>koa</code>中间件的实现，以后我在讲解<code>koa</code>源码分析系列也会讲到</p>
</li>
<li>
<p>洋葱模型</p>
<p><img src="C:%5CUsers%5C86176%5CDesktop%5C2474077171-5ab493c984bf8_articlex.png" alt=""></p>
<p>大家把洋葱的中心想象成<code>dispatch</code>函数，后面大家会明白</p>
</li>
<li>
<p>函数组合</p>
</li>
</ul>
<p>以上三者是什么，大家如果有不知道的，希望可以查一下方便大家理解</p>
<p>总的来说这个函数所作的事情，就是把一个函数的返回值，作为另一个函数的参数，不断地迭代</p>
<p>在<code>redux</code>的角度来讲：对<code>dispatch</code>进行了一层层的包装，有点像装饰器，我再画一张图方便理解</p>
<p><img src="C:%5CUsers%5C86176%5CDesktop%5CQQ%E6%88%AA%E5%9B%BE20190727011616.png" alt=""></p>
<p>如果我们有使用中间件，我们拿到的<code>dispatch</code>实际上是被包装后的<code>dispatch</code>，对于<code>compose</code>的代码，希望大家多看几遍</p>
<h3 id="logger中间件实现">logger中间件实现</h3>
<pre><code class="language-javascript">const logger1 = function({ dispatch, getState }) {
  return function(next) {
    return function(action) {
      // 打印旧state
      console.log('old', getState());
      next(action)
      // 打印新state
      console.log('new', getState());
    }
  }
}
</code></pre>
<p>首先中间件返回了一个函数,还记得<code>middlewareAPI</code>吗，第一层的函数就是用来保存<code>middlewareAPI</code>中的方法，</p>
<p>第二层函数：这个函数的参数，是经过上一层中间件包装后的或者原始的<code>dispatch</code>方法</p>
<p>第三层函数：参数是<code>action</code>，它是包装后的<code>dispatch</code>，假如还有下一个中间件，就会把第三层函数，作为参数，传给下一个中间件的第二层函数，也就是<code>next</code></p>
<p>讲完这些可能还是没明白，希望大家结合上面的图，多看几遍,理解之后看后面的中间件实现旧方便很多</p>
<h3 id="redux-thunk中间件实现">redux-thunk中间件实现</h3>
<pre><code class="language-javascript">const thunk = ({ dispatch, getState }) =&gt; next =&gt; action =&gt; {
  if (typeof action === 'function') {
    action(dispatch, getState)
  } else {
    next(action)
  }
}
</code></pre>
<h3 id="redux-promise中间件实现">redux-promise中间件实现</h3>
<pre><code class="language-javascript">const promise = ({ dispatch, getState }) =&gt; next =&gt; action =&gt; {
   if (action.then) {
      action.then(function(data) {
        dispatch(data)
      })
   } else {
      next(action)
   }
}

</code></pre>
<h2 id="react-redux">React-Redux</h2>
<p>虽然讲完了<code>redux</code>，但是它在<code>react</code>中使用还是要借助<code>react-redux</code>的，下面我将从入口文件开始</p>
<pre><code class="language-javascript">import Provider from './components/Provider'
import connectAdvanced from './components/connectAdvanced'
import { ReactReduxContext } from './components/Context'
import connect from './connect/connect'

import { useDispatch } from './hooks/useDispatch'
import { useSelector } from './hooks/useSelector'
import { useStore } from './hooks/useStore'

import { setBatch } from './utils/batch'
import { unstable_batchedUpdates as batch } from './utils/reactBatchedUpdates'
import shallowEqual from './utils/shallowEqual'

setBatch(batch)

export {
  Provider,
  connectAdvanced,
  ReactReduxContext,
  connect,
  batch,
  useDispatch,
  useSelector,
  useStore,
  shallowEqual
}


</code></pre>
<p>从这个文件来看，<code>react-redux</code>，返回了这些函数</p>
<pre><code class="language-javascript">  Provider,
  connectAdvanced,
  ReactReduxContext,
  connect,
  batch,
  useDispatch,
  useSelector,
  useStore,
  shallowEqual
</code></pre>
<p><code>Provider</code>,<code>connect</code>这两个是我们常用的函数，但其它的，在这里说实话我从来没用过，这也是在我看源码的时候才知道的API，看源码的过程就是学习API的过程，在我看来也算是种查漏补缺</p>
<p>同时如果有注意到的话能够发现，它导出了<code>batch</code>,而在上面的<code>setBatch(batch)</code>，也有使用到,那么这个<code>batch</code>又是什么呢，先从<code>setBatch</code>讲起</p>
<h3 id="batch">batch</h3>
<pre><code class="language-javascript">// batch.js
function defaultNoopBatch(callback) {
  callback()
}

let batch = defaultNoopBatch

// Allow injecting another batching function later
export const setBatch = newBatch =&gt; (batch = newBatch)

// Supply a getter just to skip dealing with ESM bindings
export const getBatch = () =&gt; batch
</code></pre>
<p>手写给<code>batch</code>设置了一个默认函数<code>defaultNoopBatch</code>,它没有做什么处理，只是调用了传入的回调函数</p>
<p>这个文件导出了两个函数<code>setBatch</code>和<code>getBatch</code>,分别用于设置和获取<code>batch</code></p>
<pre><code class="language-javascript">import { unstable_batchedUpdates as batch } from './utils/reactBatchedUpdates'


setBatch(batch)
</code></pre>
<p>我们知道在<code>index.js</code>种调用了<code>setBatch</code>方法，并传入了<code>batch</code>,来看下这个<code>batch</code>是什么</p>
<pre><code class="language-javascript">export { unstable_batchedUpdates } from 'react-dom'
</code></pre>
<p>没想到尽然是<code>react-deom</code>里面的一个方法，<code>unstable_batchedUpdates</code>又是啥，其实在看源码之前我也是不知道的，看源码真的是能学到东西啊，嘿嘿，为了方便介绍<code>unstable_batchedUpdates</code>,下面举个例子</p>
<pre><code class="language-javascript">class Sub extends PureComponent {
    state = {
        b: false,
        a: false
    }

    handleClick = () =&gt; {
		this.setState({
            a: true
        })
        this.setState({
            b: true
        })
    }

    render() {
    	return &lt;button onClick={this.handleClick}&gt;Click&lt;/button&gt;
    }
}
</code></pre>
<p>在这个点击事件中，更新总是<strong>按照它们发生的顺序进行浅合并</strong>, <strong>在 React 事件处理程序中，不论 setState() 调用了多少次，也不论 setState()被多少个组件调用，它们在事件结束时只会生成一次重新渲染</strong>**</p>
<pre><code class="language-javascript">promise.then(() =&gt; {
  // 强制批量处理
  ReactDOM.unstable_batchedUpdates(() =&gt; {
    this.setState({a: true}); // 不重新渲染
    this.setState({b: true}); // 不重新渲染
    this.props.setParentState(); // 不重新渲染
  });
  // 当我们退出 unstable_batchedUpdates函数后，重新渲染一次
});
</code></pre>
<p>所以<code>unstable_batchedUpdates</code>方法就是用来批量更新<code>state</code>,并只渲染一次</p>
<p>某大佬github中有更详细讲解，我也是参考了其文章：</p>
<p>知道了<code>batch</code>是干嘛的，我们回到<code>index.js</code></p>
<pre><code class="language-javascript">export {
  Provider,
  connectAdvanced,
  ReactReduxContext,
  connect,
  batch,
  useDispatch,
  useSelector,
  useStore,
  shallowEqual
}
</code></pre>
<p>接下来讲解<code>Provider</code></p>
<h3 id="provider">Provider</h3>
<pre><code class="language-javascript">import React, { Component } from 'react'
import PropTypes from 'prop-types'
import { ReactReduxContext } from './Context'
import Subscription from '../utils/Subscription'

class Provider extends Component {
  constructor(props) {
    super(props)
    const { store } = props
    this.notifySubscribers = this.notifySubscribers.bind(this)
    const subscription = new Subscription(store)
    subscription.onStateChange = this.notifySubscribers

    this.state = {
      store,
      subscription
    }

    this.previousState = store.getState()
  }

  componentDidMount() {
    this.state.subscription.trySubscribe()
    if (this.previousState !== this.props.store.getState()) {
      this.state.subscription.notifyNestedSubs()
    }
  }

  componentWillUnmount() {
    if (this.unsubscribe) this.unsubscribe()

    this.state.subscription.tryUnsubscribe()
  }

  componentDidUpdate(prevProps) {
    if (this.props.store !== prevProps.store) {
      this.state.subscription.tryUnsubscribe()
      const subscription = new Subscription(this.props.store)
      subscription.onStateChange = this.notifySubscribers
      this.setState({ store: this.props.store, subscription })
    }
  }

  notifySubscribers() {
    this.state.subscription.notifyNestedSubs()
  }

  render() {
    const Context = this.props.context || ReactReduxContext

    return (
      &lt;Context.Provider value={this.state}&gt;
        {this.props.children}
      &lt;/Context.Provider&gt;
    )
  }
}

Provider.propTypes = {
  store: PropTypes.shape({
    subscribe: PropTypes.func.isRequired,
    dispatch: PropTypes.func.isRequired,
    getState: PropTypes.func.isRequired
  }),
  context: PropTypes.object,
  children: PropTypes.any
}

export default Provider

</code></pre>
<p>由于内容较多，我们分方法来讲,先来看下构造函数</p>
<pre><code class="language-javascript">  constructor(props) {
    super(props)
    const { store } = props
    this.notifySubscribers = this.notifySubscribers.bind(this)
    const subscription = new Subscription(store)
    subscription.onStateChange = this.notifySubscribers
    this.state = {
      store,
      subscription
    }

    this.previousState = store.getState()
  }
</code></pre>
<ul>
<li>
<p>通过<code>props</code>拿到了我们传给<code>Provider</code>的<code>store</code></p>
</li>
<li>
<p>给<code>notifySubscribers</code>绑定<code>this</code></p>
<pre><code class="language-javascript">  notifySubscribers() {
    this.state.subscription.notifyNestedSubs()
  }
</code></pre>
</li>
<li>
<p>创建<code>Subscription</code>对象，并传入<code>store</code></p>
</li>
<li>
<p>将<code>notifySubscribers</code>函数作为<code>Subscription</code>对象的<code>onStateChange</code>属性</p>
</li>
<li>
<p>把<code>store</code>和<code>subscription</code>放在组件<code>state</code>中</p>
</li>
<li>
<p>获取<code>store</code>中的<code>state</code>,放在<code>previousState</code>对象属性中</p>
</li>
</ul>
<p>以上步骤仅仅是做了一些初始化，并没有调用任何方法，然后看下在组件挂载阶段做了什么</p>
<pre><code class="language-javascript">  componentDidMount() {
    this.state.subscription.trySubscribe()

    if (this.previousState !== this.props.store.getState()) {
      this.state.subscription.notifyNestedSubs()
    }
  }
</code></pre>
<p>调用了<code>subscription</code>对象中的<code>trySubscribe</code>方法，它的实现如下</p>
<pre><code class="language-javascript">export default class Subscription {
  constructor(store, parentSub) {
    this.store = store
    this.parentSub = parentSub
    this.unsubscribe = null
    this.listeners = nullListeners

    this.handleChangeWrapper = this.handleChangeWrapper.bind(this)
  }
  // ...其他  
  trySubscribe() {
    if (!this.unsubscribe) {
      this.unsubscribe = this.parentSub
        ? this.parentSub.addNestedSub(this.handleChangeWrapper)
        // 订阅handleChangeWrapper方法，其实就是notifySubscribers方法，这个方法可以通知调用所有listeners
        : this.store.subscribe(this.handleChangeWrapper)
      // 创建监听函数集合，它返回了一个对象，包含：clear方法，get方法，notify方法，subscribe方法
      this.listeners = createListenerCollection()
    }
  }
    //...其他
}
</code></pre>
<p>这里初始时<code>parentSub</code>并不存在，所以执行<code>this.store.subscribe(this.handleChangeWrapper)</code></p>
<pre><code class="language-javascript">  handleChangeWrapper() {
    if (this.onStateChange) {
      this.onStateChange()
    }
  }
</code></pre>
<p><code>handleChangeWrapper</code>方法实际上又调用了,<code>Provider</code>中的<code>notifySubscribers</code>方法</p>
<pre><code class="language-javascript">  notifySubscribers() {
    this.state.subscription.notifyNestedSubs()
  }
</code></pre>
<p>所以等价于</p>
<pre><code class="language-javascript">this.store.subscribe(function notifySubscribers() {
    // 通知调用所有listener
    this.state.subscription.notifyNestedSubs()
})
</code></pre>
<p>继续看后面的代码</p>
<pre><code class="language-javascript">this.listeners = createListenerCollection()
</code></pre>
<p>创建了一个<code>listener</code>集合，这个函数很关键</p>
<h4 id="createlistenercollection">createListenerCollection</h4>
<pre><code class="language-javascript">function createListenerCollection() {
  const batch = getBatch()
  // the current/next pattern is copied from redux's createStore code.
  // TODO: refactor+expose that code to be reusable here?
  let current = []
  let next = []

  return {
    clear() {
      next = CLEARED
      current = CLEARED
    },

    notify() {
      const listeners = (current = next)
      // 批量调用监听函数listeners
      batch(() =&gt; {
        for (let i = 0; i &lt; listeners.length; i++) {
          listeners[i]()
        }
      })
    },

    get() {
      return next
    },

    subscribe(listener) {
      let isSubscribed = true
      if (next === current) next = current.slice()
      next.push(listener)
      return function unsubscribe() {
        if (!isSubscribed || current === CLEARED) return
        isSubscribed = false

        if (next === current) next = current.slice()
        next.splice(next.indexOf(listener), 1)
      }
    }
  }
}
</code></pre>
<p>首先获取到了<code>batch</code>,这个<code>batch</code>是什么，大家应该还记得，用于批量<code>setState</code>，并且只渲染一次，别的不看，我们先看<code>notify</code></p>
<h5 id="1notify">1.notify</h5>
<pre><code class="language-javascript">    notify() {
      const listeners = (current = next)
      // 批量调用监听函数listeners
      batch(() =&gt; {
        for (let i = 0; i &lt; listeners.length; i++) {
          listeners[i]()
        }
      })
    },
</code></pre>
<p>大家应该能注意到使用<code>batch</code>,包裹的回调函数，里面循环调用了<code>listener</code>，没错最关键的就是这里了，如果多次调用<code>setState</code>,每次都要重新渲染，太过于耗费性能，使用<code>batch</code>就是必须的了</p>
<p>然后我们来看下，<code>subscribe</code>方法</p>
<h5 id="2subscribe">2.subscribe</h5>
<pre><code class="language-javascript">    subscribe(listener) {
      let isSubscribed = true
      if (next === current) next = current.slice()
      next.push(listener)
      return function unsubscribe() {
        if (!isSubscribed || current === CLEARED) return
        isSubscribed = false

        if (next === current) next = current.slice()
        next.splice(next.indexOf(listener), 1)
      }
    }
</code></pre>
<p>这个方法我觉得其实没必要解释了。。。和<code>redux</code>中的实现也是非常相似的</p>
<h5 id="3get">3.get</h5>
<pre><code class="language-javascript">    get() {
      return next
    }
</code></pre>
<p>这个方法是用来返回接下来的监听函数数组</p>
<h5 id="4clear">4.clear</h5>
<pre><code class="language-javascript">    clear() {
      next = CLEARED
      current = CLEARED
    }
</code></pre>
<p>清除当前和接下来的监听函数数组</p>
<p>讲完<code>createListenerCollection</code>函数，回到<code>trySubscribe</code>方法</p>
<pre><code class="language-javascript">  trySubscribe() {
    if (!this.unsubscribe) {
      this.unsubscribe = this.parentSub
        ? this.parentSub.addNestedSub(this.handleChangeWrapper)
        // 订阅handleChangeWrapper方法，其实就是notifySubscribers方法，这个方法可以通知调用所有listeners
        : this.store.subscribe(this.handleChangeWrapper)
      // 创建监听函数集合，它返回了一个对象，包含：clear方法，get方法，notify方法，subscribe方法
      this.listeners = createListenerCollection()
    }
  }
</code></pre>
<p>最后这个方法的作用就是：订阅<code>handleChangeWrapper</code>函数，它能够调用所有监听函数；同时创建了<code>ListenerCollection</code>,返回了一个对象，包含<code>notify</code>，<code>subscribe</code>等</p>
<p>再回到<code>Provider</code>组件中</p>
<pre><code class="language-javascript">  componentDidMount() {
    this.state.subscription.trySubscribe()
    if (this.previousState !== this.props.store.getState()) {
      this.state.subscription.notifyNestedSubs()
    }
  }
</code></pre>
<p><code>this.state.subscription.trySubscribe()</code>,刚刚分析过，然后是一个判断</p>
<pre><code class="language-javascript">    if (this.previousState !== this.props.store.getState()) {
      this.state.subscription.notifyNestedSubs()
    }
</code></pre>
<p>如果前后的<code>state</code>有变化就调用<code>notifyNestedSubs</code>,也就是说当我们调用<code>dispatch</code>，更新了<code>state</code>,就会导致状态的更新，状态更新，就需要通知监听函数调用，更新视图，继续看<code>notifyNestedSubs</code>实现</p>
<pre><code class="language-javascript">  notifyNestedSubs() {
    // 调用所有的listener,批量调用setState,但是只渲染一次
    this.listeners.notify()
  }

</code></pre>
<p>这个方法就不用我说了把，调用了监听函数，使用<code>batch</code>更新视图</p>
<p>继续。。。</p>
<pre><code class="language-javascript">  class Provider extends Component {
      componentWillUnmount() {
        if (this.unsubscribe) this.unsubscribe()
        this.state.subscription.tryUnsubscribe()
      }  
  }

</code></pre>
<p>在组件将要卸载阶段，清除所有的监听函数</p>
<pre><code class="language-javascript">  componentDidUpdate(prevProps) {
    if (this.props.store !== prevProps.store) {
      this.state.subscription.tryUnsubscribe()
      const subscription = new Subscription(this.props.store)
      subscription.onStateChange = this.notifySubscribers
      this.setState({ store: this.props.store, subscription })
    }
  }
</code></pre>
<p>在组件更新阶段，也就是我们调用<code>dispatch</code>，更新了<code>store</code>中的状态，然后所有的<code>listeners</code>被<code>notify</code>通知调用，假如前后的<code>store</code>不一样，就会重复之前<code>constructor</code>中一样的初始化操作，其实这个判断一般来说不会执行到</p>
<p>最后就是<code>render</code>函数了</p>
<pre><code class="language-javascript">  render() {
    const Context = this.props.context || ReactReduxContext
    return (
      &lt;Context.Provider value={this.state}&gt;
        {this.props.children}
      &lt;/Context.Provider&gt;
    )
  }
  
  
  
  
// 引入context  
Provider.propTypes = {
  store: PropTypes.shape({
    subscribe: PropTypes.func.isRequired,
    dispatch: PropTypes.func.isRequired,
    getState: PropTypes.func.isRequired
  }),
  context: PropTypes.object,
  children: PropTypes.any
}
</code></pre>
<p><code>Provider</code>最核心的功能就是给后代组件提供<code>store</code>,它利用了React的<code>Context</code>，因为React16引入了<code>createContext</code>，而且还有以前的<code>Context</code>用法，所以<code>Provider</code>会根据情况使用相应的<code>Context</code></p>
<pre><code class="language-javascript">// 优先采用原本的context
const Context = this.props.context || ReactReduxContext

// 新版本的context
export const ReactReduxContext = React.createContext(null)
</code></pre>
<p>关于<code>context</code>的用法不是本文重点，大家可以参考官方文档</p>
<h3 id="connectadvanced">connectAdvanced</h3>
<p>以下摘抄了文档中的介绍，毕竟比自己写的详细很多</p>
<p>它是一个将 React 组件连接到 Redux store 的函数。这个函数是 <code>connect()</code> 的基础，但是对于如何把<code>state</code>, <code>props</code>, 和 <code>dispatch</code> 组合到最后的 props 中，则不那么自以为是。它不对默认值或结果的记录做任何假设，而是将这些责任留给调用者。</p>
<p>它不修改传递给它的组件类；相反，它<em>返回</em>一个新的、已连接的组件类，供您使用。</p>
<h4 id="参数">参数</h4>
<ul>
<li><code>selectorFactory(dispatch, factoryOptions): selector(state, ownProps): props</code> (<em>Function</em>):初始化选择器函数 (在每个实例的构造函数中)。该选择器函数是在 connector 组件需要重新计算一个新的 props 时调用，作为 store 的 state 改变或者接收到一个新的 props 的结果。<code>selector</code> 的结果应该是一个普通对象，作为被包裹的组件的 props 传递。如果连续调用 <code>selector</code> 都返回与上一次调用相同的对象(<code>===</code>)，则不会重新渲染该组件。<code>selector</code> 的责任是在适当的时候返回以前的对象。</li>
<li>[<code>connectOptions</code>] <em>(Object)</em> 如果指定，则进一步自定义连接器(connector)的行为。
<ul>
<li>[<code>getDisplayName</code>] <em>(Function)</em>: 计算连接器组件相对于被包裹的组件的 DisplayName 属性。 通常被包裹函数覆盖。 默认值: <code>name =&gt; 'ConnectAdvanced('+name+')'</code></li>
<li>[<code>methodName</code>] <em>(String)</em>:显示在错误消息中。 通常被包裹函数覆盖。 默认值: <code>'connectAdvanced'</code></li>
<li>[<code>renderCountProp</code>] <em>(String)</em>: 如果被定义, 名为此值的属性将添加到传递给被包裹组件的 props 中。它的值将是组件被渲染的次数，这对于跟踪不必要的重新渲染非常有用。默认值: <code>undefined</code></li>
<li>[<code>shouldHandleStateChanges</code>] <em>(Boolean)</em>: 控制连接器（connector）组件是否订阅 redux store 的 state 更改。 如果设置为 false，则只会在<code>componentWillReceiveProps</code>中重新渲染。 默认值: <code>true</code></li>
<li>[<code>storeKey</code>] <em>(String)</em>: 可以获取 store 的 props/context key。 当你不明智地使用了多个 store 的时候，你才可能需要这个。默认值: <code>'store'</code></li>
<li>[<code>withRef</code>] <em>(Boolean)</em>: 如果为 true，则将一个引用存储到被包裹的组件实例中，并通过 <code>getWrappedInstance()</code> 方法使其可用。 默认值: <code>false</code></li>
<li>此外，通过 <code>connectOptions</code> 传递的任何额外选项都将传递给 <code>factorOptions</code> 参数中的 <code>selectorFactory</code>。</li>
</ul>
</li>
</ul>
<h4 id="返回值">返回值</h4>
<p>一个高阶 React 组件类，它从 store 的 state 生成 props 并将它们传递给被包裹的组件。高阶组件是接受组件参数并返回新组件的函数.</p>
<h5 id="静态属性">静态属性</h5>
<ul>
<li><code>WrappedComponent</code> <em>(Component)</em>: 原始组件类传递给 <code>connectAdvanced(...)(Component)</code>.</li>
</ul>
<h5 id="静态函数">静态函数</h5>
<ul>
<li>组件的所有原始静态方法都被挂起。</li>
</ul>
<h5 id="实例方法">实例方法</h5>
<ul>
<li><code>getWrappedInstance(): ReactComponent</code></li>
</ul>
<p>返回被包裹组件的实例。只有当你传递 <code>{ withRef: true }</code> 作为<code>options</code> 的参数才可用。</p>
<h4 id="注意">注意</h4>
<ul>
<li>因为 <code>connectAdvanced</code> 返回一个高阶组件，所以需要调用它两次。 第一次使用上面描述的参数，第二次使用组件： <code>connectAdvanced(selectorFactory)(MyComponent)</code>.</li>
<li><code>connectAdvanced</code> 不修改传递的 React 组件。它返回一个新的连接组件，您应该使用它。</li>
</ul>
<p>例子：</p>
<pre><code class="language-javascript">import * as actionCreators from './actionCreators'
import { bindActionCreators } from 'redux'

function selectorFactory(dispatch) {
  let ownProps = {}
  let result = {}
  const actions = bindActionCreators(actionCreators, dispatch)
  const addTodo = text =&gt; actions.addTodo(ownProps.userId, text)
  return (nextState, nextOwnProps) =&gt; {
    const todos = nextState.todos[nextOwnProps.userId]
    const nextResult = { ...nextOwnProps, todos, addTodo }
    ownProps = nextOwnProps
    if (!shallowEqual(result, nextResult)) result = nextResult
    return result
  }
}
export default connectAdvanced(selectorFactory)(TodoApp)
</code></pre>
<p><code>selectorFactory</code>作用其实很简单，通俗来讲就是，把<code>自己在store中选择的一些state或dispatch</code>， <code>ownProps</code>进行合并，传入到组件中，并且自己也可以进行判断前后的变化，进而确定是否要更新组件</p>
<p>看完上面这些介绍，我们直接开始讲源码，由于内容太多，就先只截取一部分</p>
<pre><code class="language-javascript">export default function connectAdvanced(
  selectorFactory,
  {
    getDisplayName = name =&gt; `ConnectAdvanced(${name})`,
    methodName = 'connectAdvanced',
    renderCountProp = undefined,
    shouldHandleStateChanges = true,
    storeKey = 'store',
    withRef = false,  // 如果为 true，则将一个引用存储到被包裹的组件实例中，并通过 getWrappedInstance() 方法使其可用。 默认值: false
    forwardRef = false,
    context = ReactReduxContext,
    ...connectOptions
  } = {}
) {
    // 。。。
  return function wrapWithConnect(WrappedComponent) {
      // 。。。
      return hoistStatics(Connect, WrappedComponent)
  }
  // 。。。。
  
}
</code></pre>
<p>整个函数最终返回了一个高阶组件，也就是被处理过的组件，我们在<code>selectorFactory</code>调用返回的对象，也会作为<code>props</code>传给原本的组件，下面跟着源码一段段分析</p>
<pre><code class="language-javascript">  invariant(
    renderCountProp === undefined,
    `renderCountProp is removed. render counting is built into the latest React Dev Tools profiling extension`
  )

  invariant(
    !withRef,
    'withRef is removed. To access the wrapped instance, use a ref on the connected component'
  )

  const customStoreWarningMessage =
    'To use a custom Redux store for specific components, create a custom React context with ' +
    &quot;React.createContext(), and pass the context object to React Redux's Provider and specific components&quot; +
    ' like: &lt;Provider context={MyContext}&gt;&lt;ConnectedComponent context={MyContext} /&gt;&lt;/Provider&gt;. ' +
    'You may also pass a {context : MyContext} option to connect'

  invariant(
    storeKey === 'store',
    'storeKey has been removed and does not do anything. ' +
      customStoreWarningMessage
  )
  const Context = context
</code></pre>
<ul>
<li>
<p>第一个<code>invariant</code>:</p>
<p>判断<code>renderCountProp</code>是否是<code>undefined</code>,如果是，就报出警告，这个属性基本上用不到，而且上面写了<code>renderCountProp已删除。渲染计数内置于最新的React Dev工具分析扩展中</code></p>
</li>
<li>
<p>第二个<code>invariant</code></p>
<p>判断<code>withRef</code>是否存在，如果存在也会报出警告，<code>withRef被删除。要访问包装的实例，请在连接的组件上使用引用</code></p>
</li>
<li>
<p>第三个<code>invariant</code></p>
<p>判断<code>storeKey</code>是否为<code>store</code>,如果是，就报出警告<code>StoreKey已被删除，不执行任何操作。</code></p>
</li>
</ul>
<p>然后又创建了一个<code>context</code>,这个其实是在参数上设置了一个默认函数</p>
<pre><code class="language-javascript">const Context = context

// Context.js
export const ReactReduxContext = React.createContext(null)

</code></pre>
<p>接下来具体分析返回的高阶函数</p>
<pre><code class="language-javascript">  return function wrapWithConnect(WrappedComponent) {
      // 。。。
    return hoistStatics(Connect, WrappedComponent)
  }
</code></pre>
<h4 id="wrapwithconnect">wrapWithConnect</h4>
<p>又是一大段代码，太长了。。。。，还是一点点分析</p>
<pre><code class="language-javascript">    if (process.env.NODE_ENV !== 'production') {
      invariant(
        isValidElementType(WrappedComponent),
        `You must pass a component to the function returned by ` +
          `${methodName}. Instead received ${stringifyComponent(
            WrappedComponent
          )}`
      )
    }
// typescript类型保护
export function isValidElementType(value: any): value is ReactType;
</code></pre>
<p>这段代码简单来说就是判断组件是否是合法的组件类型,否则警告，这里就不深入介绍了</p>
<pre><code class="language-javascript">    const wrappedComponentName =
      WrappedComponent.displayName || WrappedComponent.name || 'Component'

    const displayName = getDisplayName(wrappedComponentName)
    // getDisplayName = name =&gt; `ConnectAdvanced(${name})`,
    const selectorFactoryOptions = {
      ...connectOptions,
      getDisplayName, // 计算连接器组件相对于被包裹的组件的 DisplayName 属性。 通常被包裹函数覆盖。 默认值: name =&gt; 'ConnectAdvanced('+name+')'
      methodName,  // 示在错误消息中。 通常被包裹函数覆盖。 默认值: 'connectAdvanced'
      renderCountProp,// 如果被定义, 名为此值的属性将添加到传递给被包裹组件的 props 中。它的值将是组件被渲染的次数，这对于跟踪不必要的重新渲染非常有用。默认值: undefined
      shouldHandleStateChanges, // 控制连接器（connector）组件是否订阅 redux store 的 state 更改。 如果设置为 false，则只会在componentWillReceiveProps中重新渲染。 默认值: true
      storeKey,// 可以获取 store 的 props/context key。 当你不明智地使用了多个 store 的时候，你才可能需要这个
      displayName,
      wrappedComponentName,
      WrappedComponent
    }
    // connect中pure为true
    const { pure } = connectOptions

</code></pre>
<ul>
<li>
<p><strong>wrappedComponentName</strong>: 组件名称</p>
</li>
<li>
<p><strong>displayName</strong>： 拼接ConnectAdvanced后的组件名</p>
</li>
<li>
<p><strong>selectorFactoryOptions</strong>: 选项合并，其中有处理过后的组件名</p>
</li>
<li>
<p><strong>pure</strong>： 是否使用<code>pure</code>组件，可以对数据进行浅比较</p>
</li>
</ul>
<p>继续来看</p>
<pre><code class="language-javascript">    function createChildSelector(store) {
      return selectorFactory(store.dispatch, selectorFactoryOptions)
    }
	const usePureOnlyMemo = pure ? useMemo : callback =&gt; callback()
    
    function ConnectFunction(props) {
        //...
    }
    const Connect = pure ? React.memo(ConnectFunction) : ConnectFunction
</code></pre>
<p>首先创建了一个<code>createChildSelector</code>内部函数，调用了<code>selectorFactory</code>,传入了<code>dispatch</code>方法和刚才的<code>selectorFactoryOptions</code>对象，注意此时的<code>selectorFactoryOptions</code>还不是最新的</p>
<p>然后判断<code>pure</code>是否为<code>true</code>，如果是就使用<code>useMemo</code>函数，这个函数是<code>React Hooks</code>中的一个方法，这个函数这里简单介绍一下</p>
<pre><code class="language-javascript">const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);
</code></pre>
<p><code>把“创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算。</code></p>
<p>这句话什么意思呢，其实就是,如果<code>a</code>或者<code>b</code>发生改变，才会调用回调函数中的<code>computeExpensiveValue</code>,并返回了新的<code>computeExpensiveValue</code>返回值，这是一种优化的手段，简单介绍完<code>useMemo</code>，我们继续来讲</p>
<p>又是一个<code>ConnectFunction</code>内部函数，这个暂时先不讲，内容太多</p>
<pre><code class="language-javascript">const Connect = pure ? React.memo(ConnectFunction) : ConnectFunction
</code></pre>
<p>然后判断<code>pure</code>是否为真，如果是就用<code>React.memo</code>创建一个<code>pure</code>函数式组件，这是<code>React 16</code>中的一个新API，<code>React.memo()</code> 和 <code>PureComponent</code> 很相似，它帮助我们控制何时重新渲染组件。</p>
<p>简单点来讲就是</p>
<ul>
<li>React.memo()用于<strong>函数式组件</strong></li>
<li>PureComponent用于<strong>class组件</strong></li>
</ul>
<p>至于用法，请大家参考官方文档，不是本文重点</p>
<pre><code class="language-javascript">Connect.WrappedComponent = WrappedComponent
Connect.displayName = displayName
</code></pre>
<p>然后就是在函数上添加了两个属性</p>
<pre><code class="language-javascript">    if (forwardRef) {
      const forwarded = React.forwardRef(function forwardConnectRef(
        props,
        ref
      ) {
        return &lt;Connect {...props} forwardedRef={ref} /&gt;
      })

      forwarded.displayName = displayName
      forwarded.WrappedComponent = WrappedComponent
      return hoistStatics(forwarded, WrappedComponent)
    }
</code></pre>
<p>这段代码，判断<code>forwardRef</code>是否存在，这个属性也是在参数的配置对象中传入的，初始为<code>false</code>, 它在源码注释中的介绍是这样的<code>使用react的forwardRef公开包装组件的引用</code></p>
<pre><code class="language-javascript">      const forwarded = React.forwardRef(function forwardConnectRef(
        props,
        ref
      ) {
        return &lt;Connect {...props} forwardedRef={ref} /&gt;
      })

      forwarded.displayName = displayName
      forwarded.WrappedComponent = WrappedComponent
      return hoistStatics(forwarded, WrappedComponent)
</code></pre>
<p>这段代码比较关键的是<code>React.forwardRef</code>，这也是<code>React 16</code>中的一个api,用过的同志们可能会比较熟悉，它可以用将<code>ref</code>转发到子组件中，在这里其实是把<code>ref</code>再次传递到了<code>Connect</code>组件中，注意<code>Connect</code>函数组件其实是<code>ConnectFunction</code>函数，接下来这个函数就是重点了</p>
<h4 id="connectfunction">ConnectFunction</h4>
<p>在讲这个函数组件之前，就默认为大家会<code>React Hooks</code>了，因为里面大量的使用到了<code>React Hooks</code>中的一些<code>API</code>,另外，由于代码太多，我将会以注释的形式讲解，有重要的会在后面单独说</p>
<p>还有一件事：真的很长 。。。而且比较绕，我也是看了很久</p>
<p>这段代码太长，大家如果不太好理解，参考后面总结的代码</p>
<pre><code class="language-javascript">    function ConnectFunction(props) {
      // 当props中有值改变，才会调用回调函数
      const [propsContext, forwardedRef, wrapperProps] = useMemo(() =&gt; {
        const { forwardedRef, ...wrapperProps } = props
        // 返回context, forwardedRef,wrapperProps
        return [props.context, forwardedRef, wrapperProps]
      }, [props])


      // 当propsContext和Context有属性值发生变化，就会调用这里面的回调函数
      const ContextToUse = useMemo(() =&gt; {
        // 这里使用来判断是否是原始的context还是createContext创建的context,经过处理后，返回对应的context
        return propsContext &amp;&amp;
          propsContext.Consumer &amp;&amp;
          isContextConsumer(&lt;propsContext.Consumer /&gt;)
          ? propsContext
          : Context
      }, [propsContext, Context])

      // 使用useContext获取context中的值
      const contextValue = useContext(ContextToUse)

      // 判断是否是来自props中的store
      const didStoreComeFromProps = Boolean(props.store)
      // 判断是否是来自context中的store
      const didStoreComeFromContext =
        Boolean(contextValue) &amp;&amp; Boolean(contextValue.store)

      invariant(
        didStoreComeFromProps || didStoreComeFromContext,
        `Could not find &quot;store&quot; in the context of ` +
          `&quot;${displayName}&quot;. Either wrap the root component in a &lt;Provider&gt;, ` +
          `or pass a custom React context provider to &lt;Provider&gt; and the corresponding ` +
          `React context consumer to ${displayName} in connect options.`
      )
      
      // 优先使用props中的store
      const store = props.store || contextValue.store

      // 如果store中的属性值发生了变化，才会调用回调，其中调用了selectorFactory
      // selectorFactory是用来对props和context中的数据进行筛选和处理
      // 这个非常重要，因为它返回的值讲作为props传给组件
      const childPropsSelector = useMemo(() =&gt; {
        return createChildSelector(store)
      }, [store])


      const [subscription, notifyNestedSubs] = useMemo(() =&gt; {
        // shouldHandleStateChanges：是否处理state更改，默认为true,所以正常不会返回NO_SUBSCRIPTION_ARRAY
        if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY

        // 创建Subscription对象，
        const subscription = new Subscription(
          store,
          // 如果store是来自props中的store，就传入context中的subscription对象
          didStoreComeFromProps ? null : contextValue.subscription
        )

        // notifyNestedSubs：用来调用所有的listeners
        // 当调用这个函数的时候，实际上调用的是contextValue.subscription中的listeners
        const notifyNestedSubs = subscription.notifyNestedSubs.bind(
          subscription
        )

        // 返回subscription对象和notifyNestedSubs通知函数
        return [subscription, notifyNestedSubs]
      }, [store, didStoreComeFromProps, contextValue])


      // 按字面意思是用来覆盖ContextValue
      const overriddenContextValue = useMemo(() =&gt; {
        // 如果store是来自props中的，返回contextValue
        if (didStoreComeFromProps) {
          return contextValue
        }
        return {
          ...contextValue,
          subscription
        }
      }, [didStoreComeFromProps, contextValue, subscription])


      // userReducer:这里它的用法不做介绍，参见官网用法：https://zh-hans.reactjs.org/docs/hooks-reference.html#usereducer
      // storeStateUpdatesReducer： 是react-redux内置reducer,用来记录更新次数
      // EMPTY_ARRAY： 初始state
      // initStateUpdates: 惰性初始化
      const [
        [previousStateUpdateResult],
        forceComponentUpdateDispatch
      ] = useReducer(storeStateUpdatesReducer, EMPTY_ARRAY, initStateUpdates)


      // previousStateUpdateResult正常情况下为null ,因为initStateUpdates返回的数组第一个为null
      if (previousStateUpdateResult &amp;&amp; previousStateUpdateResult.error) {
        throw previousStateUpdateResult.error
      }

      // useRef用法参见官网：https://zh-hans.reactjs.org/docs/hooks-reference.html#useref
      const lastChildProps = useRef()
      const lastWrapperProps = useRef(wrapperProps)
      const childPropsFromStoreUpdate = useRef()
      const renderIsScheduled = useRef(false)

      // usePureOnlyMemo： pure ? useMemo : callback =&gt; callback()
      const actualChildProps = usePureOnlyMemo(() =&gt; {
        if (
          childPropsFromStoreUpdate.current &amp;&amp;
          wrapperProps === lastWrapperProps.current
        ) {
          return childPropsFromStoreUpdate.current
        }
        // 这里实际上是调用了selectorFactory返回的函数
        return childPropsSelector(store.getState(), wrapperProps)
      }, [store, previousStateUpdateResult, wrapperProps])


      // useEffect官网用法:https://zh-hans.reactjs.org/docs/hooks-reference.html#useeffect
      useIsomorphicLayoutEffect(() =&gt; {
        // 一些赋值操作
        lastWrapperProps.current = wrapperProps
        lastChildProps.current = actualChildProps
        renderIsScheduled.current = false

        if (childPropsFromStoreUpdate.current) {
          childPropsFromStoreUpdate.current = null
          // 通知listeners执行
          notifyNestedSubs()
        }
      })

      useIsomorphicLayoutEffect(() =&gt; {
        if (!shouldHandleStateChanges) return
        let didUnsubscribe = false
        let lastThrownError = null
        const checkForUpdates = () =&gt; {
          if (didUnsubscribe) {
            return
          }

          const latestStoreState = store.getState()

          let newChildProps, error
          try {
            // 传入最新的store和props
            newChildProps = childPropsSelector(
              latestStoreState,
              lastWrapperProps.current
            )
          } catch (e) {
            error = e
            lastThrownError = e
          }

          if (!error) {
            lastThrownError = null
          }
          // 如果前后的proos相同
          if (newChildProps === lastChildProps.current) {
            // renderIsScheduled.current为true，才会触发notifyNestedSubs
            if (!renderIsScheduled.current) {
              notifyNestedSubs()
            }
          } else {
            lastChildProps.current = newChildProps
            childPropsFromStoreUpdate.current = newChildProps
            renderIsScheduled.current = true
            // 强制组件更新的dispatch
            forceComponentUpdateDispatch({
              type: 'STORE_UPDATED',
              payload: {
                latestStoreState,
                error
              }
            })
          }
        }

        // 重新设置listener订阅函数
        subscription.onStateChange = checkForUpdates
        // 重新订阅
        subscription.trySubscribe()

        checkForUpdates()

        const unsubscribeWrapper = () =&gt; {
          didUnsubscribe = true
          subscription.tryUnsubscribe()
          if (lastThrownError) {
            throw lastThrownError
          }
        }

        // 返回清除函数，这个用法在官方文档中也有示例
        return unsubscribeWrapper
      }, [store, subscription, childPropsSelector])

      // 这里是关键，真正要渲染的组件，传入了处理后的props
      const renderedWrappedComponent = useMemo(
        () =&gt; &lt;WrappedComponent {...actualChildProps} ref={forwardedRef} /&gt;,
        [forwardedRef, WrappedComponent, actualChildProps]
      )

      // 这段代码就不多说了吧，如果了解createContext
      const renderedChild = useMemo(() =&gt; {
        if (shouldHandleStateChanges) {
          return (
            &lt;ContextToUse.Provider value={overriddenContextValue}&gt;
              {renderedWrappedComponent}
            &lt;/ContextToUse.Provider&gt;
          )
        }

        return renderedWrappedComponent
      }, [ContextToUse, renderedWrappedComponent, overriddenContextValue])

      // 返回组件
      return renderedChild
    }
</code></pre>
<p>接下来我将代码缩减，来整体说明<code>connectAdvanced</code>做了哪些事</p>
<pre><code class="language-javascript">function connectAdvanced(...args) {
    return function wrapWithConnect(WrappedComponent) {
        // 组件名
        const displayName = ComponentName
        // 一些配置
        const selectorFactoryOptions = {
            ...arg,
            ...options
        }
        // 判断是否应该使用pure组件
        const usePureOnlyMemo = pure ? useMemo : callback =&gt; callback()
        
        function ConnectFunction(props) {
          // props变化，获取最新的context,forwardedRef以及组件其他props
          const [propsContext, forwardedRef, wrapperProps] = useMemo(() =&gt; {...}, [props])
          
          // propsContext或Context发生变化，如果propsContext存在则优先使用
          const ContextToUse = useMemo(() =&gt; {...}, [propsContext, Context])}
                                       
          // 获取context中的值，也就是store
          const contextValue = useContext(ContextToUse)
          
          // 判断是否是来自props中的store
      	  const didStoreComeFromProps = Boolean(props.store)
          
          // 判断是否是来自context中的store
          const didStoreComeFromContext = Boolean(contextValue) &amp;&amp; Boolean(contextValue.store)
          
          // 优先使用props中的store
      	  const store = props.store || contextValue.store
          
          // 创建Selector
          const childPropsSelector = useMemo(() =&gt; {
              ...
        	  return createChildSelector(store)
          }, [store])
          
          // 创建subscription对象和notifyNestedSubs函数
          const [subscription, notifyNestedSubs] = useMemo(() =&gt; {
              ...
        	  return [subscription, notifyNestedSubs]
      	  }, [store, didStoreComeFromProps, contextValue])
          
          // 覆盖ContextValue，其实就是覆盖store
          const overriddenContextValue = useMemo(() =&gt; {
              ...
              return {
                  ...contextValue,
                  subscription
              }
      	  }, [didStoreComeFromProps, contextValue, subscription])
          
          // react-redux内置reducer,用来记录更新次数
          const [
            [previousStateUpdateResult],
            forceComponentUpdateDispatch
          ] = useReducer(storeStateUpdatesReducer, EMPTY_ARRAY, initStateUpdates)
          
          // 调用selector并传入返回函数最新的state以及组件props(不包含context)
          // 返回的actualChildProps，将用来传给要被包装的组件
          const actualChildProps = usePureOnlyMemo(() =&gt; {
			 ...
              return childPropsSelector(store.getState(), wrapperProps)
          }, [store, previousStateUpdateResult, wrapperProps])    
          
          // 一些属性的初始化
          useIsomorphicLayoutEffect(() =&gt; {
         	
      	  })
                                                                            
          useIsomorphicLayoutEffect(() =&gt; {
            // 调用内置reducer,记录更新次数，强制组件更新，因为subscription订阅了该函数，所以能触发组件更新
              const checkForUpdates = () =&gt; {}
                 // 检查state是否更新的listener
                subscription.onStateChange = checkForUpdates
                 // 调用listeners
                 subscription.trySubscribe()
                 // 先调用一次进行初始化
                 checkForUpdates()
              })         
              // 清除订阅                                                                  
             const unsubscribeWrapper = () =&gt; { ... }      
          })
          
          // 最终的被包装组件，传入了最新的props
          const renderedWrappedComponent = useMemo(
            () =&gt; &lt;WrappedComponent {...actualChildProps} ref={forwardedRef} /&gt;,
            [forwardedRef, WrappedComponent, actualChildProps]
          )
          
          const renderedChild = useMemo(() =&gt; {
            if (shouldHandleStateChanges) {
              return (
                &lt;ContextToUse.Provider value={overriddenContextValue}&gt;
                  {renderedWrappedComponent}
                &lt;/ContextToUse.Provider&gt;
              )
            }
            return renderedWrappedComponent
          }, [ContextToUse, renderedWrappedComponent, overriddenContextValue])
          
          // 返回真正的高阶组件
          return renderedChild
	  }	
      
      // 防止Component上面绑定了一些static方法丢失
      return hoistStatics(ConnectFunction, WrappedComponent)
    }
}
</code></pre>
<p>终于讲完了<code>connectAdvanced</code>,其实整体理解起来并不困难，比较难的是大量使用到了<code>React Hooks</code>，通过这一部分的学习，也让我对这些<code>hooks</code>有了更多的认识与理解</p>
<h3 id="connect">connect</h3>
<p>下面来看<code>connect</code>的源码实现</p>
<p>首先截取到<code>connect.js</code>里的关键代码</p>
<pre><code class="language-javascript">export function createConnect({
  connectHOC = connectAdvanced,
  mapStateToPropsFactories = defaultMapStateToPropsFactories,
  mapDispatchToPropsFactories = defaultMapDispatchToPropsFactories,
  mergePropsFactories = defaultMergePropsFactories,
  selectorFactory = defaultSelectorFactory
} = {}) {
  return function connect(
    mapStateToProps,
    mapDispatchToProps,
    mergeProps,
    {
      pure = true,
      areStatesEqual = strictEqual,
      areOwnPropsEqual = shallowEqual,
      areStatePropsEqual = shallowEqual,
      areMergedPropsEqual = shallowEqual,
      ...extraOptions
    } = {}
  ) {


    // 如果定义该参数，组件将会监听 Redux store 的变化。任何时候，只要 Redux store 发生改变，mapStateToProps 函数就会被调用
    // 该回调函数必须返回一个纯对象，这个对象会与组件的 props 合并。如果你省略了这个参数，你的组件将不会监听 Redux store。
    // 如果指定了该回调函数中的第二个参数 ownProps，则该参数的值为传递到组件的 props，
    // 而且只要组件接收到新的 props，mapStateToProps 也会被调用
    // （例如，当 props 接收到来自父组件一个小小的改动，那么你所使用的 ownProps 参数，mapStateToProps 都会被重新计算）。
    const initMapStateToProps = match(
      mapStateToProps,
      mapStateToPropsFactories,
      'mapStateToProps'
    )

    const initMapDispatchToProps = match(
      mapDispatchToProps,
      mapDispatchToPropsFactories,
      'mapDispatchToProps'
    )

    const initMergeProps = match(mergeProps, mergePropsFactories, 'mergeProps')
    return connectHOC(selectorFactory, {
      // used in error messages
      methodName: 'connect',

      // used to compute Connect's displayName from the wrapped component's displayName.
      getDisplayName: name =&gt; `Connect(${name})`,

      // if mapStateToProps is falsy, the Connect component doesn't subscribe to store state changes
      shouldHandleStateChanges: Boolean(mapStateToProps),
      initMapStateToProps,
      initMapDispatchToProps,
      initMergeProps,
      pure,
      areStatesEqual,
      areOwnPropsEqual,
      areStatePropsEqual,
      areMergedPropsEqual,

      // any extra options args can override defaults of connect or connectAdvanced
      ...extraOptions
    })
  }
}

</code></pre>
<p>其他不看，一步一步分析</p>
<h4 id="mapstatetoprops">mapStateToProps</h4>
<pre><code class="language-javascript">    const initMapStateToProps = match(
      mapStateToProps,
      mapStateToPropsFactories,
      'mapStateToProps'
    )
</code></pre>
<ul>
<li>
<p>mapStateToProps: <code>connect</code>传入的</p>
</li>
<li>
<p>mapStateToPropsFactories:</p>
<p>它是一个数组，包含以下两个函数，我们先暂时不讲</p>
<pre><code class="language-javascript">import { wrapMapToPropsConstant, wrapMapToPropsFunc } from './wrapMapToProps'
export function whenMapStateToPropsIsFunction(mapStateToProps) {
  // 判断是否是函数，如果是调用wrapMapToPropsFunc
  return typeof mapStateToProps === 'function'
    ? wrapMapToPropsFunc(mapStateToProps, 'mapStateToProps')
    : undefined
}

export function whenMapStateToPropsIsMissing(mapStateToProps) {
  return !mapStateToProps ? wrapMapToPropsConstant(() =&gt; ({})) : undefined
}

export default [whenMapStateToPropsIsFunction, whenMapStateToPropsIsMissing]

</code></pre>
</li>
</ul>
<p>关键是<code>match</code>方法</p>
<pre><code class="language-javascript">function match(arg, factories, name) {
  for (let i = factories.length - 1; i &gt;= 0; i--) {
    const result = factories[i](arg)
    if (result) return result
  }
  return (dispatch, options) =&gt; {
    throw new Error(
      `Invalid value of type ${typeof arg} for ${name} argument when connecting component ${
        options.wrappedComponentName
      }.`
    )
  }
}
</code></pre>
<p><code>match</code>函数实现就比较简单了，从右到左依次调用<code>[whenMapStateToPropsIsFunction, whenMapStateToPropsIsMissing]</code>, 并传入<code>mapStateToProps</code>函数，拿到调用结果后返回，如果结果不存在就返回一个会抛出错误的函数，这是为了防止传入不合法的<code>mapStateToProps</code></p>
<p>现在我们知道<code>mapStateToProps</code>需要经过两个函数的处理才能拿到真正的<code>mapStateToProps</code>,我们来具体看看其实现</p>
<pre><code class="language-javascript">// mapStateToProps.js
export function whenMapStateToPropsIsFunction(mapStateToProps) {
  // 判断是否是函数，如果是调用wrapMapToPropsFunc
  return typeof mapStateToProps === 'function'
    ? wrapMapToPropsFunc(mapStateToProps, 'mapStateToProps')
    : undefined
}
</code></pre>
<p>首先判断是否是一个函数，如果不是返回<code>undefined</code>，此时大家可以想到，这是不合法的类型，前面讲到的如果类型不合法，会返回一个抛出错误的函数，现在看来，<code>match</code>函数，除了调用工厂函数，还对错误进行了统一处理，它可以处理<code>mapStateToProps</code>和<code>mapDispatchToProps</code></p>
<p>如果是一个函数，调用<code>wrapMapToPropsFunc</code>,并继续把<code>mapStateToProps</code>传递进去，这个<code>wrapMapToPropsFunc</code>其实不单单对<code>mapStateToProps</code>进行了处理，还对<code>mapDispatchToProps</code>做了处理，我只单独讲一种情况</p>
<pre><code class="language-javascript">export function wrapMapToPropsFunc(mapToProps, methodName) {
  // 返回一个新方法
  return function initProxySelector(dispatch, { displayName }) {
    const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
      return proxy.dependsOnOwnProps
        ? proxy.mapToProps(stateOrDispatch, ownProps)
        : proxy.mapToProps(stateOrDispatch)
    }
    proxy.dependsOnOwnProps = true
    proxy.mapToProps = function detectFactoryAndVerify(
      stateOrDispatch,
      ownProps
    ) {
      // 把真实的mapToProps函数赋给代理方法的mapToProps
      proxy.mapToProps = mapToProps
      // 获取OwnProps
      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps)
      let props = proxy(stateOrDispatch, ownProps)
      
      if (typeof props === 'function') {
        proxy.mapToProps = props
        proxy.dependsOnOwnProps = getDependsOnOwnProps(props)
        props = proxy(stateOrDispatch, ownProps)
      }
      if (process.env.NODE_ENV !== 'production')
        verifyPlainObject(props, displayName, methodName)
      return props
    }

    return proxy
  }
}

</code></pre>
<p>整体看下来，其实最终返回了一个代理函数<code>proxy</code>，我们针对它的属性和方法来讲解</p>
<ul>
<li>
<p>proxy函数</p>
<pre><code class="language-javascript">    const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
      return proxy.dependsOnOwnProps
        ? proxy.mapToProps(stateOrDispatch, ownProps)
        : proxy.mapToProps(stateOrDispatch)
    }
</code></pre>
<p>这个其实就是处理过后的<code>mapStateToProps</code>或者<code>mapDispatchToProps</code></p>
<p>如果指定了该函数中的第二个参数 <code>ownProps</code>，则该参数的值为传递到组件的 props，而且只要组件接收到新的 props，<code>mapStateToProps</code> 也会被调用（例如，当 props 接收到来自父组件一个小小的改动，那么你所使用的 ownProps 参数，mapStateToProps 都会被重新计算）。</p>
</li>
<li>
<p>proxy.dependsOnOwnProps</p>
<p>默认为true</p>
</li>
<li>
<p>proxy.mapToProps</p>
<pre><code class="language-javascript">    proxy.mapToProps = function detectFactoryAndVerify(
      stateOrDispatch,
      ownProps
    ) {
      // 把真实的mapToProps函数赋给代理方法的mapToProps
      proxy.mapToProps = mapToProps
      // 获取OwnProps
      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps)
		
      // 调用了mapStateToProps,传入state，以及我们手动传入的props
      let props = proxy(stateOrDispatch, ownProps)
      
      if (typeof props === 'function') {
        proxy.mapToProps = props
        proxy.dependsOnOwnProps = getDependsOnOwnProps(props)
        props = proxy(stateOrDispatch, ownProps)
      }
      if (process.env.NODE_ENV !== 'production')
        verifyPlainObject(props, displayName, methodName)
      return props
    }

</code></pre>
<p>这段函数，调用了其实还是调用了<code>mapStateToProps</code>或者<code>mapDipsatchToProps</code>，拿到返回的<code>state</code>或者<code>dispatch</code>，最终返回，至于其他东西实际上上是对<code>OwnProps</code>做的一些处理</p>
</li>
</ul>
<p>我们会到之前说的那两个函数，已讲其一, <strong>注意：之前忘记说了，<code>whenMapStateToPropsIsMissing</code>函数实际上是先执行的。。</strong></p>
<pre><code class="language-javascript">export function whenMapStateToPropsIsFunction(mapStateToProps) {
  // 判断是否是函数，如果是调用wrapMapToPropsFunc
  return typeof mapStateToProps === 'function'
    ? wrapMapToPropsFunc(mapStateToProps, 'mapStateToProps')
    : undefined
}
export function whenMapStateToPropsIsMissing(mapStateToProps) {
  return !mapStateToProps ? wrapMapToPropsConstant(() =&gt; ({})) : undefined
}

export default [whenMapStateToPropsIsFunction, whenMapStateToPropsIsMissing]
</code></pre>
<pre><code class="language-javascript">export function whenMapStateToPropsIsMissing(mapStateToProps) {
  return !mapStateToProps ? wrapMapToPropsConstant(() =&gt; ({})) : undefined
}
</code></pre>
<p><code>whenMapStateToPropsIsMissing</code>函数实现就非常简单了，它是防止我们没有传入<code>mapStateToProps</code>,就设置了一个默认函数，他没有做任何事情</p>
<p>讲完上面这些，回到<code>connect</code>函数</p>
<pre><code class="language-javascript">
    const initMapDispatchToProps = match(
      mapDispatchToProps,
      mapDispatchToPropsFactories,
      'mapDispatchToProps'
    )
    
   
</code></pre>
<p>需要注意的是,它的第二个参数是<code>mapDispatchToPropsFactories</code></p>
<h4 id="mapdispatchtoprops">mapDispatchToProps</h4>
<pre><code class="language-javascript">import { bindActionCreators } from 'redux'
import { wrapMapToPropsConstant, wrapMapToPropsFunc } from './wrapMapToProps'

export function whenMapDispatchToPropsIsFunction(mapDispatchToProps) {
  return typeof mapDispatchToProps === 'function'
    ? wrapMapToPropsFunc(mapDispatchToProps, 'mapDispatchToProps')
    : undefined
}

export function whenMapDispatchToPropsIsMissing(mapDispatchToProps) {
  return !mapDispatchToProps
    ? wrapMapToPropsConstant(dispatch =&gt; ({ dispatch }))
    : undefined
}

export function whenMapDispatchToPropsIsObject(mapDispatchToProps) {
  return mapDispatchToProps &amp;&amp; typeof mapDispatchToProps === 'object'
    ? wrapMapToPropsConstant(dispatch =&gt;
        bindActionCreators(mapDispatchToProps, dispatch)
      )
    : undefined
}

export default [
  whenMapDispatchToPropsIsFunction,
  whenMapDispatchToPropsIsMissing,
  whenMapDispatchToPropsIsObject
]

</code></pre>
<p>可以看到，<code>mapDispatchToProps</code>,经过了三次处理，其他两个不讲，主要讲一下<code>whenMapDispatchToPropsIsObject</code></p>
<pre><code class="language-javascript">export function whenMapDispatchToPropsIsObject(mapDispatchToProps) {
  return mapDispatchToProps &amp;&amp; typeof mapDispatchToProps === 'object'
    ? wrapMapToPropsConstant(dispatch =&gt;
        bindActionCreators(mapDispatchToProps, dispatch)
      )
    : undefined
}
</code></pre>
<p>在看这段代码之前，我其实是不知道<code>actionCreator</code>可以直接作为<code>mapDispatchToProps</code>的，如果传递的是一个对象，那么每个定义在该对象的函数都将被当作 Redux action creator，对象所定义的方法名将作为属性名，举个例子</p>
<pre><code class="language-javascript">import actionCreators from './actionCreators'
connct(mapStateToProps, actionCreators)(App)
</code></pre>
<p>在来看看<code>wrapMapToPropsConstant</code>函数实现,直接看注释</p>
<pre><code class="language-javascript">export function wrapMapToPropsConstant(getConstant) {
  return function initConstantSelector(dispatch, options) {
    // 调用getConstant，实际上调用了bindActionCreators
    const constant = getConstant(dispatch, options)
    function constantSelector() {
      return constant
    }
    // 没有依赖自己定义的props
    constantSelector.dependsOnOwnProps = false
    // 返回新mapDispatchToProps函数
    return constantSeletor
  }
}
</code></pre>
<p>讲完<code>mapDispatchToProps</code>回到<code>connect</code></p>
<h4 id="mergeprops">mergeProps</h4>
<pre><code class="language-javascript"> const initMergeProps = match(mergeProps, mergePropsFactories, 'mergeProps')
</code></pre>
<p><code>mergeProps</code>是什么鬼，其实在看源码之前，我是不知道这个api的，官网说明是这样的:</p>
<p><strong>[<code>mergeProps(stateProps, dispatchProps, ownProps): props</code>] (<em>Function</em>): 如果指定了这个参数，<code>mapStateToProps()</code> 与 <code>mapDispatchToProps()</code> 的执行结果和组件自身的 <code>props</code> 将传入到这个回调函数中。该回调函数返回的对象将作为 props 传递到被包装的组件中。你也许可以用这个回调函数，根据组件的 props 来筛选部分的 state 数据，或者把 props 中的某个特定变量与 action creator 绑定在一起。如果你省略这个参数，默认情况下返回 <code>Object.assign({}, ownProps, stateProps, dispatchProps)</code> 的结果。</strong></p>
<p>好东西！这个API，其实挺有用的，可以对<code>props</code>中的<code>state, dispatch, ownProps</code>进行筛选，它是一个函数，返回值将作为<code>props</code>传给组件</p>
<p>说完这些有个东西需要注意,<code>mergePropsFactories</code>,第二个参数是<code>mergePropsFactories</code></p>
<pre><code class="language-javascript">export function whenMergePropsIsFunction(mergeProps) {
  return typeof mergeProps === 'function'
    ? wrapMergePropsFunc(mergeProps)
    : undefined
}

export function whenMergePropsIsOmitted(mergeProps) {
  return !mergeProps ? () =&gt; defaultMergeProps : undefined
}

export default [whenMergePropsIsFunction, whenMergePropsIsOmitted]

</code></pre>
<p>其他不看，只看<code>wrapMergePropsFunc</code></p>
<pre><code class="language-javascript">export function wrapMergePropsFunc(mergeProps) {
  return function initMergePropsProxy(
    dispatch,
    { displayName, pure, areMergedPropsEqual }
  ) {
    let hasRunOnce = false
    let mergedProps

    return function mergePropsProxy(stateProps, dispatchProps, ownProps) {
      const nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps)

      if (hasRunOnce) {
        if (!pure || !areMergedPropsEqual(nextMergedProps, mergedProps))
          mergedProps = nextMergedProps
      } else {
        hasRunOnce = true
        mergedProps = nextMergedProps

        if (process.env.NODE_ENV !== 'production')
          verifyPlainObject(mergedProps, displayName, 'mergeProps')
      }

      return mergedProps
    }
  }
}
</code></pre>
<p>其实看过<code>mergeProps</code>用法的同学，猜都能猜到它做了什么，没错，传入三个参数</p>
<pre><code class="language-javascript"> const nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps)
</code></pre>
<p>最终还是返回了这个合并后的<code>props</code>，其他的我就不讲了，也很好理解</p>
<p>再回到<code>conncet</code></p>
<pre><code class="language-javascript">    return connectHOC(selectorFactory, {
      // used in error messages
      methodName: 'connect',

      // used to compute Connect's displayName from the wrapped component's displayName.
      getDisplayName: name =&gt; `Connect(${name})`,

      // if mapStateToProps is falsy, the Connect component doesn't subscribe to store state changes
      shouldHandleStateChanges: Boolean(mapStateToProps),
      initMapStateToProps,
      initMapDispatchToProps,
      initMergeProps,
      pure,
      areStatesEqual,
      areOwnPropsEqual,
      areStatePropsEqual,
      areMergedPropsEqual,

      // any extra options args can override defaults of connect or connectAdvanced
      ...extraOptions
    })
</code></pre>
<p><code>connectHOC</code>其实就是<code>connectAdvanced</code>,这在前面也有讲过，它最终返回了一个高阶组件，而且是<code>pure</code>组件，这里我们主要关注<code>selectorFactory</code></p>
<pre><code class="language-javascript">export default function finalPropsSelectorFactory(
  dispatch,
  { initMapStateToProps, initMapDispatchToProps, initMergeProps, ...options }
) {
  const mapStateToProps = initMapStateToProps(dispatch, options)
  const mapDispatchToProps = initMapDispatchToProps(dispatch, options)
  const mergeProps = initMergeProps(dispatch, options)

  if (process.env.NODE_ENV !== 'production') {
    verifySubselectors(
      mapStateToProps,
      mapDispatchToProps,
      mergeProps,
      options.displayName
    )
  }

  const selectorFactory = options.pure
    ? pureFinalPropsSelectorFactory
    : impureFinalPropsSelectorFactory

  return selectorFactory(
    mapStateToProps,
    mapDispatchToProps,
    mergeProps,
    dispatch,
    options
  )
}
</code></pre>
<p>这段代码其实也挺好理解，前三行调用了被处理过的<code>mapStateToProps</code>,<code>mapDispatchToProps</code>, <code>mergeProps</code>，拿到最新的<code>props</code>，然后是对这些<code>props</code>进行校验</p>
<pre><code class="language-javascript">  const selectorFactory = options.pure
    ? pureFinalPropsSelectorFactory
    : impureFinalPropsSelectorFactory
</code></pre>
<p>然后是这一段，<code>pure</code>在默认情况下为true</p>
<p>一看吓一跳，又是这么长的代码。。。。,</p>
<pre><code class="language-javascript">export function pureFinalPropsSelectorFactory(
  mapStateToProps,
  mapDispatchToProps,
  mergeProps,
  dispatch,
  { areStatesEqual, areOwnPropsEqual, areStatePropsEqual }
) {
  let hasRunAtLeastOnce = false
  let state
  let ownProps
  let stateProps
  let dispatchProps
  let mergedProps

  // ....
  return function pureFinalPropsSelector(nextState, nextOwnProps) {
    return hasRunAtLeastOnce
      ? handleSubsequentCalls(nextState, nextOwnProps)
      : handleFirstCall(nextState, nextOwnProps)
  }
}
</code></pre>
<p>其他我先省略掉，太多，只看返回的函数,从名字就可以知道，它是最终的<code>selector</code>，我们去看下它是在哪被调用的</p>
<pre><code class="language-javascript">// connectAdvanced.js    

const selectorFactoryOptions = {
  ...connectOptions,
  getDisplayName, // 计算连接器组件相对于被包裹的组件的 DisplayName 属性。 通常被包裹函数覆盖。 默认值: name =&gt; 'ConnectAdvanced('+name+')'
  methodName,  // 示在错误消息中。 通常被包裹函数覆盖。 默认值: 'connectAdvanced'
  renderCountProp,// 如果被定义, 名为此值的属性将添加到传递给被包裹组件的 props 中。它的值将是组件被渲染的次数，这对于跟踪不必要的重新渲染非常有用。默认值: undefined
  shouldHandleStateChanges, // 控制连接器（connector）组件是否订阅 redux store 的 state 更改。 如果设置为 false，则只会在componentWillReceiveProps中重新渲染。 默认值: true
  storeKey,// 可以获取 store 的 props/context key。 当你不明智地使用了多个 store 的时候，你才可能需要这个
  displayName,
  wrappedComponentName,
  WrappedComponent
}

...
function createChildSelector(store) {
   return selectorFactory(store.dispatch, selectorFactoryOptions)
}

...
const childPropsSelector = useMemo(() =&gt; {
    return createChildSelector(store)
}, [store])
</code></pre>
<p>如果是第一次调用<code>hasRunAtLeastOnce</code>肯定为false,所以会执行<code>handleFirstCall</code></p>
<pre><code class="language-javascript">  function handleFirstCall(firstState, firstOwnProps) {
    state = firstState  // dispatch
    ownProps = firstOwnProps  // selectorFactoryOptions
    stateProps = mapStateToProps(state, ownProps)
    dispatchProps = mapDispatchToProps(dispatch, ownProps)
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps)
    hasRunAtLeastOnce = true
    return mergedProps 
  }

</code></pre>
<p>看完这些需要注意：<code>hasRunAtLeastOnce = true</code>,也就说它只能被执行依次，下一次将会执行<code>impureFinalPropsSelectorFactory</code></p>
<pre><code class="language-javascript">export function impureFinalPropsSelectorFactory(
  mapStateToProps,
  mapDispatchToProps,
  mergeProps,
  dispatch
) {
  return function impureFinalPropsSelector(state, ownProps) {
    return mergeProps(
      mapStateToProps(state, ownProps),
      mapDispatchToProps(dispatch, ownProps),
      ownProps
    )
  }
}
</code></pre>
<p>这段代码，eemmmm,各位大佬还需要我说吗。。</p>
<p>所以整个<code>finalPropsSelectorFactory</code>函数做的事情就是，判断是否是第一次执行来返回对应的<code>selector</code></p>
<p>至此<code>connect</code>也讲完了，还有那些api还没讲呢</p>
<pre><code class="language-javascript">  useDispatch,
  useSelector,
  useStore,
  shallowEqual
</code></pre>
<p>还有这些，看源码的道路真的很漫长，。</p>
<h3 id="usestore">useStore</h3>
<p>可以拿到<code>context</code>中的<code>store</code></p>
<pre><code class="language-javascript">export function useStore() {
  const { store } = useReduxContext()
  return store
}

export function useReduxContext() {
  const contextValue = useContext(ReactReduxContext)
  invariant(
    contextValue,
    'could not find react-redux context value; please ensure the component is wrapped in a &lt;Provider&gt;'
  )
  return contextValue
}
</code></pre>
<p>它的实现也很简单，利用了<code>useContext</code>这个React Hooks</p>
<h3 id="usedispatch">useDispatch</h3>
<p>拿到<code>store</code>中的<code>dispatch</code>函数</p>
<pre><code class="language-javascript">export function useDispatch() {
  const store = useStore()
  return store.dispatch
}
</code></pre>
<p>本质上调用了<code>useStore</code>,返回<code>store.dispatch</code></p>
<h3 id="useselector">useSelector</h3>
<p>能自定义<code>selector</code>，筛选数据</p>
<pre><code class="language-javascript">export function useSelector(selector, equalityFn = refEquality) {
  invariant(selector, `You must pass a selector to useSelectors`)

  // 
  const { store, subscription: contextSub } = useReduxContext()
 
  const [, forceRender] = useReducer(s =&gt; s + 1, 0)

  // 如果store发生变化，Subscription对象
  const subscription = useMemo(() =&gt; new Subscription(store, contextSub), [
    store,
    contextSub
  ])

  const latestSubscriptionCallbackError = useRef()
  // 最新的selector
  const latestSelector = useRef()
  // 最新的selector返回的state
  const latestSelectedState = useRef()

  let selectedState

  try {
    if (
      selector !== latestSelector.current ||
      latestSubscriptionCallbackError.current
    ) {
      // 第一次调用selector,传入最新的state
      selectedState = selector(store.getState())
    } else {
      selectedState = latestSelectedState.current
    }
  } catch (err) {
    let errorMessage = `An error occured while selecting the store state: ${err.message}.`

    if (latestSubscriptionCallbackError.current) {
      errorMessage += `\nThe error may be correlated with this previous error:\n${latestSubscriptionCallbackError.current.stack}\n\nOriginal stack trace:`
    }

    throw new Error(errorMessage)
  }

    // 使用useIsomorphicLayoutEffect能够执行一些副作用操作
  useIsomorphicLayoutEffect(() =&gt; {
    latestSelector.current = selector
    latestSelectedState.current = selectedState
    latestSubscriptionCallbackError.current = undefined
  })

  useIsomorphicLayoutEffect(() =&gt; {
    function checkForUpdates() {
      try {
        // 调用selector
        const newSelectedState = latestSelector.current(store.getState())
        if (equalityFn(newSelectedState, latestSelectedState.current)) {
          return
        }

         // 设置最新的state
        latestSelectedState.current = newSelectedState
      } catch (err) {
        latestSubscriptionCallbackError.current = err
      }

      // 强制组件渲染
      forceRender({})
    }

    // 重新设置通知函数
    subscription.onStateChange = checkForUpdates
    // 订阅checkForUpdates函数
    subscription.trySubscribe()
    checkForUpdates()
    return () =&gt; subscription.tryUnsubscribe()
  }, [store, subscription])
  return selectedState
}

</code></pre>
<p>整个函数所作的事</p>
<ol>
<li>设置最新的<code>selector</code>和它返回的最新<code>state</code>，下次调用如果没有发生变化，就使用之前的<code>state</code></li>
<li>在组件渲染以后，重新订阅<code>checkForUpdates函数</code>, 当调用<code>dispatch</code>,更新<code>state</code>,会触发<code>checkForUpdates</code>,执行<code>selector</code>,传入最新的<code>state</code></li>
</ol>
<h2 id="总结">总结</h2>
<p>整篇文章总体来说，写的不太好，因为<code>react-redux</code>相对<code>redux</code>更难一些，也比较绕，不太好写，有很多东西可能没有讲到，在以后我会继续补充这篇文章，有问题欢迎指正，谢谢</p>
<h2 id="下一章">下一章</h2>
<p>逐行级源码分析系列(三) Vue-Router源码</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0">系列文章</a></li>
<li><a href="#redux">Redux</a>
<ul>
<li><a href="#%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90">一个例子</a></li>
<li><a href="#%E5%85%A5%E5%8F%A3">入口</a></li>
<li><a href="#createstore">createStore</a>
<ul>
<li><a href="#getstate">getState</a></li>
<li><a href="#subscribe">subscribe</a></li>
<li><a href="#dispatch">dispatch</a></li>
<li><a href="#replacereducer">replaceReducer</a></li>
<li><a href="#observable">observable</a></li>
</ul>
</li>
<li><a href="#bindactioncreators">bindActionCreators</a></li>
<li><a href="#combinereducers">combineReducers</a></li>
<li><a href="#applymiddleware">applyMiddleware</a></li>
<li><a href="#compose">compose</a></li>
<li><a href="#logger%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%9E%E7%8E%B0">logger中间件实现</a></li>
<li><a href="#redux-thunk%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%9E%E7%8E%B0">redux-thunk中间件实现</a></li>
<li><a href="#redux-promise%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%9E%E7%8E%B0">redux-promise中间件实现</a></li>
</ul>
</li>
<li><a href="#react-redux">React-Redux</a>
<ul>
<li><a href="#batch">batch</a></li>
<li><a href="#provider">Provider</a>
<ul>
<li><a href="#createlistenercollection">createListenerCollection</a>
<ul>
<li><a href="#1notify">1.notify</a></li>
<li><a href="#2subscribe">2.subscribe</a></li>
<li><a href="#3get">3.get</a></li>
<li><a href="#4clear">4.clear</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#connectadvanced">connectAdvanced</a>
<ul>
<li><a href="#%E5%8F%82%E6%95%B0">参数</a></li>
<li><a href="#%E8%BF%94%E5%9B%9E%E5%80%BC">返回值</a>
<ul>
<li><a href="#%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7">静态属性</a></li>
<li><a href="#%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0">静态函数</a></li>
<li><a href="#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95">实例方法</a></li>
</ul>
</li>
<li><a href="#%E6%B3%A8%E6%84%8F">注意</a></li>
<li><a href="#wrapwithconnect">wrapWithConnect</a></li>
<li><a href="#connectfunction">ConnectFunction</a></li>
</ul>
</li>
<li><a href="#connect">connect</a>
<ul>
<li><a href="#mapstatetoprops">mapStateToProps</a></li>
<li><a href="#mapdispatchtoprops">mapDispatchToProps</a></li>
<li><a href="#mergeprops">mergeProps</a></li>
</ul>
</li>
<li><a href="#usestore">useStore</a></li>
<li><a href="#usedispatch">useDispatch</a></li>
<li><a href="#useselector">useSelector</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
<li><a href="#%E4%B8%8B%E4%B8%80%E7%AB%A0">下一章</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://1131153523.github.io/post/zhu-xing-ji-yuan-ma-fen-xi-xi-lie-yi-vuex">
              <h3 class="post-title">
                逐行级源码分析系列(一) Vuex
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '3f095dc7caed6dad1561',
    clientSecret: 'b6ccfd57b551f8c2d30e2bc5bcad2b1df5b23dc9',
    repo: '1131153523.github.io',
    owner: '1131153523',
    admin: ['1131153523'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
   | 
  <a class="rss" href="https://1131153523.github.io/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()

  let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

  // This should probably be throttled.
  // Especially because it triggers during smooth scrolling.
  // https://lodash.com/docs/4.17.10#throttle
  // You could do like...
  // window.addEventListener("scroll", () => {
  //    _.throttle(doThatStuff, 100);
  // });
  // Only not doing it here to keep this Pen dependency-free.

  window.addEventListener("scroll", event => {
    let fromTop = window.scrollY;

    mainNavLinks.forEach((link, index) => {
      let section = document.getElementById(decodeURI(link.hash).substring(1));
      let nextSection = null
      if (mainNavLinks[index + 1]) {
        nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
      }
      console.log('section.offsetHeight', section.offsetHeight);
      if (section.offsetTop <= fromTop) {
        if (nextSection) {
          if (nextSection.offsetTop > fromTop) {
            link.classList.add("current");
          } else {
            link.classList.remove("current");    
          }
        } else {
          link.classList.add("current");
        }
      } else {
        link.classList.remove("current");
      }
    });
  });

</script>

      </div>
    </div>
  </body>
</html>
